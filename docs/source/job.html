<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">onix.factory(&quot;$job&quot;, [
	&quot;$q&quot;,
function(
	$q
) {
<span id='$job'>	/**
</span>	 * Factory for manage multiple tasks.
	 * 
 	 * @class $job
 	 */
	var $job = function() {
		this._donePromise = $q.defer();
		this._tasks = [];
		this._taskDone = {
			cb: null,
			scope: null
		};
	};

<span id='$job-method-add'>	/**
</span>	 * Add task to job. Every job task needs to call doneFn(), which is added to the last argument position.
	 * 
	 * @param {Function} task Job function
	 * @param {Function|Object} [scope] Variable function scope
	 * @param {Object} [args] Add params to the function
	 * @member $job
	 */
	$job.prototype.add = function(task, scope, args) {
		args = args || [];

		if (!Array.isArray(args)) {
			args = [args];
		}

		this._tasks.push({
			task: task,
			scope: scope,
			args: args
		});
	};

<span id='$job-method-start'>	/**
</span>	 * Start job.
	 *
	 * @member $job
	 */
	$job.prototype.start = function() {
		if (!this._tasks.length) return;

		// because of pop
		this._tasks.reverse();

		this._doJob();

		return this._donePromise;
	};

<span id='$job-method-clear'>	/**
</span>	 * Clear all job taks.
	 *
	 * @member $job
	 */
	$job.prototype.clear = function() {
		this._tasks = [];
	};

<span id='$job-method-setTaskDone'>	/**
</span>	 * Set progress function, which will be called after each task will be done.
	 * 
	 * @param {Function} cb
	 * @param {Function|Object} [scope]
	 * @member $job
	 */
	$job.prototype.setTaskDone = function(cb, scope) {
		this._taskDone.cb = cb;
		this._taskDone.scope = scope;
	};

<span id='$job-method-_doJob'>	/**
</span>	 * Internal function for running job queue.
	 *
	 * @member $job
	 */
	$job.prototype._doJob = function() {
		var rest = this._tasks.length;

		if (rest == 0) {
			this._donePromise.resolve();
		}
		else {
			var job = this._tasks.pop();

			var doneFn = function() {
				if (this._taskDone.cb) {
					var doneFnArgs = Array.prototype.slice.call(arguments, 0);

					this._taskDone.cb.apply(this._taskDone.scope || this._taskDone.cb, doneFnArgs);
				}

				this._doJob();
			}.bind(this);

			job.task.apply(job.scope || job.task, job.args.concat(doneFn));
		}
	};

	return {
<span id='$job-method-create'>		/**
</span>		 * Factory for creating new job.
		 *
		 * @member $job
		 */
		create: function() {
			return new $job();
		},

<span id='$job-method-multipleJobs'>		/**
</span>		 * Run jobs array with count for how many functions will be processed simultinously.
		 *
		 * @param  {Object[]} jobsArray Array with jobs objects
		 * @param  {Function} jobsArray.task Job function
		 * @param  {Function} [jobsArray.scope] Variable function scope
		 * @param  {Function} [jobsArray.args] Add params to the function
		 * @param  {Number} count How many functions processed simultinously
		 * @param  {Object} taskDoneObj Callback after one task have been done
		 * @param  {Object} taskDoneObj.cb Function
		 * @param  {Object} [taskDoneObj.scope] Function scope
		 * @return {$q} Callback after all jobs are done
		 * @member $job
		 */
		multipleJobs: function(jobsArray, count, taskDoneObj) {
			var len = jobsArray.length;
			var jobs = [];

			for (var i = 0; i &lt; len; i++) {
				var jp = count &gt; 0 ? i % count : i;
				var jobItem = jobsArray[i];

				if (!jobs[jp]) {
					jobs[jp] = this.create();

					if (taskDoneObj) {
						jobs[jp].setTaskDone(taskDoneObj.cb, taskDoneObj.scope);
					}
				}

				// add one job
				jobs[jp].add(jobItem.task, jobItem.scope, jobItem.args);
			}

			var jobPromises = [];

			jobs.forEach(function(job) {
				jobPromises.push(job.start());
			});

			return $q.all(jobPromises);
		}
	};
}]);
</pre>
</body>
</html>
