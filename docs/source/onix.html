<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">onix = (function() {
<span id='$module'>	/**
</span>	 * Module object - handles one module object with services, factories etc.
	 * This object cannot be used in dependency injection!
	 * 
	 * @class $module
	 */
	var $module = function(name, dependencies) {
<span id='$module-property-_objects'>		/**
</span>		 * All objects.
		 *
		 * @type {Object}
		 * @member $module
		 * @private
		 */
		this._objects = {};

<span id='$module-property-_runs'>		/**
</span>		 * All run objects.
		 *
		 * @type {Object}
		 * @member $module
		 * @private
		 */
		this._runs = [];

<span id='$module-property-_configs'>		/**
</span>		 * All config objects.
		 *
		 * @type {Object}
		 * @member $module
		 * @private
		 */
		this._configs = [];

<span id='$module-property-_name'>		/**
</span>		 * Module name.
		 * 
		 * @type {String}
		 * @member $module
		 * @private
		 */
		this._name = name || &quot;&quot;;

<span id='$module-property-_dependencies'>		/**
</span>		 * Module dependencies.
		 * 
		 * @type {Array}
		 * @member $module
		 * @private
		 */
		this._dependencies = dependencies || [];
	};

<span id='$module-property-CONST'>	/**
</span>	 * Module constants.
	 *
	 * @property {Object}
	 * @type {Object}
	 * @member $module
	 * @private
	 */
	$module.CONST = {
		PROVIDER_NAME: &quot;Provider&quot;,
		FILTER_NAME: &quot;$filter&quot;,
		TYPE: {
			PROVIDER: 1,
			SERVICE: 2,
			FACTORY: 3,
			CONSTANT: 4,
			VALUE: 5,
			FILTER: 6,
			CONFIG: 7,
			RUN: 8
		}
	};

<span id='$module-property-parseParam'>	/**
</span>	 * Parse parameters. From param parse function and dependencies.
	 *
	 * @property {Function}
	 * @param  {Array|Function} param 
	 * @return {Object} Parse object
	 * @member $module
	 */
	$module.parseParam = function(param) {
		var fn;
		var inject = [];

		if (Array.isArray(param)) {
			param.every(function(item) {
				if (typeof item === &quot;function&quot;) {
					fn = item;
					return false;
				}
				else if (typeof item === &quot;string&quot;) {
					inject.push(item);
				}

				return true;
			}, this);
		}
		else {
			fn = param;
		}

		return {
			fn: fn,
			inject: inject
		}
	};

<span id='$module-method-getFilterName'>	/**
</span>	 * Get filter name.
	 * 
	 * @param  {String} name
	 * @return {String}
	 * @member $module
	 */
	$module.getFilterName = function(name) {
		name = name || &quot;&quot;;

		return $module.CONST.FILTER_NAME + name[0].toUpperCase() + name.substr(1, name.length - 1);
	};

<span id='$module-method-getDependencies'>	/**
</span>	 * Get dependencies.
	 * 
	 * @return {Array}
	 * @member $module
	 */
	$module.prototype.getDependencies = function() {
		return this._dependencies;
	};

<span id='$module-method-getName'>	/**
</span>	 * Get module name.
	 * 
	 * @return {String}
	 * @member $module
	 */
	$module.prototype.getName = function() {
		return this._name;
	};

<span id='$module-method-getConfigs'>	/**
</span>	 * Get module configs.
	 * 
	 * @return {Array}
	 * @member $module
	 */
	$module.prototype.getConfigs = function() {
		return this._configs;
	};

<span id='$module-method-getRuns'>	/**
</span>	 * Get module runs.
	 * 
	 * @return {Array}
	 * @member $module
	 */
	$module.prototype.getRuns = function() {
		return this._runs;
	};

<span id='$module-method-getObjects'>	/**
</span>	 * Get module objects.
	 * 
	 * @return {Array}
	 * @member $module
	 */
	$module.prototype.getObjects = function() {
		return this._objects;
	};

<span id='$module-method-provider'>	/**
</span>	 * Add provider to the application.
	 *
	 * @chainable
	 * @param  {String} name 
	 * @param  {Function} param
	 * @member $module
	 */
	$module.prototype.provider = function(name, param) {
		if (!name || !param) {
			return this;
		}

		var pp = $module.parseParam(param);

		this._objects[name + $module.CONST.PROVIDER_NAME] = {
			name: name + $module.CONST.PROVIDER_NAME,
			inject: pp.inject,
			fn: pp.fn,
			cache: null,
			type: $module.CONST.TYPE.PROVIDER
		};

		this._objects[name] = {
			name: name,
			inject: null,
			fn: null,
			cache: null,
			provider: name + $module.CONST.PROVIDER_NAME,
			type: $module.CONST.TYPE.FACTORY
		};

		return this;
	};

<span id='$module-method-service'>	/**
</span>	 * Add service to the application.
	 *
	 * @chainable
	 * @param  {String} name 
	 * @param  {Function|Array} param
	 * @member $module
	 */
	$module.prototype.service = function(name, param) {
		if (!name || !param) {
			return this;
		}

		var pp = $module.parseParam(param);

		this._objects[name] = {
			name: name,
			inject: pp.inject,
			fn: pp.fn,
			cache: null,
			type: $module.CONST.TYPE.SERVICE
		};

		return this;
	};

<span id='$module-method-factory'>	/**
</span>	 * Add factory to the application.
	 *
	 * @chainable
	 * @param  {String} name 
	 * @param  {Function|Array} param
	 * @member $module
	 */
	$module.prototype.factory = function(name, param) {
		if (!name || !param) {
			return this;
		}

		var pp = $module.parseParam(param);

		this._objects[name] = {
			name: name,
			inject: pp.inject,
			fn: pp.fn,
			cache: null,
			type: $module.CONST.TYPE.FACTORY
		};

		return this;
	};

<span id='$module-method-constant'>	/**
</span>	 * Add new constant.
	 *
	 * @chainable
	 * @param  {String} name
	 * @param  {Object} param
	 * @member $module
	 */
	$module.prototype.constant = function(name, obj) {
		if (!name || !obj) {
			return this;
		}

		this._objects[name] = {
			name: name,
			cache: obj,
			type: $module.CONST.TYPE.CONSTANT
		};

		return this;
	};

<span id='$module-method-value'>	/**
</span>	 * Add a new value.
	 *
	 * @chainable
	 * @param  {String} name
	 * @param  {Object} param
	 * @member $module
	 */
	$module.prototype.value = function(name, obj) {
		if (!name || !obj) {
			return this;
		}

		this._objects[name] = {
			name: name,
			cache: obj,
			type: $module.CONST.TYPE.VALUE
		};

		return this;
	};

<span id='$module-method-filter'>	/**
</span>	 * Add filter to the application.
	 *
	 * @chainable
	 * @param  {String} name 
	 * @param  {Function|Array} param
	 * @member $module
	 */
	$module.prototype.filter = function(name, param) {
		if (!name || !param) {
			return this;
		}

		var pp = $module.parseParam(param);

		this._objects[$module.getFilterName(name)] = {
			name: name,
			inject: pp.inject,
			fn: pp.fn,
			cache: null,
			type: $module.CONST.TYPE.FILTER
		};

		return this;
	};

<span id='$module-method-config'>	/**
</span>	 * Add a new config.
	 *
	 * @chainable
	 * @param  {Array|Function} param With DI
	 * @member $module
	 */
	$module.prototype.config = function(param) {
		if (!param) {
			return this;
		}

		var pp = $module.parseParam(param);

		this._configs.push({
			fn: pp.fn,
			inject: pp.inject,
			type: $module.CONST.TYPE.CONFIG
		});

		return this;
	};

<span id='$module-method-run'>	/**
</span>	 * Add a new run.
	 * 
	 * @param  {Array|Function} param With DI
	 * @member $module
	 */
	$module.prototype.run = function(param) {
		if (!param) {
			return this;
		}

		var pp = $module.parseParam(param);

		this._runs.push({
			fn: pp.fn,
			inject: pp.inject,
			type: $module.CONST.TYPE.RUN
		});

		return this;
	};

<span id='$modules'>	/**
</span>	 * Modules object - handles all modules in the application; runs object.
	 * This object cannot be used in dependency injection!
	 *
	 * @class $modules
	 */
	var $modules = {
<span id='$modules-property-_modules'>		/**
</span>		 * All modules array.
		 *
		 * @private
		 * @member $modules
		 * @type {Array}
		 */
		_modules: [],

<span id='$modules-property-_modulesObj'>		/**
</span>		 * All modules object - quick access.
		 *
		 * @private
		 * @member $modules
		 * @type {Object}
		 */
		_modulesObj: {},

<span id='$modules-property-_CONST'>		/**
</span>		 * Modules constants.
		 *
		 * @private
		 * @member $modules
		 * @type {Ojbect}
		 */
		_CONST: {
			MODULE_SEPARATOR: &quot;::&quot;,
		},

<span id='$modules-method-_noop'>		/**
</span>		 * Function which does nothing.
		 *
		 * @private
		 * @member $modules
		 */
		_noop: function() {

		},

<span id='$modules-method-domLoad'>		/**
</span>		 * Event - Dom LOAD.
		 *
		 * @member $modules
		 */
		domLoad: function() {
			var configs = [];
			var runs = [];

			this._modules.forEach(function(module) {
				var error = false;
				var dependencies = module.getDependencies();

				dependencies.every(function(dep) {
					if (!(dep in this._modulesObj)) {
						console.error(&quot;Module &#39;&quot; + this._name + &quot;&#39; dependency &#39;&quot; + dep + &quot;&#39; not found!&quot;);
						error = true;
						return false;
					}
					else {
						return true;
					}
				}, this);

				if (!error) {
					configs = configs.concat(module.getConfigs());
					runs = runs.concat(module.getRuns());
				}
			}, this);

			// run all configs
			configs.forEach(function(config) {
				this.run(config, true);
			}, this);

			// run all runs
			runs.forEach(function(run) {
				this.run(run);
			}, this);
		},

<span id='$modules-method-_getObject'>		/**
</span>		 * Get object by his name.
		 *
		 * @param {String} name Object name
		 * @return {Object} Object data
		 * @member $modules
		 * @private
		 */
		_getObject: function(name) {
			var output = null;

			var searchModuleName = &quot;&quot;;
			var searchObjectName = &quot;&quot;;

			if (name.indexOf(this._CONST.MODULE_SEPARATOR) != -1) {
				var parts = name.split(this._CONST.MODULE_SEPARATOR);

				if (parts.length == 2) {
					searchModuleName = parts[0];
					searchObjectName = parts[1];
				}
				else {
					console.error(&quot;Get object &quot; + name + &quot; error! Wrong module separator use.&quot;);
					return null;
				}
			}
			else {
				searchObjectName = name;
			}

			this._modules.every(function(module) {
				var moduleObjects = module.getObjects();

				if (searchModuleName) {
					if (module.getName() != searchModuleName) return true;

					if (searchObjectName in moduleObjects) {
						output = moduleObjects[searchObjectName];
						return false;
					}
					else {
						console.error(&quot;Get object &quot; + searchObjectName + &quot; error! Cannot find object in the module &quot; + searchModuleName + &quot;.&quot;);
						return false;
					}
				}
				else {
					if (searchObjectName in moduleObjects) {
						output = moduleObjects[searchObjectName];
						return false;
					}
					else return true;
				}
			});

			return output;
		},

<span id='$modules-method-run'>		/**
</span>		 * Run object configuration; returns his cache (data).
		 *
		 * @param  {Object}  obj Object configuration
		 * @param  {Boolean} [isConfig] Is config phase?
		 * @param  {Array} [parent] Parent objects
		 * @return {Object}
		 * @member $modules
		 */
		run: function(obj, isConfig, parent) {
			parent = parent || [];

			if (parent.indexOf(obj.name) != -1) {
				console.error(&quot;Circular dependency error! Object name: &quot; + obj.name + &quot;, parents: &quot; + parent.join(&quot;|&quot;));
				return null;
			}

			var inject = [];

			if (obj.provider) {
				var providerObj = this._getObject(obj.provider);

				if (!providerObj.cache) {
					var providerFn = providerObj.fn || this._noop;
					providerObj.cache = new providerFn();
				}

				var getFn = providerObj.cache[&quot;$get&quot;] || this._noop;
				var pp = $module.parseParam(getFn);

				obj.fn = pp.fn;
				obj.inject = pp.inject;

				delete obj.provider;
			}

			if (obj.inject &amp;&amp; obj.inject.length) {
				obj.inject.forEach(function(objName) {
					if (typeof objName === &quot;string&quot;) {
						var injObj = this._getObject(objName);

						if (!injObj) {
							console.error(&quot;Object name: &quot; + objName + &quot; not found!&quot;);
							inject.push(null);
						}
						else {
							inject.push(this.run(injObj, isConfig, obj.name ? parent.concat(obj.name) : parent));
						}
					}
					else if (typeof objName === &quot;object&quot;) {
						inject.push(objName);
					}
				}, this);
			}

			// config phase
			if (isConfig) {
				switch (obj.type) {
					case $module.CONST.TYPE.PROVIDER:
						if (!obj.cache) {
							var fn = obj.fn || this._noop;
							obj.cache = new fn();
						}

						return obj.cache;
						break;

					case $module.CONST.TYPE.CONSTANT:
						return obj.cache;
						break;

					case $module.CONST.TYPE.CONFIG:
						var fn = obj.fn || this._noop;
						return fn.apply(fn, inject);
						break;

					default:
						return null;
				}
			}
			// run phase
			else {
				switch (obj.type) {
					case $module.CONST.TYPE.FACTORY:
					case $module.CONST.TYPE.FILTER:
						if (!obj.cache) {
							var fn = obj.fn || this._noop;
							obj.cache = fn.apply(fn, inject);
						}

						return obj.cache;
						break;

					case $module.CONST.TYPE.SERVICE:
						if (!obj.cache) {
							var fn = obj.fn || this._noop;
							var serviceObj = Object.create(fn.prototype);
							fn.apply(serviceObj, inject);
							obj.cache = serviceObj;
						}
						
						return obj.cache;
						break;

					case $module.CONST.TYPE.VALUE:
						return obj.cache;
						break;

					case $module.CONST.TYPE.CONSTANT:
						return obj.cache;
						break;

					case $module.CONST.TYPE.RUN:
						var fn = obj.fn || this._noop;
						return fn.apply(fn, inject);
						break;

					default:
						return null;
				}
			}
		},

<span id='$modules-method-addModule'>		/**
</span>		 * Add a new module to the application.
		 * 
		 * @param {String} name Module name
		 * @param {Array} [dependencies] Module dependencies
		 * @return {Object} Created module
		 * @member $modules
		 */
		addModule: function(name, dependencies) {
			var module = new $module(name, dependencies);

			this._modulesObj[name] = module
			this._modules.push(module);

			return module;
		}
	};

	// bind DOM ready
	document.addEventListener(&quot;DOMContentLoaded&quot;, $modules.domLoad.bind($modules));

<span id='onix'>	/**
</span>	 * Main framework object, which is created like new module with name &#39;onix&#39;.
	 * Module has addtional functions.
	 * 
	 * @class onix
	 */
	var onix = $modules.addModule(&quot;onix&quot;);

<span id='onix-method-module'>	/**
</span>	 * Add a new module to the application.
	 * 
	 * @param {String} name Module name
	 * @param {Array} [dependencies] Module dependencies
	 * @return {$module} Created module
	 * @member onix
	 */
	onix.module = function(name, dependencies) {
		return $modules.addModule(name, dependencies);
	};

<span id='onix-method-noop'>	/**
</span>	 * Empty function.
	 *
	 * @member onix
	 */
	onix.noop = function() {
	};

<span id='onix-method-info'>	/**
</span>	 * Framework info.
	 *
	 * @member onix
	 */
	onix.info = function() {
		console.log(
			&quot;OnixJS framework\n&quot; +
			&quot;2.5.2/16. 5. 2016\n&quot; +
			&quot;source: https://gitlab.com/LorDOniX/onix\n&quot; +
			&quot;documentation: https://gitlab.com/LorDOniX/onix/tree/master/docs\n&quot; +
			&quot;@license MIT\n&quot; +
			&quot;* - Free for use in both personal and commercial projects\n&quot;
		);
	};

	onix.factory(&quot;$di&quot;, function() {
<span id='$di'>		/**
</span>		 * Helper factory for dependency injection and parsing function parameters.
		 * 
		 * @class $di
		 */
		return {
<span id='$di-property-parseParam'>			/**
</span>			 * Parse parameters. From param parse function and dependencies.
			 *
			 * @property {Function}
			 * @param  {Array|Function} param 
			 * @return {Object} Parse object
			 * @member $di
			 */
			parseParam: $module.parseParam,

<span id='$di-method-getFilterName'>			/**
</span>			 * Get filter name.
			 * 
			 * @param  {String} name
			 * @return {String}
			 * @member $di
			 */
			getFilterName: $module.getFilterName,

<span id='$di-method-run'>			/**
</span>			 * Run function with possible inject - handles dependency injection.
			 * 
			 * @param  {Object} runObj
			 * @param  {Function} runObj.fn
			 * @param  {Array} runObj.inject
			 * @return {Object} Function output
			 * @member $di
			 */
			run: function(runObj) {
				if (!runObj) return null;
				
				if (!runObj.fn) {
					runObj.fn = function() {};
				}

				// def. type
				runObj.type = $module.CONST.TYPE.RUN;

				return $modules.run(runObj);
			}
		}
	});

	return onix;
})();
</pre>
</body>
</html>
