<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">onix.provider(&quot;$template&quot;, function() {
	var conf = {
		left: &quot;{{&quot;,
		right: &quot;}}&quot;
	};

<span id='$templateProvider-method-setConfig'>	/**
</span>	 * Set template config; you can use &quot;left&quot; {{ and &quot;right&quot; }} template delimeters.
	 * 
	 * @param {Object} confParam Object with new config
	 * @member $templateProvider
	 */
	this.setConfig = function(confParam) {
		Object.keys(confParam).forEach(function(confParamKey) {
			conf[confParamKey] = confParam[confParamKey];
		});
	};

<span id='$template'>	/**
</span>	 * @class $template
	 *
	 * Handle templates, binds events - syntax similar to moustache and angular template system.
	 * $myQuery is used for cache record
	 */
	this.$get = [&quot;$common&quot;, &quot;$q&quot;, &quot;$http&quot;, function(
				$common, $q, $http) {

		var $template = {
<span id='$template-property-_cache'>			/**
</span>			 * Template cache.
			 *
			 * @type {Object}
			 * @member $template
			 * @private
			 */
			_cache: {},

<span id='$template-property-_RE'>			/**
</span>			 * Regular expressions for handle template variables
			 *
			 * @type {Object}
			 * @member $template
			 * @private
			 */
			_RE: {
				VARIABLE: /[$_a-zA-Z][$_a-zA-Z0-9]+/g,
				NUMBERS: /[-]?[0-9]+[.]?([0-9e]+)?/g,
				STRINGS: /[&quot;&#39;][^&quot;&#39;]+[&quot;&#39;]/g,
				JSONS: /[{][^}]+[}]/g,
				ALL: /[-]?[0-9]+[.]?([0-9e]+)?|[&quot;&#39;][^&quot;&#39;]+[&quot;&#39;]|[{][^}]+[}]|[$_a-zA-Z][$_a-zA-Z0-9]+/g
			},

<span id='$template-method-_parseFnName'>			/**
</span>			 * Parse a function name from the string
			 *
			 * @param  {String} value
			 * @return {String}
			 * @member $template
			 * @private
			 */
			_parseFnName: function(value) {
				value = value || &quot;&quot;;

				return value.match(/[a-zA-Z0-9_]+/)[0];
			},

<span id='$template-method-_parseArgs'>			/**
</span>			 * Parse arguments from the string -&gt; makes array from them
			 *
			 * @param  {String} value
			 * @param  {Object} config
			 * @param  {Object} config.$event Event object
			 * @param  {Object} config.$element Reference to element
			 * @return {Array}
			 * @member $template
			 * @private
			 */
			_parseArgs: function(value, config) {
				argsValue = value ? value.replace(/^[^(]+./, &quot;&quot;).replace(/\).*$/, &quot;&quot;) : &quot;&quot;;

				var args = [];
				var matches = argsValue.match(this._RE.ALL);
				
				if (matches) {
					var all = [];

					matches.forEach(function(item) {
						var value;

						if (item.match(this._RE.STRINGS)) {
							value = item.substr(1, item.length - 2)
						}
						else if (item.match(this._RE.NUMBERS)) {
							value = parseFloat(item);
						}
						else if (item.match(this._RE.JSONS)) {
							value = JSON.parse(item);
						}
						else if (item.match(this._RE.VARIABLE)) {
							var variable = item.match(this._RE.VARIABLE)[0];

							if (variable == &quot;$event&quot;) {
								value = config.event;
							}
							else if (variable == &quot;$element&quot;) {
								value = config.el;
							}
							else {
								// todo - maybe eval with scope
								value = null;
							}
						}

						all.push({
							value: value,
							pos: argsValue.indexOf(item)
						});
					}, this);

					if (all.length) {
						all.sort(function(a, b) {
							return a.pos - b.pos
						}).forEach(function(item) {
							args.push(item.value);
						});
					}
				}

				return args;
			},

<span id='$template-method-_bindEvent'>			/**
</span>			 * Bind one single event to the element
			 * 
			 * @param  {HTMLElement} el
			 * @param  {String} eventName click, keydown...
			 * @param  {String} data data-x value
			 * @param  {Function} scope
			 * @member $template
			 * @private
			 */
			_bindEvent: function(el, eventName, data, scope) {
				if (data &amp;&amp; this._parseFnName(data) in scope) {
					el.addEventListener(eventName, $common.bindWithoutScope(function(event, templScope) {
						var value = this.getAttribute(&quot;data-&quot; + eventName);
						var fnName = templScope._parseFnName(value);
						var args = templScope._parseArgs(value, {
							el: this,
							event: event
						});

						scope[fnName].apply(scope, args);
					}, this));
				}
			},

<span id='$template-method-_init'>			/**
</span>			 * Init - get all templates from the page. Uses &#39;text/template&#39; script with template data
			 *
			 * @private
			 * @member $template
			 */
			_init: function() {
				onix.element(&quot;script[type=&#39;text/template&#39;]&quot;).forEach(function(item) {
					this.add(item.id, item.innerHTML);
				}, this);
			},
			
<span id='$template-method-add'>			/**
</span>			 * Add new item to the cachce
			 *
			 * @param {String} key 
			 * @param {String} data
			 * @member $template
			 */
			add: function(key, data) {
				this._cache[key] = data;
			},

<span id='$template-method-compile'>			/**
</span>			 * Compile one template - replaces all ocurances of {} by model
			 *
			 * @param  {String} key Template key/name
			 * @param  {Object} data Model
			 * @return {String}
			 * @member $template
			 */
			compile: function(key, data) {
				var tmpl = this.get(key);

				if (data) {
					Object.keys(data).forEach(function(key) {
						tmpl = tmpl.replace(new RegExp(conf.left + &quot;[ ]*&quot; + key + &quot;[ ]*&quot; + conf.right, &quot;g&quot;), data[key]);
					});
				}

				return tmpl;
			},

<span id='$template-method-get'>			/**
</span>			 * Get template from the cache
			 *
			 * @param  {String} key Template key/name
			 * @return {String}
			 * @member $template
			 */
			get: function(key) {
				return this._cache[key] || &quot;&quot;;
			},

<span id='$template-method-bindTemplate'>			/**
</span>			 * Bind all elements in the root element. Selectors all data-[click|change|bind|keydown] and functions are binds against scope object.
			 * Supports: click, change, keydown, bind
			 *
			 * @param  {HTMLElement} root
			 * @param  {Object|Function} scope
			 * @member $template
			 */
			bindTemplate: function(root, scope) {
				var allElements = onix.element(&quot;*[data-click], *[data-change], *[data-bind], *[data-keydown]&quot;, root);

				if (allElements.len()) {
					var newEls = {};

					allElements.forEach(function(item) {
						this._bindEvent(item, &quot;click&quot;, item.getAttribute(&quot;data-click&quot;), scope);
						this._bindEvent(item, &quot;change&quot;, item.getAttribute(&quot;data-change&quot;), scope);
						this._bindEvent(item, &quot;keydown&quot;, item.getAttribute(&quot;data-keydown&quot;), scope);

						var dataBind = item.getAttribute(&quot;data-bind&quot;);

						if (dataBind) {
							newEls[dataBind] = item;
						}
					}, this);

					if (&quot;addEls&quot; in scope &amp;&amp; typeof scope.addEls === &quot;function&quot;) {
						scope.addEls(newEls);
					}
				}
			},

<span id='$template-method-load'>			/**
</span>			 * Load template from the path, returns promise after load
			 *
			 * @param  {String} key
			 * @param  {String} path
			 * @return {$q}
			 * @member $template
			 */
			load: function(key, path) {
				var promise = $q.defer();

				$http.createRequest({
					url: path
				}).then(function(data) {
					this.add(key, data.data);

					promise.resolve();
				}.bind(this), function(data) {
					promise.reject();
				});

				return promise;
			}
		};

		// template init
		$template._init();

		return $template;
	}];
});
</pre>
</body>
</html>
