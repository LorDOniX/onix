<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">onix.provider(&quot;$template&quot;, function() {
<span id='$templateProvider-property-_conf'>	/**
</span>	 * Configuration for template delimeters.
	 *
	 * @type {Object}
	 * @member $templateProvider
	 * @private
	 */
	var _conf = {
		left: &quot;{{&quot;,
		right: &quot;}}&quot;,
		elPrefix: &quot;data-&quot;,
		elDataBind: &quot;data-bind&quot;
	};

<span id='$templateProvider-method-setConfig'>	/**
</span>	 * Set template config; you can use &quot;left&quot; {{ and &quot;right&quot; }} template delimeters, elPrefix = &quot;data-&quot; and elDataBind = &quot;data-bind&quot;
	 * 
	 * @param {Object} confParam Object with new config
	 * @member $templateProvider
	 */
	this.setConfig = function(confParam) {
		Object.keys(confParam).forEach(function(confParamKey) {
			_conf[confParamKey] = confParam[confParamKey];
		});
	};
	
	this.$get = [&quot;$common&quot;, &quot;$promise&quot;, &quot;$http&quot;, &quot;$filter&quot;, function(
				$common, $promise, $http, $filter) {

<span id='$template'>		/**
</span>		 * Handle templates, binds events - syntax similar to moustache and angular template system.
		 * $myQuery is used for cache record.
		 *
		 * @class $template
		 */
		var $template = function() {
<span id='$template-property-_cache'>			/**
</span>			 * Template cache.
			 *
			 * @type {Object}
			 * @member $template
			 * @private
			 */
			this._cache = {};

<span id='$template-property-_RE'>			/**
</span>			 * Regular expressions for handle template variables.
			 *
			 * @type {Object}
			 * @member $template
			 * @private
			 */
			this._RE = {
				VARIABLE: /[$_a-zA-Z][$_a-zA-Z0-9]+/g,
				NUMBERS: /[-]?[0-9]+[.]?([0-9e]+)?/g,
				STRINGS: /[&quot;&#39;][^&quot;&#39;]+[&quot;&#39;]/g,
				JSONS: /[{][^}]+[}]/g,
				ALL: /[-]?[0-9]+[.]?([0-9e]+)?|[&quot;&#39;][^&quot;&#39;]+[&quot;&#39;]|[{][^}]+[}]|[$_a-zA-Z][$_a-zA-Z0-9]+/g
			};

<span id='$template-property-_CONST'>			/**
</span>			 * Constants.
			 * 
			 * @type {Object}
			 * @member $template
			 * @private
			 */
			this._CONST = {
				FILTER_DELIMETER: &quot;|&quot;,
				FILTER_PARAM_DELIMETER: &quot;:&quot;,
				TEMPLATE_SCRIPT_SELECTOR: &quot;script[type=&#39;text/template&#39;]&quot;
			};

			// template init
			this._init();
		};

<span id='$template-method-_parseFnName'>		/**
</span>		 * Parse a function name from the string.
		 *
		 * @param  {String} value
		 * @return {String}
		 * @member $template
		 * @private
		 */
		$template.prototype._parseFnName = function(value) {
			value = value || &quot;&quot;;

			return value.match(/[a-zA-Z0-9_]+/)[0];
		};

<span id='$template-method-_parseArgs'>		/**
</span>		 * Parse arguments from the string -&gt; makes array from them.
		 *
		 * @param  {String} value
		 * @param  {Object} config
		 * @param  {Object} config.$event Event object
		 * @param  {Object} config.$element Reference to element
		 * @return {Array}
		 * @member $template
		 * @private
		 */
		$template.prototype._parseArgs = function(value, config) {
			argsValue = value ? value.replace(/^[^(]+./, &quot;&quot;).replace(/\).*$/, &quot;&quot;) : &quot;&quot;;

			var args = [];
			var matches = argsValue.match(this._RE.ALL);
			
			if (matches) {
				var all = [];

				matches.forEach(function(item) {
					var value;

					if (item.match(this._RE.STRINGS)) {
						value = item.substr(1, item.length - 2)
					}
					else if (item.match(this._RE.NUMBERS)) {
						value = parseFloat(item);
					}
					else if (item.match(this._RE.JSONS)) {
						value = JSON.parse(item);
					}
					else if (item.match(this._RE.VARIABLE)) {
						var variable = item.match(this._RE.VARIABLE)[0];

						if (variable == &quot;$event&quot;) {
							value = config.event;
						}
						else if (variable == &quot;$element&quot;) {
							value = config.el;
						}
						else {
							// todo - maybe eval with scope
							value = null;
						}
					}

					all.push({
						value: value,
						pos: argsValue.indexOf(item)
					});
				}, this);

				if (all.length) {
					all.sort(function(a, b) {
						return a.pos - b.pos
					}).forEach(function(item) {
						args.push(item.value);
					});
				}
			}

			return args;
		};

<span id='$template-method-_bindEvent'>		/**
</span>		 * Bind one single event to the element.
		 * 
		 * @param  {HTMLElement} el
		 * @param  {Object} attr { name, value }
		 * @param  {Function} scope
		 * @member $template
		 * @private
		 */
		$template.prototype._bindEvent = function(el, attr, scope) {
			if (!el || !attr || !scope) return;

			var eventName = attr.name.replace(_conf.elPrefix, &quot;&quot;);
			var fnName = this._parseFnName(attr.value);

			if (eventName &amp;&amp; fnName in scope) {
				el.addEventListener(eventName, $common.bindWithoutScope(function(event, templScope) {
					var args = templScope._parseArgs(attr.value, {
						el: this,
						event: event
					});

					scope[fnName].apply(scope, args);
				}, this));
			}
		};

<span id='$template-method-_getAttributes'>		/**
</span>		 * Get element prefixed attributes.
		 * 
		 * @param  {HTMLElement} el
		 * @return {Array}
		 * @member $template
		 * @private
		 */
		$template.prototype._getAttributes = function(el) {
			var output = [];

			if (el &amp;&amp; &quot;attributes&quot; in el) {
				Object.keys(el.attributes).forEach(function(attr) {
					var item = el.attributes[attr];

					if (item.name.indexOf(_conf.elPrefix) != -1) {
						output.push({
							name: item.name,
							value: item.value
						});
					}
				}, this);
			}

			return output;
		};

<span id='$template-method-_init'>		/**
</span>		 * Init - get all templates from the page. Uses &#39;text/template&#39; script with template data.
		 * Each script has to have id and specifi type=&quot;text/template&quot;.
		 *
		 * @private
		 * @member $template
		 */
		$template.prototype._init = function() {
			onix.element(this._CONST.TEMPLATE_SCRIPT_SELECTOR).forEach(function(item) {
				this.add(item.id || &quot;&quot;, item.innerHTML);
			}, this);
		};
		
<span id='$template-method-add'>		/**
</span>		 * Add new item to the cache.
		 *
		 * @param {String} key 
		 * @param {String} data
		 * @member $template
		 */
		$template.prototype.add = function(key, data) {
			this._cache[key] = data;
		};

<span id='$template-method-compile'>		/**
</span>		 * Compile one template - replaces all ocurances of {{ xxx }} by model.
		 *
		 * @param  {String} key Template key/name
		 * @param  {Object} data Model
		 * @return {String}
		 * @member $template
		 */
		$template.prototype.compile = function(key, data) {
			var tmpl = this.get(key);

			if (data) {
				var all = tmpl.match(new RegExp(_conf.left + &quot;(.*?)&quot; + _conf.right, &quot;g&quot;)) || [];

				all.forEach(function(item) {
					var itemSave = item;

					item = item.replace(new RegExp(&quot;^&quot; + _conf.left), &quot;&quot;).replace(new RegExp(_conf.right + &quot;$&quot;), &quot;&quot;);

					if (item.indexOf(this._CONST.FILTER_DELIMETER) != -1) {
						var filterValue;

						// filters
						item.split(this._CONST.FILTER_DELIMETER).forEach(function(filterItem, ind) {
							filterItem = filterItem.trim();

							if (!ind) {
								// value
								if (filterItem in data) {
									filterValue = data[filterItem];
								}
							}
							else {
								// preprocessing by filter
								var args = [filterValue];
								var filterParts = filterItem.split(this._CONST.FILTER_PARAM_DELIMETER);
								var filterName = &quot;&quot;;

								if (filterParts.length == 1) {
									filterName = filterParts[0].trim();
								}
								else {
									filterParts.forEach(function(filterPartItem, filterPartInd) {
										filterPartItem = filterPartItem.trim();

										if (!filterPartInd) {
											filterName = filterPartItem;
										}
										else {
											args.push(filterPartItem);
										}
									});
								}

								var filter = $filter(filterName);
								filterValue = filter.apply(filter, args);
							}
						}, this);

						tmpl = tmpl.replace(itemSave, filterValue || &quot;&quot;);
					}
					else {
						// standard
						var replaceValue = &quot;&quot;;

						item = item.trim();

						if (item in data) {
							replaceValue = data[item];
						}

						tmpl = tmpl.replace(itemSave, replaceValue);
					}
				}, this);
			}

			return tmpl;
		};

<span id='$template-method-get'>		/**
</span>		 * Get template from the cache.
		 *
		 * @param  {String} key Template key/name
		 * @return {String}
		 * @member $template
		 */
		$template.prototype.get = function(key) {
			return this._cache[key] || &quot;&quot;;
		};

<span id='$template-method-bindTemplate'>		/**
</span>		 * Bind all elements in the root element. Selectors all data-* and functions are binds against scope object.
		 * For data-bind, scope has to have &quot;addEls&quot; function.
		 * Supports: click, change, keydown, bind.
		 *
		 * @param  {HTMLElement} root Root element
		 * @param  {Object} scope Scope which against will be binding used
		 * @param  {Function} [addElsCb] Callback function with object with all data-bind objects
		 * @member $template
		 */
		$template.prototype.bindTemplate = function(root, scope, addElsCb) {
			var allElements = onix.element(&quot;*&quot;, root);

			if (allElements.len()) {
				var newEls = {};

				allElements.forEach(function(item) {
					var attrs = this._getAttributes(item);

					attrs.forEach(function(attr) {
						if (attr.name == _conf.elDataBind) {
							newEls[attr.value] = item;
						}
						else {
							this._bindEvent(item, attr, scope);
						}
					}, this);
				}, this);

				if (addElsCb &amp;&amp; typeof addElsCb === &quot;function&quot;) {
					addElsCb(newEls);
				}
			}
		};

<span id='$template-method-load'>		/**
</span>		 * Load template from the path, returns promise after load.
		 *
		 * @param  {String} key
		 * @param  {String} path
		 * @return {$promise}
		 * @member $template
		 */
		$template.prototype.load = function(key, path) {
			return new $promise(function(resolve, reject) {
				$http.createRequest({
					url: path
				}).then(function(data) {
					this.add(key, data.data);

					resolve();
				}.bind(this), function(data) {
					reject(data);
				});
			}.bind(this));
		};

		return new $template();
	}];
});
</pre>
</body>
</html>
