<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * OnixJS framework
 * 2.7.3/8. 7. 2016
 * source: https://gitlab.com/LorDOniX/onix
 * documentation: https://gitlab.com/LorDOniX/onix/tree/master/docs
 * @license MIT
 * - Free for use in both personal and commercial projects
 */
(function() {
	Event = Event || window.Event;
	Event.prototype.stopPropagation = Event.prototype.stopPropagation || function() {
		this.cancelBubble = true;
	};
	Event.prototype.preventDefault = Event.prototype.preventDefault || function () {
		this.returnValue = false;
	};
})();
if (!(&quot;btoa&quot; in window)) {
	window.btoa = function(val) {
		return val;
	}
}
if (!String.prototype.trim) {
	String.prototype.trim = function () {
		return this.replace(/^\s+|\s+$/g, &#39;&#39;);
	};
}
if(!Array.isArray) {
<span id='global-method-isArray'>	/**
</span>	 * Array.isArray dle ES5 - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray
	 */
	Array.isArray = function (vArg) {
		return Object.prototype.toString.call(vArg) === &quot;[object Array]&quot;;
	};
}
<span id='global-property-'>/**
</span> * Shim for &quot;fixing&quot; IE&#39;s lack of support (IE &lt; 9) for applying slice
 * on host objects like NamedNodeMap, NodeList, and HTMLCollection
 * (technically, since host objects have been implementation-dependent,
 * at least before ES6, IE hasn&#39;t needed to work this way).
 * Also works on strings, fixes IE &lt; 9 to allow an explicit undefined
 * for the 2nd argument (as in Firefox), and prevents errors when
 * called on other DOM objects.
 */
(function () {
  &#39;use strict&#39;;
  var _slice = Array.prototype.slice;
  try {
    // Can&#39;t be used with DOM elements in IE &lt; 9
    _slice.call(document.documentElement);
  } catch (e) { // Fails in IE &lt; 9
    // This will work for genuine arrays, array-like objects, 
    // NamedNodeMap (attributes, entities, notations),
    // NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes),
    // and will not fail on other DOM objects (as do DOM elements in IE &lt; 9)
    Array.prototype.slice = function(begin, end) {
      // IE &lt; 9 gets unhappy with an undefined end argument
      end = (typeof end !== &#39;undefined&#39;) ? end : this.length;
      // For native Array objects, we use the native slice function
      if (Object.prototype.toString.call(this) === &#39;[object Array]&#39;){
        return _slice.call(this, begin, end); 
      }
      // For array like object we handle it ourselves.
      var i, cloned = [],
        size, len = this.length;
      // Handle negative value for &quot;begin&quot;
      var start = begin || 0;
      start = (start &gt;= 0) ? start : Math.max(0, len + start);
      // Handle negative value for &quot;end&quot;
      var upTo = (typeof end == &#39;number&#39;) ? Math.min(end, len) : len;
      if (end &lt; 0) {
        upTo = len + end;
      }
      // Actual expected size of the slice
      size = upTo - start;
      if (size &gt; 0) {
        cloned = new Array(size);
        if (this.charAt) {
          for (i = 0; i &lt; size; i++) {
            cloned[i] = this.charAt(start + i);
          }
        } else {
          for (i = 0; i &lt; size; i++) {
            cloned[i] = this[start + i];
          }
        }
      }
      return cloned;
    };
  }
}());
if (!Array.prototype.forEach) { 
	Array.prototype.forEach = function(cb, _this) {
	    var len = this.length;
	    for (var i=0;i&lt;len;i++) { 
			if (i in this) { cb.call(_this, this[i], i, this); }
		}
	}
}
if (!Array.prototype.every) { 
	Array.prototype.every = function(cb, _this) {
	    var len = this.length;
	    for (var i=0;i&lt;len;i++) {
			if (i in this &amp;&amp; !cb.call(_this, this[i], i, this)) { return false; }
	    }
	    return true;
	}
}
if (!Array.prototype.indexOf) { 
	Array.prototype.indexOf = function(item, from) {
	    var len = this.length;
	    var i = from || 0;
	    if (i &lt; 0) { i += len; }
	    for (;i&lt;len;i++) {
			if (i in this &amp;&amp; this[i] === item) { return i; }
	    }
	    return -1;
	}
}
if (!(&quot;console&quot; in window)) {
	var emptyFn = function() {};
	window.console = {};
	[&quot;log&quot;, &quot;warn&quot;, &quot;error&quot;, &quot;clear&quot;, &quot;info&quot;].forEach(function(name) {
		window.console[name] = emptyFn;
	});
}
if (!Function.prototype.bind) {
<span id='global-method-bind'>	/**
</span>	 * ES5 Function.prototype.bind
	 * Vrací funkci zbindovanou do zadaného kontextu.
	 * Zbylé volitelné parametry jsou předány volání vnitřní funkce.
	 * @param {object} thisObj Nový kontext
	 * @returns {function}
	 */
	Function.prototype.bind = function(thisObj) {
		var fn = this;
		var args = Array.prototype.slice.call(arguments, 1);
		return function() {
			return fn.apply(thisObj, args.concat(Array.prototype.slice.call(arguments)));
		}
	}
};
if (!(&quot;addEventListener&quot; in document)) {
	var w = Window.prototype;
	var h = HTMLDocument.prototype;
	var e = Element.prototype;
	document[&quot;addEventListener&quot;] = w[&quot;addEventListener&quot;] = h[&quot;addEventListener&quot;] = e[&quot;addEventListener&quot;] = function(eventName, listener) {
		if (!this.__eventListeners) {
			this.__eventListeners = {};
		}
		if (eventName == &quot;DOMContentLoaded&quot;) {
			this.attachEvent(&quot;onreadystatechange&quot;, function() {
				if (document.readyState === &quot;complete&quot;) {
					listener();
				}
			});
		}
		else {
			if (!this.__eventListeners[eventName]) {
				this.__eventListeners[eventName] = [];
			}
			var fn = function() {
				return listener.apply(this, arguments);
			}.bind(this);
			this.__eventListeners[eventName].push({
				fn: fn,
				listener: listener
			});
			this.attachEvent(&quot;on&quot; + eventName, fn);
		}
	};
	document[&quot;removeEventListener&quot;] = w[&quot;removeEventListener&quot;] = h[&quot;removeEventListener&quot;] = e[&quot;removeEventListener&quot;] = function(eventName, listener) {
		var all = this.__eventListeners || {};
		var items = all[eventName] || [];
		var fn = null;
		var pos = -1;
		for (var i = 0; i &lt; items.length; i++) {
			var item = items[i];
			if (item.listener == listener) {
				fn = item.fn;
				pos = i;
				break;
			}
		}
		if (fn) {
			items.splice(pos, 1);
			if (!items.length) {
				delete all[eventName];
			}
			return this.detachEvent(&quot;on&quot; + eventName, fn);
		}
		else return null;
	};
}
if (!(&quot;classList&quot; in document.documentElement) &amp;&amp; window.Element) {
	(function () {
		var prototype = Array.prototype,
		indexOf = prototype.indexOf,
		slice = prototype.slice,
		push = prototype.push,
		splice = prototype.splice,
		join = prototype.join;
		function DOMTokenList(elm) {
			this._element = elm;
			if (elm.className == this._classCache) { return; }
			this._classCache = elm.className;
			if (!this._classCache) { return; }
			var classes = this._classCache.replace(/^\s+|\s+$/g,&#39;&#39;).split(/\s+/);
			for (var i = 0; i &lt; classes.length; i++) {
				push.call(this, classes[i]);
			}
		}
		window.DOMTokenList = DOMTokenList;
		function setToClassName(el, classes) {
			el.className = classes.join(&quot; &quot;);
		}
		DOMTokenList.prototype = {
			add: function(token) {
				if (this.contains(token)) { return; }
				push.call(this, token);
				setToClassName(this._element, slice.call(this, 0));
			},
			contains: function(token) {
				return (indexOf.call(this, token) != -1);
			},
			item: function(index) {
				return this[index] || null;
			},
			remove: function(token) {
				var i = indexOf.call(this, token);
				if (i == -1) { return; }
				splice.call(this, i, 1);
				setToClassName(this._element, slice.call(this, 0));
			},
			toString: function() {
				return join.call(this, &quot; &quot;);
			},
			toggle: function(token) {
				if (indexOf.call(this, token) == -1) {
					this.add(token);
					return true;
				} else {
					this.remove(token);
					return false;
				}
			}
		};
		function defineElementGetter (obj, prop, getter) {
			if (Object.defineProperty) {
				Object.defineProperty(obj, prop, {
					get: getter
				});
			} else {
				obj.__defineGetter__(prop, getter);
			}
		}
		defineElementGetter(Element.prototype, &quot;classList&quot;, function() {
			return new DOMTokenList(this);
		});
	})();
}
if (!Date.now) {
<span id='global-method-now'>	/**
</span>	 * aktuální timestamp dle ES5 - http://dailyjs.com/2010/01/07/ecmascript5-date/
	 */
	Date.now = function() { return +(new Date); }
}
/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */
// vim: ts=4 sts=4 sw=4 expandtab
// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
;
// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
(function (root, factory) {
    &#39;use strict&#39;;
    /* global define, exports, module */
    if (typeof define === &#39;function&#39; &amp;&amp; define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof exports === &#39;object&#39;) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.returnExports = factory();
  }
}(this, function () {
var call = Function.call;
var prototypeOfObject = Object.prototype;
var owns = call.bind(prototypeOfObject.hasOwnProperty);
var isEnumerable = call.bind(prototypeOfObject.propertyIsEnumerable);
var toStr = call.bind(prototypeOfObject.toString);
// If JS engine supports accessors creating shortcuts.
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors = owns(prototypeOfObject, &#39;__defineGetter__&#39;);
if (supportsAccessors) {
    /* eslint-disable no-underscore-dangle */
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
    /* eslint-enable no-underscore-dangle */
}
<span id='global-property-'> /**
</span> * Object.keys by ES5 - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
 */
if (!Object.keys) {
    Object.keys = (function () {
        &#39;use strict&#39;;
        var hasOwnProperty = Object.prototype.hasOwnProperty,
            hasDontEnumBug = !({toString: null}).propertyIsEnumerable(&#39;toString&#39;),
            dontEnums = [
                &#39;toString&#39;,
                &#39;toLocaleString&#39;,
                &#39;valueOf&#39;,
                &#39;hasOwnProperty&#39;,
                &#39;isPrototypeOf&#39;,
                &#39;propertyIsEnumerable&#39;,
                &#39;constructor&#39;
            ],
            dontEnumsLength = dontEnums.length;
        return function (obj) {
            if (typeof obj !== &#39;object&#39; &amp;&amp; (typeof obj !== &#39;function&#39; || obj === null)) {
                throw new TypeError(&#39;Object.keys called on non-object&#39;);
            }
            var result = [], prop, i;
            for (prop in obj) {
                if (hasOwnProperty.call(obj, prop)) {
                    result.push(prop);
                }
            }
            if (hasDontEnumBug) {
                for (i = 0; i &lt; dontEnumsLength; i++) {
                    if (hasOwnProperty.call(obj, dontEnums[i])) {
                        result.push(dontEnums[i]);
                    }
                }
            }
            return result;
        };
    }());
}
// ES5 15.2.3.2
// http://es5.github.com/#x15.2.3.2
if (!Object.getPrototypeOf) {
    // https://github.com/es-shims/es5-shim/issues#issue/2
    // http://ejohn.org/blog/objectgetprototypeof/
    // recommended by fschaefer on github
    //
    // sure, and webreflection says ^_^
    // ... this will nerever possibly return null
    // ... Opera Mini breaks here with infinite loops
    Object.getPrototypeOf = function getPrototypeOf(object) {
        /* eslint-disable no-proto */
        var proto = object.__proto__;
        /* eslint-enable no-proto */
        if (proto || proto === null) {
            return proto;
        } else if (toStr(object.constructor) === &#39;[object Function]&#39;) {
            return object.constructor.prototype;
        } else if (object instanceof Object) {
          return prototypeOfObject;
        } else {
          // Correctly return null for Objects created with `Object.create(null)`
          // (shammed or native) or `{ __proto__: null}`.  Also returns null for
          // cross-realm objects on browsers that lack `__proto__` support (like
          // IE &lt;11), but that&#39;s the best we can do.
          return null;
        }
    };
}
// ES5 15.2.3.3
// http://es5.github.com/#x15.2.3.3
var doesGetOwnPropertyDescriptorWork = function doesGetOwnPropertyDescriptorWork(object) {
    try {
        object.sentinel = 0;
        return Object.getOwnPropertyDescriptor(object, &#39;sentinel&#39;).value === 0;
    } catch (exception) {
        return false;
    }
};
// check whether getOwnPropertyDescriptor works if it&#39;s given. Otherwise, shim partially.
if (Object.defineProperty) {
    var getOwnPropertyDescriptorWorksOnObject = doesGetOwnPropertyDescriptorWork({});
    var getOwnPropertyDescriptorWorksOnDom = typeof document === &#39;undefined&#39; ||
    doesGetOwnPropertyDescriptorWork(document.createElement(&#39;div&#39;));
    if (!getOwnPropertyDescriptorWorksOnDom || !getOwnPropertyDescriptorWorksOnObject) {
        var getOwnPropertyDescriptorFallback = Object.getOwnPropertyDescriptor;
    }
}
if (!Object.getOwnPropertyDescriptor || getOwnPropertyDescriptorFallback) {
    var ERR_NON_OBJECT = &#39;Object.getOwnPropertyDescriptor called on a non-object: &#39;;
    /* eslint-disable no-proto */
    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
        if ((typeof object !== &#39;object&#39; &amp;&amp; typeof object !== &#39;function&#39;) || object === null) {
            throw new TypeError(ERR_NON_OBJECT + object);
        }
        // make a valiant attempt to use the real getOwnPropertyDescriptor
        // for I8&#39;s DOM elements.
        if (getOwnPropertyDescriptorFallback) {
            try {
                return getOwnPropertyDescriptorFallback.call(Object, object, property);
            } catch (exception) {
                // try the shim if the real one doesn&#39;t work
            }
        }
        var descriptor;
        // If object does not owns property return undefined immediately.
        if (!owns(object, property)) {
            return descriptor;
        }
        // If object has a property then it&#39;s for sure `configurable`, and
        // probably `enumerable`. Detect enumerability though.
        descriptor = {
            enumerable: isEnumerable(object, property),
            configurable: true
        };
        // If JS engine supports accessor properties then property may be a
        // getter or setter.
        if (supportsAccessors) {
            // Unfortunately `__lookupGetter__` will return a getter even
            // if object has own non getter property along with a same named
            // inherited getter. To avoid misbehavior we temporary remove
            // `__proto__` so that `__lookupGetter__` will return getter only
            // if it&#39;s owned by an object.
            var prototype = object.__proto__;
            var notPrototypeOfObject = object !== prototypeOfObject;
            // avoid recursion problem, breaking in Opera Mini when
            // Object.getOwnPropertyDescriptor(Object.prototype, &#39;toString&#39;)
            // or any other Object.prototype accessor
            if (notPrototypeOfObject) {
                object.__proto__ = prototypeOfObject;
            }
            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);
            if (notPrototypeOfObject) {
                // Once we have getter and setter we can put values back.
                object.__proto__ = prototype;
            }
            if (getter || setter) {
                if (getter) {
                    descriptor.get = getter;
                }
                if (setter) {
                    descriptor.set = setter;
                }
                // If it was accessor property we&#39;re done and return here
                // in order to avoid adding `value` to the descriptor.
                return descriptor;
            }
        }
        // If we got this far we know that object has an own property that is
        // not an accessor so we set it as a value and return descriptor.
        descriptor.value = object[property];
        descriptor.writable = true;
        return descriptor;
    };
    /* eslint-enable no-proto */
}
// ES5 15.2.3.4
// http://es5.github.com/#x15.2.3.4
if (!Object.getOwnPropertyNames) {
    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
        return Object.keys(object);
    };
}
// ES5 15.2.3.5
// http://es5.github.com/#x15.2.3.5
if (!Object.create) {
    // Contributed by Brandon Benvie, October, 2012
    var createEmpty;
    var supportsProto = !({ __proto__: null } instanceof Object);
                        // the following produces false positives
                        // in Opera Mini =&gt; not a reliable check
                        // Object.prototype.__proto__ === null
    // Check for document.domain and active x support
    // No need to use active x approach when document.domain is not set
    // see https://github.com/es-shims/es5-shim/issues/150
    // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
    /* global ActiveXObject */
    var shouldUseActiveX = function shouldUseActiveX() {
        // return early if document.domain not set
        if (!document.domain) {
            return false;
        }
        try {
            return !!new ActiveXObject(&#39;htmlfile&#39;);
        } catch (exception) {
            return false;
        }
    };
    // This supports IE8 when document.domain is used
    // see https://github.com/es-shims/es5-shim/issues/150
    // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
    var getEmptyViaActiveX = function getEmptyViaActiveX() {
        var empty;
        var xDoc;
        xDoc = new ActiveXObject(&#39;htmlfile&#39;);
        xDoc.write(&#39;&lt;script&gt;&lt;\/script&gt;&#39;);
        xDoc.close();
        empty = xDoc.parentWindow.Object.prototype;
        xDoc = null;
        return empty;
    };
    // The original implementation using an iframe
    // before the activex approach was added
    // see https://github.com/es-shims/es5-shim/issues/150
    var getEmptyViaIFrame = function getEmptyViaIFrame() {
        var iframe = document.createElement(&#39;iframe&#39;);
        var parent = document.body || document.documentElement;
        var empty;
        iframe.style.display = &#39;none&#39;;
        parent.appendChild(iframe);
        /* eslint-disable no-script-url */
        iframe.src = &#39;javascript:&#39;;
        /* eslint-enable no-script-url */
        empty = iframe.contentWindow.Object.prototype;
        parent.removeChild(iframe);
        iframe = null;
        return empty;
    };
    /* global document */
    if (supportsProto || typeof document === &#39;undefined&#39;) {
        createEmpty = function () {
            return { __proto__: null };
        };
    } else {
        // In old IE __proto__ can&#39;t be used to manually set `null`, nor does
        // any other method exist to make an object that inherits from nothing,
        // aside from Object.prototype itself. Instead, create a new global
        // object and *steal* its Object.prototype and strip it bare. This is
        // used as the prototype to create nullary objects.
        createEmpty = function () {
            // Determine which approach to use
            // see https://github.com/es-shims/es5-shim/issues/150
            var empty = shouldUseActiveX() ? getEmptyViaActiveX() : getEmptyViaIFrame();
            delete empty.constructor;
            delete empty.hasOwnProperty;
            delete empty.propertyIsEnumerable;
            delete empty.isPrototypeOf;
            delete empty.toLocaleString;
            delete empty.toString;
            delete empty.valueOf;
            var Empty = function Empty() {};
            Empty.prototype = empty;
            // short-circuit future calls
            createEmpty = function () {
                return new Empty();
            };
            return new Empty();
        };
    }
    Object.create = function create(prototype, properties) {
        var object;
        var Type = function Type() {}; // An empty constructor.
        if (prototype === null) {
            object = createEmpty();
        } else {
            if (typeof prototype !== &#39;object&#39; &amp;&amp; typeof prototype !== &#39;function&#39;) {
                // In the native implementation `parent` can be `null`
                // OR *any* `instanceof Object`  (Object|Function|Array|RegExp|etc)
                // Use `typeof` tho, b/c in old IE, DOM elements are not `instanceof Object`
                // like they are in modern browsers. Using `Object.create` on DOM elements
                // is...err...probably inappropriate, but the native version allows for it.
                throw new TypeError(&#39;Object prototype may only be an Object or null&#39;); // same msg as Chrome
            }
            Type.prototype = prototype;
            object = new Type();
            // IE has no built-in implementation of `Object.getPrototypeOf`
            // neither `__proto__`, but this manually setting `__proto__` will
            // guarantee that `Object.getPrototypeOf` will work as expected with
            // objects created using `Object.create`
            /* eslint-disable no-proto */
            object.__proto__ = prototype;
            /* eslint-enable no-proto */
        }
        if (properties !== void 0) {
            Object.defineProperties(object, properties);
        }
        return object;
    };
}
// ES5 15.2.3.6
// http://es5.github.com/#x15.2.3.6
// Patch for WebKit and IE8 standard mode
// Designed by hax &lt;hax.github.com&gt;
// related issue: https://github.com/es-shims/es5-shim/issues#issue/5
// IE8 Reference:
//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
// WebKit Bugs:
//     https://bugs.webkit.org/show_bug.cgi?id=36423
var doesDefinePropertyWork = function doesDefinePropertyWork(object) {
    try {
        Object.defineProperty(object, &#39;sentinel&#39;, {});
        return &#39;sentinel&#39; in object;
    } catch (exception) {
        return false;
    }
};
// check whether defineProperty works if it&#39;s given. Otherwise,
// shim partially.
if (Object.defineProperty) {
    var definePropertyWorksOnObject = doesDefinePropertyWork({});
    var definePropertyWorksOnDom = typeof document === &#39;undefined&#39; ||
        doesDefinePropertyWork(document.createElement(&#39;div&#39;));
    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
        var definePropertyFallback = Object.defineProperty,
            definePropertiesFallback = Object.defineProperties;
    }
}
if (!Object.defineProperty || definePropertyFallback) {
    var ERR_NON_OBJECT_DESCRIPTOR = &#39;Property description must be an object: &#39;;
    var ERR_NON_OBJECT_TARGET = &#39;Object.defineProperty called on non-object: &#39;;
    var ERR_ACCESSORS_NOT_SUPPORTED = &#39;getters &amp; setters can not be defined on this javascript engine&#39;;
    Object.defineProperty = function defineProperty(object, property, descriptor) {
        if ((typeof object !== &#39;object&#39; &amp;&amp; typeof object !== &#39;function&#39;) || object === null) {
            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
        }
        if ((typeof descriptor !== &#39;object&#39; &amp;&amp; typeof descriptor !== &#39;function&#39;) || descriptor === null) {
            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
        }
        // make a valiant attempt to use the real defineProperty
        // for I8&#39;s DOM elements.
        if (definePropertyFallback) {
            try {
                return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {
                // try the shim if the real one doesn&#39;t work
            }
        }
        // If it&#39;s a data property.
        if (&#39;value&#39; in descriptor) {
            // fail silently if &#39;writable&#39;, &#39;enumerable&#39;, or &#39;configurable&#39;
            // are requested but not supported
            /*
            // alternate approach:
            if ( // can&#39;t implement these features; allow false but not true
                (&#39;writable&#39; in descriptor &amp;&amp; !descriptor.writable) ||
                (&#39;enumerable&#39; in descriptor &amp;&amp; !descriptor.enumerable) ||
                (&#39;configurable&#39; in descriptor &amp;&amp; !descriptor.configurable)
            ))
                throw new RangeError(
                    &#39;This implementation of Object.defineProperty does not support configurable, enumerable, or writable.&#39;
                );
            */
            if (supportsAccessors &amp;&amp; (lookupGetter(object, property) || lookupSetter(object, property))) {
                // As accessors are supported only on engines implementing
                // `__proto__` we can safely override `__proto__` while defining
                // a property to make sure that we don&#39;t hit an inherited
                // accessor.
                /* eslint-disable no-proto */
                var prototype = object.__proto__;
                object.__proto__ = prototypeOfObject;
                // Deleting a property anyway since getter / setter may be
                // defined on object itself.
                delete object[property];
                object[property] = descriptor.value;
                // Setting original `__proto__` back now.
                object.__proto__ = prototype;
                /* eslint-enable no-proto */
            } else {
                object[property] = descriptor.value;
            }
        } else {
            if (!supportsAccessors &amp;&amp; ((&#39;get&#39; in descriptor) || (&#39;set&#39; in descriptor))) {
                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
            }
            // If we got that far then getters and setters can be defined !!
            if (&#39;get&#39; in descriptor) {
                defineGetter(object, property, descriptor.get);
            }
            if (&#39;set&#39; in descriptor) {
                defineSetter(object, property, descriptor.set);
            }
        }
        return object;
    };
}
// ES5 15.2.3.7
// http://es5.github.com/#x15.2.3.7
if (!Object.defineProperties || definePropertiesFallback) {
    Object.defineProperties = function defineProperties(object, properties) {
        // make a valiant attempt to use the real defineProperties
        if (definePropertiesFallback) {
            try {
                return definePropertiesFallback.call(Object, object, properties);
            } catch (exception) {
                // try the shim if the real one doesn&#39;t work
            }
        }
        Object.keys(properties).forEach(function (property) {
            if (property !== &#39;__proto__&#39;) {
                Object.defineProperty(object, property, properties[property]);
            }
        });
        return object;
    };
}
// ES5 15.2.3.8
// http://es5.github.com/#x15.2.3.8
if (!Object.seal) {
    Object.seal = function seal(object) {
        if (Object(object) !== object) {
            throw new TypeError(&#39;Object.seal can only be called on Objects.&#39;);
        }
        // this is misleading and breaks feature-detection, but
        // allows &quot;securable&quot; code to &quot;gracefully&quot; degrade to working
        // but insecure code.
        return object;
    };
}
// ES5 15.2.3.9
// http://es5.github.com/#x15.2.3.9
if (!Object.freeze) {
    Object.freeze = function freeze(object) {
        if (Object(object) !== object) {
            throw new TypeError(&#39;Object.freeze can only be called on Objects.&#39;);
        }
        // this is misleading and breaks feature-detection, but
        // allows &quot;securable&quot; code to &quot;gracefully&quot; degrade to working
        // but insecure code.
        return object;
    };
}
// detect a Rhino bug and patch it
try {
    Object.freeze(function () {});
} catch (exception) {
    Object.freeze = (function (freezeObject) {
        return function freeze(object) {
            if (typeof object === &#39;function&#39;) {
                return object;
            } else {
                return freezeObject(object);
            }
        };
    }(Object.freeze));
}
// ES5 15.2.3.10
// http://es5.github.com/#x15.2.3.10
if (!Object.preventExtensions) {
    Object.preventExtensions = function preventExtensions(object) {
        if (Object(object) !== object) {
            throw new TypeError(&#39;Object.preventExtensions can only be called on Objects.&#39;);
        }
        // this is misleading and breaks feature-detection, but
        // allows &quot;securable&quot; code to &quot;gracefully&quot; degrade to working
        // but insecure code.
        return object;
    };
}
// ES5 15.2.3.11
// http://es5.github.com/#x15.2.3.11
if (!Object.isSealed) {
    Object.isSealed = function isSealed(object) {
        if (Object(object) !== object) {
            throw new TypeError(&#39;Object.isSealed can only be called on Objects.&#39;);
        }
        return false;
    };
}
// ES5 15.2.3.12
// http://es5.github.com/#x15.2.3.12
if (!Object.isFrozen) {
    Object.isFrozen = function isFrozen(object) {
        if (Object(object) !== object) {
            throw new TypeError(&#39;Object.isFrozen can only be called on Objects.&#39;);
        }
        return false;
    };
}
// ES5 15.2.3.13
// http://es5.github.com/#x15.2.3.13
if (!Object.isExtensible) {
    Object.isExtensible = function isExtensible(object) {
        // 1. If Type(O) is not Object throw a TypeError exception.
        if (Object(object) !== object) {
            throw new TypeError(&#39;Object.isExtensible can only be called on Objects.&#39;);
        }
        // 2. Return the Boolean value of the [[Extensible]] internal property of O.
        var name = &#39;&#39;;
        while (owns(object, name)) {
            name += &#39;?&#39;;
        }
        object[name] = true;
        var returnValue = owns(object, name);
        delete object[name];
        return returnValue;
    };
}
}));
(function() {
	var debug = false;
	var root = this;
	var EXIF = function(obj) {
		if (obj instanceof EXIF) return obj;
		if (!(this instanceof EXIF)) return new EXIF(obj);
		this.EXIFwrapped = obj;
	};
	if (typeof exports !== &#39;undefined&#39;) {
		if (typeof module !== &#39;undefined&#39; &amp;&amp; module.exports) {
			exports = module.exports = EXIF;
		}
		exports.EXIF = EXIF;
	} else {
		root.EXIF = EXIF;
	}
	var ExifTags = EXIF.Tags = {
		// version tags
		0x9000 : &quot;ExifVersion&quot;,             // EXIF version
		0xA000 : &quot;FlashpixVersion&quot;,         // Flashpix format version
		// colorspace tags
		0xA001 : &quot;ColorSpace&quot;,              // Color space information tag
		// image configuration
		0xA002 : &quot;PixelXDimension&quot;,         // Valid width of meaningful image
		0xA003 : &quot;PixelYDimension&quot;,         // Valid height of meaningful image
		0x9101 : &quot;ComponentsConfiguration&quot;, // Information about channels
		0x9102 : &quot;CompressedBitsPerPixel&quot;,  // Compressed bits per pixel
		// user information
		0x927C : &quot;MakerNote&quot;,               // Any desired information written by the manufacturer
		0x9286 : &quot;UserComment&quot;,             // Comments by user
		// related file
		0xA004 : &quot;RelatedSoundFile&quot;,        // Name of related sound file
		// date and time
		0x9003 : &quot;DateTimeOriginal&quot;,        // Date and time when the original image was generated
		0x9004 : &quot;DateTimeDigitized&quot;,       // Date and time when the image was stored digitally
		0x9290 : &quot;SubsecTime&quot;,              // Fractions of seconds for DateTime
		0x9291 : &quot;SubsecTimeOriginal&quot;,      // Fractions of seconds for DateTimeOriginal
		0x9292 : &quot;SubsecTimeDigitized&quot;,     // Fractions of seconds for DateTimeDigitized
		// picture-taking conditions
		0x829A : &quot;ExposureTime&quot;,            // Exposure time (in seconds)
		0x829D : &quot;FNumber&quot;,                 // F number
		0x8822 : &quot;ExposureProgram&quot;,         // Exposure program
		0x8824 : &quot;SpectralSensitivity&quot;,     // Spectral sensitivity
		0x8827 : &quot;ISOSpeedRatings&quot;,         // ISO speed rating
		0x8828 : &quot;OECF&quot;,                    // Optoelectric conversion factor
		0x9201 : &quot;ShutterSpeedValue&quot;,       // Shutter speed
		0x9202 : &quot;ApertureValue&quot;,           // Lens aperture
		0x9203 : &quot;BrightnessValue&quot;,         // Value of brightness
		0x9204 : &quot;ExposureBias&quot;,            // Exposure bias
		0x9205 : &quot;MaxApertureValue&quot;,        // Smallest F number of lens
		0x9206 : &quot;SubjectDistance&quot;,         // Distance to subject in meters
		0x9207 : &quot;MeteringMode&quot;,            // Metering mode
		0x9208 : &quot;LightSource&quot;,             // Kind of light source
		0x9209 : &quot;Flash&quot;,                   // Flash status
		0x9214 : &quot;SubjectArea&quot;,             // Location and area of main subject
		0x920A : &quot;FocalLength&quot;,             // Focal length of the lens in mm
		0xA20B : &quot;FlashEnergy&quot;,             // Strobe energy in BCPS
		0xA20C : &quot;SpatialFrequencyResponse&quot;,    //
		0xA20E : &quot;FocalPlaneXResolution&quot;,   // Number of pixels in width direction per FocalPlaneResolutionUnit
		0xA20F : &quot;FocalPlaneYResolution&quot;,   // Number of pixels in height direction per FocalPlaneResolutionUnit
		0xA210 : &quot;FocalPlaneResolutionUnit&quot;,    // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution
		0xA214 : &quot;SubjectLocation&quot;,         // Location of subject in image
		0xA215 : &quot;ExposureIndex&quot;,           // Exposure index selected on camera
		0xA217 : &quot;SensingMethod&quot;,           // Image sensor type
		0xA300 : &quot;FileSource&quot;,              // Image source (3 == DSC)
		0xA301 : &quot;SceneType&quot;,               // Scene type (1 == directly photographed)
		0xA302 : &quot;CFAPattern&quot;,              // Color filter array geometric pattern
		0xA401 : &quot;CustomRendered&quot;,          // Special processing
		0xA402 : &quot;ExposureMode&quot;,            // Exposure mode
		0xA403 : &quot;WhiteBalance&quot;,            // 1 = auto white balance, 2 = manual
		0xA404 : &quot;DigitalZoomRation&quot;,       // Digital zoom ratio
		0xA405 : &quot;FocalLengthIn35mmFilm&quot;,   // Equivalent foacl length assuming 35mm film camera (in mm)
		0xA406 : &quot;SceneCaptureType&quot;,        // Type of scene
		0xA407 : &quot;GainControl&quot;,             // Degree of overall image gain adjustment
		0xA408 : &quot;Contrast&quot;,                // Direction of contrast processing applied by camera
		0xA409 : &quot;Saturation&quot;,              // Direction of saturation processing applied by camera
		0xA40A : &quot;Sharpness&quot;,               // Direction of sharpness processing applied by camera
		0xA40B : &quot;DeviceSettingDescription&quot;,    //
		0xA40C : &quot;SubjectDistanceRange&quot;,    // Distance to subject
		// other tags
		0xA005 : &quot;InteroperabilityIFDPointer&quot;,
		0xA420 : &quot;ImageUniqueID&quot;            // Identifier assigned uniquely to each image
	};
	var TiffTags = EXIF.TiffTags = {
		0x0100 : &quot;ImageWidth&quot;,
		0x0101 : &quot;ImageHeight&quot;,
		0x8769 : &quot;ExifIFDPointer&quot;,
		0x8825 : &quot;GPSInfoIFDPointer&quot;,
		0xA005 : &quot;InteroperabilityIFDPointer&quot;,
		0x0102 : &quot;BitsPerSample&quot;,
		0x0103 : &quot;Compression&quot;,
		0x0106 : &quot;PhotometricInterpretation&quot;,
		0x0112 : &quot;Orientation&quot;,
		0x0115 : &quot;SamplesPerPixel&quot;,
		0x011C : &quot;PlanarConfiguration&quot;,
		0x0212 : &quot;YCbCrSubSampling&quot;,
		0x0213 : &quot;YCbCrPositioning&quot;,
		0x011A : &quot;XResolution&quot;,
		0x011B : &quot;YResolution&quot;,
		0x0128 : &quot;ResolutionUnit&quot;,
		0x0111 : &quot;StripOffsets&quot;,
		0x0116 : &quot;RowsPerStrip&quot;,
		0x0117 : &quot;StripByteCounts&quot;,
		0x0201 : &quot;JPEGInterchangeFormat&quot;,
		0x0202 : &quot;JPEGInterchangeFormatLength&quot;,
		0x012D : &quot;TransferFunction&quot;,
		0x013E : &quot;WhitePoint&quot;,
		0x013F : &quot;PrimaryChromaticities&quot;,
		0x0211 : &quot;YCbCrCoefficients&quot;,
		0x0214 : &quot;ReferenceBlackWhite&quot;,
		0x0132 : &quot;DateTime&quot;,
		0x010E : &quot;ImageDescription&quot;,
		0x010F : &quot;Make&quot;,
		0x0110 : &quot;Model&quot;,
		0x0131 : &quot;Software&quot;,
		0x013B : &quot;Artist&quot;,
		0x8298 : &quot;Copyright&quot;
	};
	var GPSTags = EXIF.GPSTags = {
		0x0000 : &quot;GPSVersionID&quot;,
		0x0001 : &quot;GPSLatitudeRef&quot;,
		0x0002 : &quot;GPSLatitude&quot;,
		0x0003 : &quot;GPSLongitudeRef&quot;,
		0x0004 : &quot;GPSLongitude&quot;,
		0x0005 : &quot;GPSAltitudeRef&quot;,
		0x0006 : &quot;GPSAltitude&quot;,
		0x0007 : &quot;GPSTimeStamp&quot;,
		0x0008 : &quot;GPSSatellites&quot;,
		0x0009 : &quot;GPSStatus&quot;,
		0x000A : &quot;GPSMeasureMode&quot;,
		0x000B : &quot;GPSDOP&quot;,
		0x000C : &quot;GPSSpeedRef&quot;,
		0x000D : &quot;GPSSpeed&quot;,
		0x000E : &quot;GPSTrackRef&quot;,
		0x000F : &quot;GPSTrack&quot;,
		0x0010 : &quot;GPSImgDirectionRef&quot;,
		0x0011 : &quot;GPSImgDirection&quot;,
		0x0012 : &quot;GPSMapDatum&quot;,
		0x0013 : &quot;GPSDestLatitudeRef&quot;,
		0x0014 : &quot;GPSDestLatitude&quot;,
		0x0015 : &quot;GPSDestLongitudeRef&quot;,
		0x0016 : &quot;GPSDestLongitude&quot;,
		0x0017 : &quot;GPSDestBearingRef&quot;,
		0x0018 : &quot;GPSDestBearing&quot;,
		0x0019 : &quot;GPSDestDistanceRef&quot;,
		0x001A : &quot;GPSDestDistance&quot;,
		0x001B : &quot;GPSProcessingMethod&quot;,
		0x001C : &quot;GPSAreaInformation&quot;,
		0x001D : &quot;GPSDateStamp&quot;,
		0x001E : &quot;GPSDifferential&quot;
	};
	var StringValues = EXIF.StringValues = {
		ExposureProgram : {
			0 : &quot;Not defined&quot;,
			1 : &quot;Manual&quot;,
			2 : &quot;Normal program&quot;,
			3 : &quot;Aperture priority&quot;,
			4 : &quot;Shutter priority&quot;,
			5 : &quot;Creative program&quot;,
			6 : &quot;Action program&quot;,
			7 : &quot;Portrait mode&quot;,
			8 : &quot;Landscape mode&quot;
		},
		MeteringMode : {
			0 : &quot;Unknown&quot;,
			1 : &quot;Average&quot;,
			2 : &quot;CenterWeightedAverage&quot;,
			3 : &quot;Spot&quot;,
			4 : &quot;MultiSpot&quot;,
			5 : &quot;Pattern&quot;,
			6 : &quot;Partial&quot;,
			255 : &quot;Other&quot;
		},
		LightSource : {
			0 : &quot;Unknown&quot;,
			1 : &quot;Daylight&quot;,
			2 : &quot;Fluorescent&quot;,
			3 : &quot;Tungsten (incandescent light)&quot;,
			4 : &quot;Flash&quot;,
			9 : &quot;Fine weather&quot;,
			10 : &quot;Cloudy weather&quot;,
			11 : &quot;Shade&quot;,
			12 : &quot;Daylight fluorescent (D 5700 - 7100K)&quot;,
			13 : &quot;Day white fluorescent (N 4600 - 5400K)&quot;,
			14 : &quot;Cool white fluorescent (W 3900 - 4500K)&quot;,
			15 : &quot;White fluorescent (WW 3200 - 3700K)&quot;,
			17 : &quot;Standard light A&quot;,
			18 : &quot;Standard light B&quot;,
			19 : &quot;Standard light C&quot;,
			20 : &quot;D55&quot;,
			21 : &quot;D65&quot;,
			22 : &quot;D75&quot;,
			23 : &quot;D50&quot;,
			24 : &quot;ISO studio tungsten&quot;,
			255 : &quot;Other&quot;
		},
		Flash : {
			0x0000 : &quot;Flash did not fire&quot;,
			0x0001 : &quot;Flash fired&quot;,
			0x0005 : &quot;Strobe return light not detected&quot;,
			0x0007 : &quot;Strobe return light detected&quot;,
			0x0009 : &quot;Flash fired, compulsory flash mode&quot;,
			0x000D : &quot;Flash fired, compulsory flash mode, return light not detected&quot;,
			0x000F : &quot;Flash fired, compulsory flash mode, return light detected&quot;,
			0x0010 : &quot;Flash did not fire, compulsory flash mode&quot;,
			0x0018 : &quot;Flash did not fire, auto mode&quot;,
			0x0019 : &quot;Flash fired, auto mode&quot;,
			0x001D : &quot;Flash fired, auto mode, return light not detected&quot;,
			0x001F : &quot;Flash fired, auto mode, return light detected&quot;,
			0x0020 : &quot;No flash function&quot;,
			0x0041 : &quot;Flash fired, red-eye reduction mode&quot;,
			0x0045 : &quot;Flash fired, red-eye reduction mode, return light not detected&quot;,
			0x0047 : &quot;Flash fired, red-eye reduction mode, return light detected&quot;,
			0x0049 : &quot;Flash fired, compulsory flash mode, red-eye reduction mode&quot;,
			0x004D : &quot;Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected&quot;,
			0x004F : &quot;Flash fired, compulsory flash mode, red-eye reduction mode, return light detected&quot;,
			0x0059 : &quot;Flash fired, auto mode, red-eye reduction mode&quot;,
			0x005D : &quot;Flash fired, auto mode, return light not detected, red-eye reduction mode&quot;,
			0x005F : &quot;Flash fired, auto mode, return light detected, red-eye reduction mode&quot;
		},
		SensingMethod : {
			1 : &quot;Not defined&quot;,
			2 : &quot;One-chip color area sensor&quot;,
			3 : &quot;Two-chip color area sensor&quot;,
			4 : &quot;Three-chip color area sensor&quot;,
			5 : &quot;Color sequential area sensor&quot;,
			7 : &quot;Trilinear sensor&quot;,
			8 : &quot;Color sequential linear sensor&quot;
		},
		SceneCaptureType : {
			0 : &quot;Standard&quot;,
			1 : &quot;Landscape&quot;,
			2 : &quot;Portrait&quot;,
			3 : &quot;Night scene&quot;
		},
		SceneType : {
			1 : &quot;Directly photographed&quot;
		},
		CustomRendered : {
			0 : &quot;Normal process&quot;,
			1 : &quot;Custom process&quot;
		},
		WhiteBalance : {
			0 : &quot;Auto white balance&quot;,
			1 : &quot;Manual white balance&quot;
		},
		GainControl : {
			0 : &quot;None&quot;,
			1 : &quot;Low gain up&quot;,
			2 : &quot;High gain up&quot;,
			3 : &quot;Low gain down&quot;,
			4 : &quot;High gain down&quot;
		},
		Contrast : {
			0 : &quot;Normal&quot;,
			1 : &quot;Soft&quot;,
			2 : &quot;Hard&quot;
		},
		Saturation : {
			0 : &quot;Normal&quot;,
			1 : &quot;Low saturation&quot;,
			2 : &quot;High saturation&quot;
		},
		Sharpness : {
			0 : &quot;Normal&quot;,
			1 : &quot;Soft&quot;,
			2 : &quot;Hard&quot;
		},
		SubjectDistanceRange : {
			0 : &quot;Unknown&quot;,
			1 : &quot;Macro&quot;,
			2 : &quot;Close view&quot;,
			3 : &quot;Distant view&quot;
		},
		FileSource : {
			3 : &quot;DSC&quot;
		},
		Components : {
			0 : &quot;&quot;,
			1 : &quot;Y&quot;,
			2 : &quot;Cb&quot;,
			3 : &quot;Cr&quot;,
			4 : &quot;R&quot;,
			5 : &quot;G&quot;,
			6 : &quot;B&quot;
		}
	};
	function addEvent(element, event, handler) {
		if (element.addEventListener) {
			element.addEventListener(event, handler, false);
		} else if (element.attachEvent) {
			element.attachEvent(&quot;on&quot; + event, handler);
		}
	}
	function imageHasData(img) {
		return !!(img.exifdata);
	}
	function base64ToArrayBuffer(base64, contentType) {
		contentType = contentType || base64.match(/^data\:([^\;]+)\;base64,/mi)[1] || &#39;&#39;; // e.g. &#39;data:image/jpeg;base64,...&#39; =&gt; &#39;image/jpeg&#39;
		base64 = base64.replace(/^data\:([^\;]+)\;base64,/gmi, &#39;&#39;);
		var binary = atob(base64);
		var len = binary.length;
		var buffer = new ArrayBuffer(len);
		var view = new Uint8Array(buffer);
		for (var i = 0; i &lt; len; i++) {
			view[i] = binary.charCodeAt(i);
		}
		return buffer;
	}
	function objectURLToBlob(url, callback) {
		var http = new XMLHttpRequest();
		http.open(&quot;GET&quot;, url, true);
		http.responseType = &quot;blob&quot;;
		http.onload = function(e) {
			if (this.status == 200 || this.status === 0) {
				callback(this.response);
			}
		};
		http.send();
	}
	function getImageData(img, callback) {
		function handleBinaryFile(binFile) {
			var data = findEXIFinJPEG(binFile);
			var iptcdata = findIPTCinJPEG(binFile);
			img.exifdata = data || {};
			img.iptcdata = iptcdata || {};
			if (callback) {
				callback.call(img);
			}
		}
		if (img.src) {
			if (/^data\:/i.test(img.src)) { // Data URI
				var arrayBuffer = base64ToArrayBuffer(img.src);
				handleBinaryFile(arrayBuffer);
			} else if (/^blob\:/i.test(img.src)) { // Object URL
				var fileReader = new FileReader();
				fileReader.onload = function(e) {
					handleBinaryFile(e.target.result);
				};
				objectURLToBlob(img.src, function (blob) {
					fileReader.readAsArrayBuffer(blob);
				});
			} else {
				var http = new XMLHttpRequest();
				http.onload = function() {
					if (this.status == 200 || this.status === 0) {
						handleBinaryFile(http.response);
					} else {
						throw &quot;Could not load image&quot;;
					}
					http = null;
				};
				http.open(&quot;GET&quot;, img.src, true);
				http.responseType = &quot;arraybuffer&quot;;
				http.send(null);
			}
		} else if (window.FileReader &amp;&amp; (img instanceof window.Blob || img instanceof window.File)) {
			var fileReader = new FileReader();
			fileReader.onload = function(e) {
				if (debug) console.log(&quot;Got file of length &quot; + e.target.result.byteLength);
				handleBinaryFile(e.target.result);
			};
			fileReader.readAsArrayBuffer(img);
		}
	}
	function findEXIFinJPEG(file) {
		var dataView = new DataView(file);
		if (debug) console.log(&quot;Got file of length &quot; + file.byteLength);
		if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {
			if (debug) console.log(&quot;Not a valid JPEG&quot;);
			return false; // not a valid jpeg
		}
		var offset = 2,
			length = file.byteLength,
			marker;
		while (offset &lt; length) {
			if (dataView.getUint8(offset) != 0xFF) {
				if (debug) console.log(&quot;Not a valid marker at offset &quot; + offset + &quot;, found: &quot; + dataView.getUint8(offset));
				return false; // not a valid marker, something is wrong
			}
			marker = dataView.getUint8(offset + 1);
			if (debug) console.log(marker);
			// we could implement handling for other markers here,
			// but we&#39;re only looking for 0xFFE1 for EXIF data
			if (marker == 225) {
				if (debug) console.log(&quot;Found 0xFFE1 marker&quot;);
				return readEXIFData(dataView, offset + 4, dataView.getUint16(offset + 2) - 2);
				// offset += 2 + file.getShortAt(offset+2, true);
			} else {
				offset += 2 + dataView.getUint16(offset+2);
			}
		}
	}
	function findIPTCinJPEG(file) {
		var dataView = new DataView(file);
		if (debug) console.log(&quot;Got file of length &quot; + file.byteLength);
		if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {
			if (debug) console.log(&quot;Not a valid JPEG&quot;);
			return false; // not a valid jpeg
		}
		var offset = 2,
			length = file.byteLength;
		var isFieldSegmentStart = function(dataView, offset){
			return (
				dataView.getUint8(offset) === 0x38 &amp;&amp;
				dataView.getUint8(offset+1) === 0x42 &amp;&amp;
				dataView.getUint8(offset+2) === 0x49 &amp;&amp;
				dataView.getUint8(offset+3) === 0x4D &amp;&amp;
				dataView.getUint8(offset+4) === 0x04 &amp;&amp;
				dataView.getUint8(offset+5) === 0x04
			);
		};
		while (offset &lt; length) {
			if ( isFieldSegmentStart(dataView, offset )){
				// Get the length of the name header (which is padded to an even number of bytes)
				var nameHeaderLength = dataView.getUint8(offset+7);
				if(nameHeaderLength % 2 !== 0) nameHeaderLength += 1;
				// Check for pre photoshop 6 format
				if(nameHeaderLength === 0) {
					// Always 4
					nameHeaderLength = 4;
				}
				var startOffset = offset + 8 + nameHeaderLength;
				var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);
				return readIPTCData(file, startOffset, sectionLength);
				break;
			}
			// Not the marker, continue searching
			offset++;
		}
	}
	var IptcFieldMap = {
		0x78 : &#39;caption&#39;,
		0x6E : &#39;credit&#39;,
		0x19 : &#39;keywords&#39;,
		0x37 : &#39;dateCreated&#39;,
		0x50 : &#39;byline&#39;,
		0x55 : &#39;bylineTitle&#39;,
		0x7A : &#39;captionWriter&#39;,
		0x69 : &#39;headline&#39;,
		0x74 : &#39;copyright&#39;,
		0x0F : &#39;category&#39;
	};
	function readIPTCData(file, startOffset, sectionLength){
		var dataView = new DataView(file);
		var data = {};
		var fieldValue, fieldName, dataSize, segmentType, segmentSize;
		var segmentStartPos = startOffset;
		while(segmentStartPos &lt; startOffset+sectionLength) {
			if(dataView.getUint8(segmentStartPos) === 0x1C &amp;&amp; dataView.getUint8(segmentStartPos+1) === 0x02){
				segmentType = dataView.getUint8(segmentStartPos+2);
				if(segmentType in IptcFieldMap) {
					dataSize = dataView.getInt16(segmentStartPos+3);
					segmentSize = dataSize + 5;
					fieldName = IptcFieldMap[segmentType];
					fieldValue = getStringFromDB(dataView, segmentStartPos+5, dataSize);
					// Check if we already stored a value with this name
					if(data.hasOwnProperty(fieldName)) {
						// Value already stored with this name, create multivalue field
						if(data[fieldName] instanceof Array) {
							data[fieldName].push(fieldValue);
						}
						else {
							data[fieldName] = [data[fieldName], fieldValue];
						}
					}
					else {
						data[fieldName] = fieldValue;
					}
				}
			}
			segmentStartPos++;
		}
		return data;
	}
	function readTags(file, tiffStart, dirStart, strings, bigEnd) {
		var entries = file.getUint16(dirStart, !bigEnd),
			tags = {},
			entryOffset, tag,
			i;
		for (i=0;i&lt;entries;i++) {
			entryOffset = dirStart + i*12 + 2;
			tag = strings[file.getUint16(entryOffset, !bigEnd)];
			if (!tag &amp;&amp; debug) console.log(&quot;Unknown tag: &quot; + file.getUint16(entryOffset, !bigEnd));
			tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);
		}
		return tags;
	}
	function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {
		var type = file.getUint16(entryOffset+2, !bigEnd),
			numValues = file.getUint32(entryOffset+4, !bigEnd),
			valueOffset = file.getUint32(entryOffset+8, !bigEnd) + tiffStart,
			offset,
			vals, val, n,
			numerator, denominator;
		switch (type) {
			case 1: // byte, 8-bit unsigned int
			case 7: // undefined, 8-bit byte, value depending on field
				if (numValues == 1) {
					return file.getUint8(entryOffset + 8, !bigEnd);
				} else {
					offset = numValues &gt; 4 ? valueOffset : (entryOffset + 8);
					vals = [];
					for (n=0;n&lt;numValues;n++) {
						vals[n] = file.getUint8(offset + n);
					}
					return vals;
				}
			case 2: // ascii, 8-bit byte
				offset = numValues &gt; 4 ? valueOffset : (entryOffset + 8);
				return getStringFromDB(file, offset, numValues-1);
			case 3: // short, 16 bit int
				if (numValues == 1) {
					return file.getUint16(entryOffset + 8, !bigEnd);
				} else {
					offset = numValues &gt; 2 ? valueOffset : (entryOffset + 8);
					vals = [];
					for (n=0;n&lt;numValues;n++) {
						vals[n] = file.getUint16(offset + 2*n, !bigEnd);
					}
					return vals;
				}
			case 4: // long, 32 bit int
				if (numValues == 1) {
					return file.getUint32(entryOffset + 8, !bigEnd);
				} else {
					vals = [];
					for (n=0;n&lt;numValues;n++) {
						vals[n] = file.getUint32(valueOffset + 4*n, !bigEnd);
					}
					return vals;
				}
			case 5:    // rational = two long values, first is numerator, second is denominator
				if (numValues == 1) {
					numerator = file.getUint32(valueOffset, !bigEnd);
					denominator = file.getUint32(valueOffset+4, !bigEnd);
					val = new Number(numerator / denominator);
					val.numerator = numerator;
					val.denominator = denominator;
					return val;
				} else {
					vals = [];
					for (n=0;n&lt;numValues;n++) {
						numerator = file.getUint32(valueOffset + 8*n, !bigEnd);
						denominator = file.getUint32(valueOffset+4 + 8*n, !bigEnd);
						vals[n] = new Number(numerator / denominator);
						vals[n].numerator = numerator;
						vals[n].denominator = denominator;
					}
					return vals;
				}
			case 9: // slong, 32 bit signed int
				if (numValues == 1) {
					return file.getInt32(entryOffset + 8, !bigEnd);
				} else {
					vals = [];
					for (n=0;n&lt;numValues;n++) {
						vals[n] = file.getInt32(valueOffset + 4*n, !bigEnd);
					}
					return vals;
				}
			case 10: // signed rational, two slongs, first is numerator, second is denominator
				if (numValues == 1) {
					return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset+4, !bigEnd);
				} else {
					vals = [];
					for (n=0;n&lt;numValues;n++) {
						vals[n] = file.getInt32(valueOffset + 8*n, !bigEnd) / file.getInt32(valueOffset+4 + 8*n, !bigEnd);
					}
					return vals;
				}
		}
	}
	function getStringFromDB(buffer, start, length) {
		var outstr = &quot;&quot;;
		for (n = start; n &lt; start+length; n++) {
			outstr += String.fromCharCode(buffer.getUint8(n));
		}
		return outstr;
	}
	function readEXIFData(file, start) {
		if (getStringFromDB(file, start, 4) != &quot;Exif&quot;) {
			if (debug) console.log(&quot;Not valid EXIF data! &quot; + getStringFromDB(file, start, 4));
			return false;
		}
		var bigEnd,
			tags, tag,
			exifData, gpsData,
			tiffOffset = start + 6;
		// test for TIFF validity and endianness
		if (file.getUint16(tiffOffset) == 0x4949) {
			bigEnd = false;
		} else if (file.getUint16(tiffOffset) == 0x4D4D) {
			bigEnd = true;
		} else {
			if (debug) console.log(&quot;Not valid TIFF data! (no 0x4949 or 0x4D4D)&quot;);
			return false;
		}
		if (file.getUint16(tiffOffset+2, !bigEnd) != 0x002A) {
			if (debug) console.log(&quot;Not valid TIFF data! (no 0x002A)&quot;);
			return false;
		}
		var firstIFDOffset = file.getUint32(tiffOffset+4, !bigEnd);
		if (firstIFDOffset &lt; 0x00000008) {
			if (debug) console.log(&quot;Not valid TIFF data! (First offset less than 8)&quot;, file.getUint32(tiffOffset+4, !bigEnd));
			return false;
		}
		tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, TiffTags, bigEnd);
		if (tags.ExifIFDPointer) {
			exifData = readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, ExifTags, bigEnd);
			for (tag in exifData) {
				switch (tag) {
					case &quot;LightSource&quot; :
					case &quot;Flash&quot; :
					case &quot;MeteringMode&quot; :
					case &quot;ExposureProgram&quot; :
					case &quot;SensingMethod&quot; :
					case &quot;SceneCaptureType&quot; :
					case &quot;SceneType&quot; :
					case &quot;CustomRendered&quot; :
					case &quot;WhiteBalance&quot; :
					case &quot;GainControl&quot; :
					case &quot;Contrast&quot; :
					case &quot;Saturation&quot; :
					case &quot;Sharpness&quot; :
					case &quot;SubjectDistanceRange&quot; :
					case &quot;FileSource&quot; :
						exifData[tag] = StringValues[tag][exifData[tag]];
						break;
					case &quot;ExifVersion&quot; :
					case &quot;FlashpixVersion&quot; :
						exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);
						break;
					case &quot;ComponentsConfiguration&quot; :
						exifData[tag] =
							StringValues.Components[exifData[tag][0]] +
							StringValues.Components[exifData[tag][1]] +
							StringValues.Components[exifData[tag][2]] +
							StringValues.Components[exifData[tag][3]];
						break;
				}
				tags[tag] = exifData[tag];
			}
		}
		if (tags.GPSInfoIFDPointer) {
			gpsData = readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, GPSTags, bigEnd);
			for (tag in gpsData) {
				switch (tag) {
					case &quot;GPSVersionID&quot; :
						gpsData[tag] = gpsData[tag][0] +
							&quot;.&quot; + gpsData[tag][1] +
							&quot;.&quot; + gpsData[tag][2] +
							&quot;.&quot; + gpsData[tag][3];
						break;
				}
				tags[tag] = gpsData[tag];
			}
		}
		return tags;
	}
	EXIF.getData = function(img, callback) {
		if ((img instanceof Image || img instanceof HTMLImageElement) &amp;&amp; !img.complete) return false;
		if (!imageHasData(img)) {
			getImageData(img, callback);
		} else {
			if (callback) {
				callback.call(img);
			}
		}
		return true;
	}
	EXIF.getTag = function(img, tag) {
		if (!imageHasData(img)) return;
		return img.exifdata[tag];
	}
	EXIF.getAllTags = function(img) {
		if (!imageHasData(img)) return {};
		var a,
			data = img.exifdata,
			tags = {};
		for (a in data) {
			if (data.hasOwnProperty(a)) {
				tags[a] = data[a];
			}
		}
		return tags;
	}
	EXIF.pretty = function(img) {
		if (!imageHasData(img)) return &quot;&quot;;
		var a,
			data = img.exifdata,
			strPretty = &quot;&quot;;
		for (a in data) {
			if (data.hasOwnProperty(a)) {
				if (typeof data[a] == &quot;object&quot;) {
					if (data[a] instanceof Number) {
						strPretty += a + &quot; : &quot; + data[a] + &quot; [&quot; + data[a].numerator + &quot;/&quot; + data[a].denominator + &quot;]\r\n&quot;;
					} else {
						strPretty += a + &quot; : [&quot; + data[a].length + &quot; values]\r\n&quot;;
					}
				} else {
					strPretty += a + &quot; : &quot; + data[a] + &quot;\r\n&quot;;
				}
			}
		}
		return strPretty;
	}
	EXIF.readFromBinaryFile = function(file) {
		return findEXIFinJPEG(file);
	}
	if (typeof define === &#39;function&#39; &amp;&amp; define.amd) {
		define(&#39;exif-js&#39;, [], function() {
			return EXIF;
		});
	}
}.call(this));
var _typeof2 = typeof Symbol === &quot;function&quot; &amp;&amp; typeof Symbol.iterator === &quot;symbol&quot; ? function (obj) { return typeof obj; } : function (obj) { return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol ? &quot;symbol&quot; : typeof obj; };
function _classCallCheck2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(&quot;Cannot call a class as a function&quot;); } }
onix = function () {
	/* ************************************* $module **************************** */
<span id='$module'>	/**
</span>  * Module object - handles one module object with services, factories etc.
  * This object cannot be used in dependency injection!
  * 
  * @class $module
  */
	var $module = function () {
<span id='$module-method-S-module'>		/**
</span>   * New module.
   * 
   * @param  {String} name Module name
   * @param  {Array} dependencies Other modules dependencies
   */
		function $module(name, dependencies) {
			_classCallCheck2(this, $module);
<span id='$module-property-_objects'>			/**
</span>    * All objects.
    *
    * @type {Object}
    * @member $module
    * @private
    */
			this._objects = {};
<span id='$module-property-_runs'>			/**
</span>    * All run objects.
    *
    * @type {Object}
    * @member $module
    * @private
    */
			this._runs = [];
<span id='$module-property-_configs'>			/**
</span>    * All config objects.
    *
    * @type {Object}
    * @member $module
    * @private
    */
			this._configs = [];
<span id='$module-property-_name'>			/**
</span>    * Module name.
    * 
    * @type {String}
    * @member $module
    * @private
    */
			this._name = name || &quot;&quot;;
<span id='$module-property-_dependencies'>			/**
</span>    * Module dependencies.
    * 
    * @type {Array}
    * @member $module
    * @private
    */
			this._dependencies = dependencies || [];
		}
<span id='$module-static-property-parseParam'>		/**
</span>   * Parse parameters. From param parse function and dependencies.
   *
   * @property {Function}
   * @param  {Array|Function} param 
   * @return {Object} Parse object
   * @member $module
   * @static
   * @method parseParam
   */
		$module.parseParam = function parseParam(param) {
			var fn = void 0;
			var inject = [];
			if (Array.isArray(param)) {
				param.every(function (item) {
					if (typeof item === &quot;function&quot;) {
						fn = item;
						return false;
					} else if (typeof item === &quot;string&quot;) {
						inject.push(item);
					}
					return true;
				});
			} else {
				fn = param;
			}
			return {
				fn: fn,
				inject: inject
			};
		};
<span id='$module-static-method-getFilterName'>		/**
</span>   * Get filter name.
   * 
   * @param  {String} name
   * @return {String}
   * @member $module
   * @static
   * @method getFilterName
   */
		$module.getFilterName = function getFilterName(name) {
			name = name || &quot;&quot;;
			return $module.CONST.FILTER_NAME + name[0].toUpperCase() + name.substr(1);
		};
<span id='$module-method-getDependencies'>		/**
</span>   * Get dependencies.
   * 
   * @return {Array}
   * @member $module
   * @method getDependencies
   */
		$module.prototype.getDependencies = function getDependencies() {
			return this._dependencies;
		};
<span id='$module-method-getName'>		/**
</span>   * Get module name.
   * 
   * @return {String}
   * @member $module
   * @method getName
   */
		$module.prototype.getName = function getName() {
			return this._name;
		};
<span id='$module-method-getConfigs'>		/**
</span>   * Get module configs.
   * 
   * @return {Array}
   * @member $module
   * @method getConfigs
   */
		$module.prototype.getConfigs = function getConfigs() {
			return this._configs;
		};
<span id='$module-method-getRuns'>		/**
</span>   * Get module runs.
   * 
   * @return {Array}
   * @member $module
   * @method getRuns
   */
		$module.prototype.getRuns = function getRuns() {
			return this._runs;
		};
<span id='$module-method-getObjects'>		/**
</span>   * Get module objects.
   * 
   * @return {Array}
   * @member $module
   * @method getObjects
   */
		$module.prototype.getObjects = function getObjects() {
			return this._objects;
		};
<span id='$module-method-provider'>		/**
</span>   * Add provider to the application.
   *
   * @chainable
   * @param  {String} name 
   * @param  {Function} param
   * @member $module
   * @method provider
   */
		$module.prototype.provider = function provider(name, param) {
			if (!name || !param) {
				return this;
			}
			var pp = $module.parseParam(param);
			this._objects[name + $module.CONST.PROVIDER_NAME] = {
				name: name + $module.CONST.PROVIDER_NAME,
				inject: pp.inject,
				fn: pp.fn,
				cache: null,
				type: $module.CONST.TYPE.PROVIDER
			};
			this._objects[name] = {
				name: name,
				inject: null,
				fn: null,
				cache: null,
				provider: name + $module.CONST.PROVIDER_NAME,
				type: $module.CONST.TYPE.FACTORY
			};
			return this;
		};
<span id='$module-method-service'>		/**
</span>   * Add service to the application.
   *
   * @chainable
   * @param  {String} name 
   * @param  {Function|Array} param
   * @member $module
   * @method service
   */
		$module.prototype.service = function service(name, param) {
			if (!name || !param) {
				return this;
			}
			var pp = $module.parseParam(param);
			this._objects[name] = {
				name: name,
				inject: pp.inject,
				fn: pp.fn,
				cache: null,
				type: $module.CONST.TYPE.SERVICE
			};
			return this;
		};
<span id='$module-method-factory'>		/**
</span>   * Add factory to the application.
   *
   * @chainable
   * @param  {String} name 
   * @param  {Function|Array} param
   * @member $module
   * @method factory
   */
		$module.prototype.factory = function factory(name, param) {
			if (!name || !param) {
				return this;
			}
			var pp = $module.parseParam(param);
			this._objects[name] = {
				name: name,
				inject: pp.inject,
				fn: pp.fn,
				cache: null,
				type: $module.CONST.TYPE.FACTORY
			};
			return this;
		};
<span id='$module-method-constant'>		/**
</span>   * Add new constant.
   *
   * @chainable
   * @param  {String} name
   * @param  {Object} param
   * @member $module
   * @method constant
   */
		$module.prototype.constant = function constant(name, obj) {
			if (!name || !obj) {
				return this;
			}
			this._objects[name] = {
				name: name,
				cache: obj,
				type: $module.CONST.TYPE.CONSTANT
			};
			return this;
		};
<span id='$module-method-value'>		/**
</span>   * Add a new value.
   *
   * @chainable
   * @param  {String} name
   * @param  {Object} param
   * @member $module
   * @method value
   */
		$module.prototype.value = function value(name, obj) {
			if (!name || !obj) {
				return this;
			}
			this._objects[name] = {
				name: name,
				cache: obj,
				type: $module.CONST.TYPE.VALUE
			};
			return this;
		};
<span id='$module-method-filter'>		/**
</span>   * Add filter to the application.
   *
   * @chainable
   * @param  {String} name 
   * @param  {Function|Array} param
   * @member $module
   * @method filter
   */
		$module.prototype.filter = function filter(name, param) {
			if (!name || !param) {
				return this;
			}
			var pp = $module.parseParam(param);
			this._objects[$module.getFilterName(name)] = {
				name: name,
				inject: pp.inject,
				fn: pp.fn,
				cache: null,
				type: $module.CONST.TYPE.FILTER
			};
			return this;
		};
<span id='$module-method-config'>		/**
</span>   * Add a new config.
   *
   * @chainable
   * @param  {Array|Function} param With DI
   * @member $module
   * @method config
   */
		$module.prototype.config = function config(param) {
			if (!param) {
				return this;
			}
			var pp = $module.parseParam(param);
			this._configs.push({
				fn: pp.fn,
				inject: pp.inject,
				type: $module.CONST.TYPE.CONFIG
			});
			return this;
		};
<span id='$module-method-run'>		/**
</span>   * Add a new run.
   *
   * @chainable
   * @param  {Array|Function} param With DI
   * @member $module
   * @method run
   */
		$module.prototype.run = function run(param) {
			if (!param) {
				return this;
			}
			var pp = $module.parseParam(param);
			this._runs.push({
				fn: pp.fn,
				inject: pp.inject,
				type: $module.CONST.TYPE.RUN
			});
			return this;
		};
<span id='$module-method-controller'>		/**
</span>   * Add a new controller - only for back comptability with angular modules.
   * This feature is not implemented!
   *
   * @chainable
   * @member $module
   * @method controller
   */
		$module.prototype.controller = function controller() {
			return this;
		};
<span id='$module-method-directive'>		/**
</span>   * Add a new directive - only for back comptability with angular modules.
   * This feature is not implemented!
   *
   * @chainable
   * @member $module
   * @method directive
   */
		$module.prototype.directive = function directive() {
			return this;
		};
		return $module;
	}();
	;
<span id='$module-static-property-CONST'>	/**
</span>  * Module constants.
  *
  * @property {Object}
  * @type {Object}
  * @member $module
  * @private
  * @static
  */
	$module.CONST = {
		PROVIDER_NAME: &quot;Provider&quot;,
		FILTER_NAME: &quot;$filter&quot;,
		TYPE: {
			PROVIDER: 1,
			SERVICE: 2,
			FACTORY: 3,
			CONSTANT: 4,
			VALUE: 5,
			FILTER: 6,
			CONFIG: 7,
			RUN: 8
		}
	};
	/* ************************************* $modules **************************** */
<span id='$modules'>	/**
</span>  * Modules object - handles all modules in the application; runs object.
  * This object cannot be used in dependency injection!
  *
  * @class $modules
  */
	var $modules = function () {
		function $modules() {
			var _this7 = this;
			_classCallCheck2(this, $modules);
<span id='$modules-property-_modules'>			/**
</span>    * All modules array.
    *
    * @private
    * @member $modules
    * @type {Array}
    */
			this._modules = [];
<span id='$modules-property-_modulesObj'>			/**
</span>    * All modules object - quick access.
    *
    * @private
    * @member $modules
    * @type {Object}
    */
			this._modulesObj = {};
<span id='$modules-property-_CONST'>			/**
</span>    * Modules constants.
    *
    * @private
    * @member $modules
    * @type {Object}
    */
			this._CONST = {
				MODULE_SEPARATOR: &quot;::&quot;
			};
			// bind DOM ready
			document.addEventListener(&quot;DOMContentLoaded&quot;, function () {
				_this7._domLoad();
			});
		}
<span id='$modules-method-_domLoad'>		/**
</span>   * Event - Dom LOAD.
   *
   * @member $modules
   * @private
   * @method _domLoad
   */
		$modules.prototype._domLoad = function _domLoad() {
			var _this8 = this;
			var configs = [];
			var runs = [];
			this._modules.forEach(function (module) {
				var error = false;
				var dependencies = module.getDependencies();
				dependencies.every(function (dep) {
					if (!(dep in _this8._modulesObj)) {
						console.error(&quot;Module &#39;&quot; + _this8._name + &quot;&#39; dependency &#39;&quot; + dep + &quot;&#39; not found!&quot;);
						error = true;
						return false;
					} else {
						return true;
					}
				});
				if (!error) {
					configs = configs.concat(module.getConfigs());
					runs = runs.concat(module.getRuns());
				}
			});
			// run all configs
			configs.forEach(function (config) {
				_this8.run(config, true);
			});
			// run all runs
			runs.forEach(function (run) {
				_this8.run(run);
			});
		};
<span id='$modules-method-_getObject'>		/**
</span>   * Get object by his name.
   *
   * @param {String} name Object name
   * @return {Object} Object data
   * @member $modules
   * @private
   * @method _getObject
   */
		$modules.prototype._getObject = function _getObject(name) {
			var output = null;
			var searchModuleName = &quot;&quot;;
			var searchObjectName = &quot;&quot;;
			if (name.indexOf(this._CONST.MODULE_SEPARATOR) != -1) {
				var parts = name.split(this._CONST.MODULE_SEPARATOR);
				if (parts.length == 2) {
					searchModuleName = parts[0];
					searchObjectName = parts[1];
				} else {
					console.error(&quot;Get object &quot; + name + &quot; error! Wrong module separator use.&quot;);
					return null;
				}
			} else {
				searchObjectName = name;
			}
			this._modules.every(function (module) {
				var moduleObjects = module.getObjects();
				if (searchModuleName) {
					if (module.getName() != searchModuleName) return true;
					if (searchObjectName in moduleObjects) {
						output = moduleObjects[searchObjectName];
						return false;
					} else {
						console.error(&quot;Get object &quot; + searchObjectName + &quot; error! Cannot find object in the module &quot; + searchModuleName + &quot;.&quot;);
						return false;
					}
				} else {
					if (searchObjectName in moduleObjects) {
						output = moduleObjects[searchObjectName];
						return false;
					} else return true;
				}
			});
			return output;
		};
<span id='$modules-method-noop'>		/**
</span>   * Function which does nothing.
   *
   * @member $modules
   * @method noop
   */
		$modules.prototype.noop = function noop() {};
<span id='$modules-method-run'>		/**
</span>   * Run object configuration; returns his cache (data).
   *
   * @param  {Object}  obj Object configuration
   * @param  {Boolean} [isConfig] Is config phase?
   * @param  {Array} [parent] Parent objects
   * @return {Object}
   * @member $modules
   * @method run
   */
		$modules.prototype.run = function run(obj, isConfig, parent) {
			var _this9 = this;
			parent = parent || [];
			if (parent.indexOf(obj.name) != -1) {
				console.error(&quot;Circular dependency error! Object name: &quot; + obj.name + &quot;, parents: &quot; + parent.join(&quot;|&quot;));
				return null;
			}
			var inject = [];
			if (obj.provider) {
				var providerObj = this._getObject(obj.provider);
				if (!providerObj.cache) {
					var providerFn = providerObj.fn || this.noop;
					providerObj.cache = new providerFn();
				}
				var getFn = providerObj.cache[&quot;$get&quot;] || this.noop;
				var pp = $module.parseParam(getFn);
				obj.fn = pp.fn;
				obj.inject = pp.inject;
				delete obj.provider;
			}
			if (obj.inject &amp;&amp; obj.inject.length) {
				obj.inject.forEach(function (objName) {
					if (typeof objName === &quot;string&quot;) {
						var injObj = _this9._getObject(objName);
						if (!injObj) {
							console.error(&quot;Object name: &quot; + objName + &quot; not found!&quot;);
							inject.push(null);
						} else {
							inject.push(_this9.run(injObj, isConfig, obj.name ? parent.concat(obj.name) : parent));
						}
					} else if ((typeof objName === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(objName)) === &quot;object&quot;) {
						inject.push(objName);
					}
				});
			}
			// config phase
			if (isConfig) {
				switch (obj.type) {
					case $module.CONST.TYPE.PROVIDER:
						if (!obj.cache) {
							var _fn = obj.fn || this.noop;
							obj.cache = new _fn();
						}
						return obj.cache;
						break;
					case $module.CONST.TYPE.CONSTANT:
						return obj.cache;
						break;
					case $module.CONST.TYPE.CONFIG:
						var fn = obj.fn || this.noop;
						return fn.apply(fn, inject);
						break;
					default:
						return null;
				}
			}
			// run phase
			else {
					switch (obj.type) {
						case $module.CONST.TYPE.FACTORY:
						case $module.CONST.TYPE.FILTER:
							if (!obj.cache) {
								var _fn3 = obj.fn || this.noop;
								obj.cache = _fn3.apply(_fn3, inject);
							}
							return obj.cache;
							break;
						case $module.CONST.TYPE.SERVICE:
							if (!obj.cache) {
								var _fn4 = obj.fn || this.noop;
								var serviceObj = Object.create(_fn4.prototype);
								_fn4.apply(serviceObj, inject);
								obj.cache = serviceObj;
							}
							return obj.cache;
							break;
						case $module.CONST.TYPE.VALUE:
							return obj.cache;
							break;
						case $module.CONST.TYPE.CONSTANT:
							return obj.cache;
							break;
						case $module.CONST.TYPE.RUN:
							var _fn2 = obj.fn || this.noop;
							return _fn2.apply(_fn2, inject);
							break;
						default:
							return null;
					}
				}
		};
<span id='$modules-method-addModule'>		/**
</span>   * Add a new module to the application.
   * 
   * @param {String} name Module name
   * @param {Array} [dependencies] Module dependencies
   * @return {Object} Created module
   * @member $modules
   * @method addModule
   */
		$modules.prototype.addModule = function addModule(name, dependencies) {
			var module = new $module(name, dependencies);
			this._modulesObj[name] = module;
			this._modules.push(module);
			return module;
		};
		return $modules;
	}();
	;
	// new instance from $modules class
	var $modulesInst = new $modules();
	/* ************************************* onix **************************** */
<span id='onix'>	/**
</span>  * Main framework object, which is created like new module with name &#39;onix&#39;.
  * Module has addtional functions.
  * 
  * @class onix
  */
	var onix = $modulesInst.addModule(&quot;onix&quot;);
<span id='onix-static-method-module'>	/**
</span>  * Add a new module to the application.
  * 
  * @param {String} name Module name
  * @param {Array} [dependencies] Module dependencies
  * @return {$module} Created module
  * @static
  * @member onix
  */
	onix.module = function (name, dependencies) {
		return $modulesInst.addModule(name, dependencies);
	};
<span id='onix-static-method-noop'>	/**
</span>  * Empty function.
  *
  * @member onix
  * @method noop
  * @static
  */
	onix.noop = $modulesInst.noop;
<span id='onix-static-method-info'>	/**
</span>  * Framework info.
  *
  * version: 2.7.3
  * date: 8. 7. 2016
  * @member onix
  * @static
  */
	onix.info = function () {
		console.log(&#39;OnixJS framework\n&#39;+
&#39;2.7.3/8. 7. 2016\n&#39;+
&#39;source: https://gitlab.com/LorDOniX/onix\n&#39;+
&#39;documentation: https://gitlab.com/LorDOniX/onix/tree/master/docs\n&#39;+
&#39;@license MIT\n&#39;+
&#39;- Free for use in both personal and commercial projects\n&#39;);
	};
	/* ************************************* $di **************************** */
	onix.factory(&quot;$di&quot;, function () {
<span id='$di'>		/**
</span>   * Helper factory for dependency injection and parsing function parameters.
   * 
   * @class $di
   */
		return {
<span id='$di-method-parseParam'>			/**
</span>    * Parse parameters. From param parse function and dependencies.
    *
    * @param  {Array|Function} param 
    * @return {Object} Parse object
    * @member $di
    */
			parseParam: $module.parseParam,
<span id='$di-method-getFilterName'>			/**
</span>    * Get filter name.
    * 
    * @param  {String} name
    * @return {String}
    * @member $di
    */
			getFilterName: $module.getFilterName,
<span id='$di-method-run'>			/**
</span>    * Run function with possible inject - handles dependency injection.
    * 
    * @param  {Object} runObj
    * @param  {Function} runObj.fn
    * @param  {Array} runObj.inject
    * @return {Object} Function output
    * @member $di
    */
			run: function run(runObj) {
				if (!runObj) return null;
				if (!runObj.fn) {
					runObj.fn = function () {};
				}
				// def. type
				runObj.type = $module.CONST.TYPE.RUN;
				return $modulesInst.run(runObj);
			}
		};
	});
	return onix;
}();
<span id='$filter'>/**
</span> * Filter process input data and output can be used in template or in the code.
 *
 * @class $filter
 */
onix.factory(&quot;$filter&quot;, [&quot;$di&quot;, function ($di) {
<span id='$filter-method-filter'>	/**
</span>  * Return filter by his name or returns empty filter. Filter name is concatenation of $filter + Filter name.
  *
  * @method filter
  * @param  {String} filterName 
  * @return {Object}
  * @member $filter
  */
	return function (filterName) {
		var emptyFilter = function emptyFilter(value) {
			return value || &quot;&quot;;
		};
		if (!filterName) {
			return emptyFilter;
		}
		return $di.run({
			fn: function fn(moduleObj) {
				return moduleObj || emptyFilter;
			},
			// get filter name for injection
			inject: [$di.getFilterName(filterName)]
		});
	};
}]);
<span id='$common'>/**
</span> * Commom functions used in whole application.
 *
 * @class $common
 */
onix.service(&quot;$common&quot;, [&quot;$promise&quot;, function ($promise) {
<span id='$common-method-_objCopy'>	/**
</span>  * Object copy, from source to dest.
  *
  * @param  {Object} dest
  * @param  {Object} source
  * @member $common
  * @private
  */
	this._objCopy = function (dest, source) {
		var _this10 = this;
		Object.keys(source).forEach(function (prop) {
			if (source.hasOwnProperty(prop)) {
				dest[prop] = _this10.cloneValue(source[prop]);
			}
		});
	};
<span id='$common-method-_chainPromisesInner'>	/**
</span>  * Inner method for chaining promises.
  * 
  * @param  {Object[]} opts
  * @param  {String|Function} opts.method Function or method name inside scope
  * @param  {Object} opts.scope Scope for method function
  * @param  {Array} opts.args Additional arguments for function
  * @param  {Function} resolve Resolve callback for $promise
  * @param  {Array} outArray Array for output from all executed promises
  * @private
  * @member $common
  */
	this._chainPromisesInner = function (opts, resolve, outArray) {
		var _this11 = this;
		var firstItem = opts.shift();
		if (firstItem) {
			// string or function itself
			var fn = void 0;
			var error = false;
			switch (_typeof2(firstItem.method)) {
				case &quot;string&quot;:
					if (!firstItem.scope || !(firstItem.method in firstItem.scope)) {
						error = true;
					} else {
						fn = firstItem.scope[firstItem.method];
						if (typeof fn !== &quot;function&quot;) {
							error = true;
						}
					}
					break;
				case &quot;function&quot;:
					fn = firstItem.method;
					break;
				default:
					error = true;
			}
			if (!error) {
				fn.apply(firstItem.scope || fn, firstItem.args || []).then(function (data) {
					outArray.push(data);
					_this11._chainPromisesInner(opts, resolve, outArray);
				}, function (err) {
					outArray.push(err);
					_this11._chainPromisesInner(opts, resolve, outArray);
				});
			} else {
				resolve(outArray);
			}
		} else {
			resolve(outArray);
		}
	};
<span id='$common-method-confirm'>	/**
</span>  * Confirm window, returns promise.
  *
  * @param  {String} txt
  * @return {$promise}
  * @member $common
  */
	this.confirm = function (txt) {
		return new $promise(function (resolve, reject) {
			if (confirm(txt)) {
				resolve();
			} else {
				reject();
			}
		});
	};
<span id='$common-method-merge'>	/**
</span>  * Merge multiple objects into the single one.
  *
  * @return {Object}
  * @member $common
  */
	this.merge = function () {
		var count = arguments.length;
		var dest = {};
		if (count &gt; 0) {
			for (var i = 0; i &lt; count; i++) {
				var source = arguments[i];
				this._objCopy(dest, source);
			}
		}
		return dest;
	};
<span id='$common-method-extend'>	/**
</span>  * Extend one object by other; from source to dest.
  *
  * @param  {Object} dest
  * @param  {Object} source
  * @member $common
  */
	this.extend = function (dest, source) {
		dest = dest || {};
		source = source || {};
		this._objCopy(dest, source);
	};
<span id='$common-method-cloneValue'>	/**
</span>  * Clone value without references.
  * 
  * @param  {Object} value Input value
  * @param  {Number} [lvl] Recursive threshold
  * @return {Object} cloned value
  * @member $common
  */
	this.cloneValue = function (value, lvl) {
		var _this12 = this;
		lvl = lvl || 1;
		// recursive call threshold
		if (lvl &gt; 100) return null;
		switch (typeof value === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(value)) {
			case &quot;object&quot;:
				if (Array.isArray(value)) {
					var _ret2 = function () {
						// array
						var newArray = [];
						value.forEach(function (item) {
							newArray.push(_this12.cloneValue(item, lvl + 1));
						});
						return {
							v: newArray
						};
					}();
					if ((typeof _ret2 === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(_ret2)) === &quot;object&quot;) return _ret2.v;
				} else if (value instanceof Date) {
					// date
					return new Date(value.getTime());
				} else if (value instanceof Element) {
					// element
					return value;
				} else if (value) {
					var _ret3 = function () {
						// object
						var newObj = {};
						Object.keys(value).forEach(function (prop) {
							if (value.hasOwnProperty(prop)) {
								newObj[prop] = _this12.cloneValue(value[prop], lvl + 1);
							}
						});
						return {
							v: newObj
						};
					}();
					if ((typeof _ret3 === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(_ret3)) === &quot;object&quot;) return _ret3.v;
				} else {
					// null
					return null;
				}
			case &quot;undefined&quot;:
			case &quot;function&quot;:
			case &quot;number&quot;:
			case &quot;string&quot;:
				return value;
		}
	};
<span id='$common-method-inherit'>	/**
</span>  * Inherit function with another function/s.
  * First argument is source function, others are for inheritance.
  * Last parameters have higher priority than the previous ones.
  *
  * @member $common
  */
	this.inherit = function () {
		// first is source, rest is inherit classess
		var args = arguments;
		if (args.length &lt; 2) return;
		var source = args[0].prototype;
		var inherits = Array.prototype.slice.call(args, 1);
		// all inherits items
		inherits.forEach(function (inhItem) {
			// iterate prototype items
			for (var p in inhItem.prototype) {
				source[p] = _typeof2(inhItem.prototype[p]) != &quot;object&quot; ? inhItem.prototype[p] : JSON.parse(JSON.stringify(inhItem.prototype[p]));
			}
		});
	};
<span id='$common-method-bindWithoutScope'>	/**
</span>  * Bind function arguments without scope.
  *
  * @param  {Function} cb
  * @return {Function}
  * @member $common
  */
	this.bindWithoutScope = function (cb) {
		var bindArgs = Array.prototype.slice.call(arguments, 1);
		return function () {
			var internalArgs = Array.prototype.slice.call(arguments, 0);
			var args = Array.prototype.concat(internalArgs, bindArgs);
			return cb.apply(this, args);
		};
	};
<span id='$common-method-nodesForEach'>	/**
</span>  * Missing for each for Node array.
  *
  * @param  {Object[]} nodes
  * @param  {Function} cb
  * @param  {Object|Function} scope
  * @member $common
  */
	this.nodesForEach = function (nodes, cb, scope) {
		if (typeof cb !== &quot;function&quot;) return;
		if (nodes) {
			Array.prototype.slice.call(nodes).forEach(function (item, ind) {
				cb.apply(scope || cb, [item, ind]);
			});
		}
	};
<span id='$common-method-reverseForEach'>	/**
</span>  * Reverse for each.
  *
  * @param {Array} arr
  * @param {Function} cb
  * @param {Function} [scope]
  * @member $common
  */
	this.reverseForEach = function (arr, cb, scope) {
		if (typeof cb !== &quot;function&quot;) return;
		arr = arr || [];
		for (var i = arr.length - 1; i &gt;= 0; i--) {
			cb.apply(scope || this, [arr[i], i]);
		}
	};
<span id='$common-method-hexToD'>	/**
</span>  * HEX value to DEC.
  *
  * @param  {String} hex
  * @return {Number}
  * @member $common
  */
	this.hexToD = function (hex) {
		hex = hex.toLowerCase();
		switch (hex) {
			case &quot;a&quot;:
				return 10;
			case &quot;b&quot;:
				return 11;
			case &quot;c&quot;:
				return 12;
			case &quot;d&quot;:
				return 13;
			case &quot;e&quot;:
				return 14;
			case &quot;f&quot;:
				return 15;
			default:
				return parseInt(hex, 10);
		}
	};
<span id='$common-method-hexToRGB'>	/**
</span>  * HEX value to RGB.
  *
  * @param  {String} hexColor
  * @return {Object}
  * @member $common
  */
	this.hexToRGB = function (hexColor) {
		if (hexColor[0] == &quot;#&quot;) {
			hexColor = hexColor.replace(&quot;#&quot;, &quot;&quot;);
			if (hexColor.length == 3) {
				return {
					r: this.hexToD(hexColor[0]) * 16 + this.hexToD(hexColor[0]),
					g: this.hexToD(hexColor[1]) * 16 + this.hexToD(hexColor[1]),
					b: this.hexToD(hexColor[2]) * 16 + this.hexToD(hexColor[2])
				};
			} else {
				return {
					r: this.hexToD(hexColor[0]) * 16 + this.hexToD(hexColor[1]),
					g: this.hexToD(hexColor[2]) * 16 + this.hexToD(hexColor[3]),
					b: this.hexToD(hexColor[4]) * 16 + this.hexToD(hexColor[5])
				};
			}
		} else {
			return hexColor;
		}
	};
<span id='$common-method-isElement'>	/**
</span>  * Is value element?
  *
  * @param  {Object} val
  * @return {Boolean}
  * @member $common
  */
	this.isElement = function (val) {
		return val instanceof HTMLElement;
	};
<span id='$common-method-isObject'>	/**
</span>  * Is item object?
  * 
  * @param  {Object} item
  * @return {Boolean}
  * @member $common
  */
	this.isObject = function (item) {
		return (typeof item === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(item)) === &quot;object&quot; &amp;&amp; !Array.isArray(item) &amp;&amp; item !== null;
	};
<span id='$common-method-col'>	/**
</span>  * Cover function for console.log, which allows to replace {0..n} occurences inside string.
  * First argument is string, other arguments are for replace objects by key.
  * 
  * @member $common
  */
	this.col = function () {
		var args = Array.prototype.slice.call(arguments);
		var output = &quot;&quot;;
		var params = {};
		args.forEach(function (arg, ind) {
			if (ind == 0) {
				output = arg;
			} else {
				params[&quot;[{]&quot; + (ind - 1) + &quot;[}]&quot;] = arg;
			}
		});
		Object.keys(params).forEach(function (param) {
			output = output.replace(new RegExp(param, &quot;g&quot;), params[param]);
		});
		if (output) {
			console.log(output);
		}
	};
<span id='$common-method-formatSize'>	/**
</span>  * Format size in bytes.
  * 
  * @param  {Number} size
  * @return {String}
  * @member $common
  */
	this.formatSize = function (size) {
		if (typeof size !== &quot;number&quot;) {
			return &quot;null&quot;;
		}
		var lv = size &gt; 0 ? Math.floor(Math.log(size) / Math.log(1000)) : 0;
		var sizes = [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;G&quot;, &quot;T&quot;];
		lv = Math.min(sizes.length, lv);
		var value = lv &gt; 0 ? (size / Math.pow(1000, lv)).toFixed(2) : size;
		return value + &quot; &quot; + sizes[lv] + &quot;B&quot;;
	};
<span id='$common-method-chainPromises'>	/**
</span>  * Chaining multiple methods with promises, returns promise.
  * 
  * @param  {Object[]} opts
  * @param  {String|Function} opts.method Function or method name inside scope
  * @param  {Object} opts.scope Scope for method function
  * @param  {Array} opts.args Additional arguments for function
  * @return {$promise}
  * @member $common
  */
	this.chainPromises = function (opts) {
		var _this13 = this;
		return new $promise(function (resolve) {
			_this13._chainPromisesInner(opts, resolve, []);
		});
	};
<span id='$common-method-cancelEvents'>	/**
</span>  * Cancel event and his propagation.
  * 
  * @param  {Event} e
  * @member $common
  */
	this.cancelEvents = function (e) {
		if (e) {
			e.stopPropagation();
			e.preventDefault();
		}
	};
<span id='$common-method-cssNameToJS'>	/**
</span>  * Converts css name to javascript style interpretation.
  * 
  * @param {String} value
  * @return {String} &quot;z-index&quot; -&gt; zIndex
  * @member $common
  */
	this.cssNameToJS = function (value) {
		var parts = value.split(&quot;-&quot;);
		var output = &quot;&quot;;
		parts.forEach(function (part, ind) {
			output += !ind ? part : part[0].toUpperCase() + part.substr(1);
		});
		return output;
	};
}]);
<span id='$cookie'>/**
</span> * Functionality over browser cookies.
 *
 * @class $cookie
 */
onix.service(&quot;$cookie&quot;, [&quot;$date&quot;, function ($date) {
<span id='$cookie-property-_CONST'>	/**
</span>  * $cookie constants.
  * 
  * @member $cookie
  * @private
  */
	this._CONST = {
		EXPIRES: {
			MAX: &quot;Fri, 31 Dec 9999 23:59:59 GMT&quot;,
			MIN: &quot;Thu, 01 Jan 1970 00:00:00 GMT&quot;
		}
	};
<span id='$cookie-method-set'>	/**
</span>  * Set cookie. Default expiration is 30 days from creation.
  *
  * @param  {String} name
  * @param  {String} value
  * @param  {Object} [optsArg]
  * @param  {Number|String|Date} [optsArg.expiration=null] Cookie expiration
  * @param  {String} [optsArg.path=&quot;&quot;] Cookie path
  * @param  {String} [optsArg.domain=&quot;&quot;] Cookie domain
  * @param  {String} [optsArg.secure=&quot;&quot;] Cookie secure
  * @return {Boolean}
  * @member $cookie
  * @private
  */
	this.set = function (name, value, optsArg) {
		if (!name || /^(?:expires|max\-age|path|domain|secure)$/i.test(name)) {
			return false;
		}
		var opts = {
			expiration: $date.addDays(new Date(), 30),
			path: &quot;&quot;,
			domain: &quot;&quot;,
			secure: &quot;&quot;
		};
		var expires = &quot;&quot;;
		if (opts.expiration) {
			switch (opts.expiration.constructor) {
				case Number:
					expires = opts.expiration === Infinity ? &quot;; expires=&quot; + this._CONST.EXPIRES.MAX : &quot;; max-age=&quot; + opts.expiration;
					break;
				case String:
					expires = &quot;; expires=&quot; + opts.expiration;
					break;
				case Date:
					expires = &quot;; expires=&quot; + opts.expiration.toUTCString();
					break;
			}
		}
		document.cookie = encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value) + expires + (opts.domain ? &quot;; domain=&quot; + opts.domain : &quot;&quot;) + (opts.path ? &quot;; path=&quot; + opts.path : &quot;&quot;) + (opts.secure ? &quot;; secure&quot; : &quot;&quot;);
		return true;
	};
<span id='$cookie-method-get'>	/**
</span>  * Get cookies by her name.
  *
  * @param  {String} name
  * @return {String}
  * @member $cookie
  * @private
  */
	this.get = function (name) {
		name = name || &quot;&quot;;
		var cookieValue = null;
		if (document.cookie &amp;&amp; document.cookie != &#39;&#39;) {
			var cookies = document.cookie.split(&#39;;&#39;);
			cookies.every(function (cookie) {
				cookie = cookie.trim();
				if (cookie.substring(0, name.length + 1) == name + &#39;=&#39;) {
					cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
					return false;
				} else return true;
			});
		}
		return cookieValue;
	};
<span id='$cookie-method-remove'>	/**
</span>  * Remove cookie.
  *
  * @param  {String} name Cookie name
  * @param  {String} [domain] Cookie domain
  * @param  {String} [path] Cookie path
  * @return {Boolean}
  * @member $cookie
  * @private
  */
	this.remove = function (name, domain, path) {
		if (!this.contains(name)) {
			return false;
		}
		document.cookie = encodeURIComponent(name) + &quot;=; expires=&quot; + this._CONST.EXPIRES.MIN + (domain ? &quot;; domain=&quot; + domain : &quot;&quot;) + (path ? &quot;; path=&quot; + path : &quot;&quot;);
		return true;
	};
<span id='$cookie-method-contains'>	/**
</span>  * Document contains cookie?
  *
  * @param  {String} name Cookie name
  * @return {Boolean}
  * @member $cookie
  * @private
  */
	this.contains = function (name) {
		if (!name) return false;
		return new RegExp(&quot;(?:^|;\\s*)&quot; + encodeURIComponent(name).replace(/[\-\.\+\*]/g, &quot;\\$&amp;&quot;) + &quot;\\s*\\=&quot;).test(document.cookie);
	};
}]);
<span id='$date'>/**
</span> * Date operations.
 * 
 * @class $date
 */
onix.service(&quot;$date&quot;, function () {
<span id='$date-method-dateENtoCS'>	/**
</span>  * Parse EN date to CS format.
  * year-month-day -&gt; day. month. year
  * 2016-06-31 -&gt; 31. 6. 2016
  * 
  * @param {String} enDate
  * @return {String}
  * @member $date
  */
	this.dateENtoCS = function (enDate) {
		enDate = enDate || &quot;&quot;;
		var parts = enDate.split(&quot;-&quot;);
		if (parts.length == 3) {
			// delete first 0
			return [parts[2].replace(/^0/, &quot;&quot;), parts[1].replace(/^0/, &quot;&quot;), parts[0]].join(&quot;. &quot;);
		} else {
			return &quot;&quot;;
		}
	};
<span id='$date-method-dateCStoEN'>	/**
</span>  * Parse CS date to EN format.
  * day. month. year -&gt; year-month-day
  * 31. 6. 2016 -&gt; 2016-06-31
  * 
  * @param {String} csDate
  * @return {String}
  * @member $date
  */
	this.dateCStoEN = function (csDate) {
		// day. month. year 31. 12. 2015
		csDate = csDate || &quot;&quot;;
		var parts = csDate.split(&quot;.&quot;);
		if (parts.length == 3) {
			var year = parts[2].trim();
			var month = parts[1].trim();
			var date = parts[0].trim();
			// add 0 from left
			date = date.length == 1 ? &quot;0&quot; + date : date;
			month = month.length == 1 ? &quot;0&quot; + month : month;
			return [year, month, date].join(&quot;-&quot;);
		} else {
			return &quot;&quot;;
		}
	};
<span id='$date-method-isCSdate'>	/**
</span>  * Is string contains CS date format?
  * 
  * @param  {String} csDate
  * @return {Boolean}
  * @member $date
  */
	this.isCSdate = function (csDate) {
		csDate = csDate || &quot;&quot;;
		return !!csDate.match(/([1-9]|[1-3][0-9])\.[ ]*([1-9]|1[0-2])\.[ ]*[1-9][0-9]{3}/);
	};
<span id='$date-method-addDays'>	/**
</span>  * Add days to date.
  * 
  * @param  {Date} date
  * @param  {Number} days
  * @return {Date}
  * @member $date
  */
	this.addDays = function (date, days) {
		days = days || 0;
		var addTime = 1000 * 60 * 60 * 24 * days;
		return new Date(date.getTime() + addTime);
	};
});
<span id='$dom'>/**
</span> * Class for creating DOM elements and getting their references.
 * 
 * @class $dom
 */
onix.service(&quot;$dom&quot;, [&quot;$common&quot;, function ($common) {
<span id='$dom-method-create'>	/**
</span>  * Create $dom from the configuration.
  *
  * @param  {Object} config
  * @param  {String} config.el Element name, default creates &quot;div&quot;
  * @param  {Object} [config.attrs] Atributes
  * @param  {Object} [config.css] Object with css styles
  * @param  {Array|Object} [config.events] Bind events {event, fn}
  * @param  {Array|Object} [config.child] Child nodes
  * @param  {String|Array} [config.class] Add CSS class/es
  * @param  {Object} [exported] to this object will be exported all marked elements (_exported attr.)
  * @return {Element}
  * @member $dom
  */
	this.create = function (config, exported) {
		var _this14 = this;
		var el = document.createElement(config.el || &quot;div&quot;);
		Object.keys(config).forEach(function (key) {
			var value = void 0;
			switch (key) {
				case &quot;el&quot;:
					break;
				case &quot;attrs&quot;:
					value = config.attrs;
					if (value &amp;&amp; (typeof value === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(value)) === &quot;object&quot; &amp;&amp; !Array.isArray(value)) {
						Object.keys(value).forEach(function (attr) {
							el.setAttribute(attr, value[attr]);
						});
					}
					break;
				case &quot;css&quot;:
					value = config.css;
					if (value &amp;&amp; (typeof value === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(value)) === &quot;object&quot; &amp;&amp; !Array.isArray(value)) {
						Object.keys(value).forEach(function (name) {
							el.style[$common.cssNameToJS(name)] = value[name];
						});
					}
					break;
				case &quot;events&quot;:
					value = config.events;
					if (!Array.isArray(value)) {
						value = [value];
					}
					value.forEach(function (child) {
						el.addEventListener(item.event, item.fn);
					});
					break;
				case &quot;child&quot;:
					value = config.child;
					if (!Array.isArray(value)) {
						value = [value];
					}
					value.forEach(function (child) {
						el.appendChild(_this14.create(child, exported));
					});
					break;
				case &quot;_exported&quot;:
					exported[config._exported] = el;
					break;
				case &quot;class&quot;:
					value = config[&quot;class&quot;];
					if (typeof value === &quot;string&quot;) {
						el.classList.add(value);
					} else if (Array.isArray(value)) {
						value.forEach(function (item) {
							el.classList.add(item);
						});
					}
					break;
				default:
					el[key] = config[key];
			}
		});
		return el;
	};
<span id='$dom-method-get'>	/**
</span>  * Get element from the document.
  *
  * @param  {String|Array} els Els = &quot;&quot; -&gt; element; [x, y] -&gt; { x: el, y: el }; [{sel: &quot;div&quot;, name: &quot;xyz&quot;}] -&gt; { &quot;xyz&quot;: div el }
  * @param  {Object} [parent]
  * @return {Object|Element}
  * @member $dom
  */
	this.get = function (els, parent) {
		parent = parent || document;
		var output = void 0;
		if (typeof els === &quot;string&quot; &amp;&amp; els) {
			output = parent.querySelector(els);
		} else if (Array.isArray(els)) {
			output = {};
			els.forEach(function (item) {
				var name = void 0;
				if (typeof item === &quot;string&quot;) {
					name = item.replace(/^[.# ]+/g, &quot;&quot;);
					output[name] = parent.querySelector(item);
				} else {
					name = item.sel.replace(/^[.# ]+/g, &quot;&quot;);
					output[item.name || name] = parent.querySelector(item.sel);
				}
			});
		}
		return output;
	};
}]);
function _classCallCheck(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError(&quot;Cannot call a class as a function&quot;);
	}
}
onix.factory(&quot;$event&quot;, function () {
<span id='$event'>	/**
</span>  * This class is used for extending existing objects and brings signal functionality.
  * 
 	 * @class $event
 	 */
	var $event = function () {
		function $event() {
			_classCallCheck(this, $event);
		}
<span id='$event-method-_eventInit'>		/**
</span>   * Init event functionality.
   * 
   * @member $event
   * @private
   * @method _eventInit
   */
		$event.prototype._eventInit = function _eventInit() {
<span id='$event-property-_allEvents'>			/**
</span>    * All events. { name: name, event: function, scope, [once] }
    * 
    * @type {Array}
    * @member $event
    * @private
    */
			this._allEvents = [];
		};
<span id='$event-method-on'>		/**
</span>   * Add new event to the stack.
   * 
   * @param  {String} name 
   * @param  {Function} fn
   * @param  {Object|Function} [scope]
   * @member $event
   * @method on
   */
		$event.prototype.on = function on(name, fn, scope) {
			if (!name || !fn) return;
			this._allEvents.push({
				name: name,
				fn: fn,
				scope: scope
			});
		};
<span id='$event-method-off'>		/**
</span>   * Remove event from the stack.
   * 
   * @param  {String} name 
   * @param  {Function} [fn]
   * @param  {Object|Function} [scope]
   * @member $event
   * @method off
   */
		$event.prototype.off = function off(name, fn, scope) {
			if (!name) return;
			var len = this._allEvents.length - 1;
			for (var i = len; i &gt;= 0; i--) {
				var item = this._allEvents[i];
				if (item.name != name) continue;
				if ((!fn || fn == item.fn) &amp;&amp; (!scope || scope == item.scope)) {
					this._allEvents.splice(i, 1);
				}
			}
		};
<span id='$event-method-once'>		/**
</span>   * Add one time event to the stack.
   * 
   * @param  {String} name
   * @param  {Function} [fn]
   * @param  {Object|Function} [scope]
   * @member $event
   * @method once
   */
		$event.prototype.once = function once(name, fn, scope) {
			if (!name || !fn) return;
			this._allEvents.push({
				name: name,
				fn: fn,
				scope: scope,
				once: true
			});
		};
<span id='$event-method-trigger'>		/**
</span>   * Trigger event with arguments 0..n.
   * 
   * @param  {String} name
   * @member $event
   * @method trigger
   */
		$event.prototype.trigger = function trigger(name) {
			if (!name) return;
			var args = Array.prototype.slice.call(arguments, 1);
			var len = this._allEvents.length - 1;
			for (var i = len; i &gt;= 0; i--) {
				var item = this._allEvents[i];
				if (item.name != name) continue;
				// call fn
				item.fn.apply(item.scope || this, args);
				// once event
				if (item.once) {
					this._allEvents.splice(i, 1);
				}
			}
		};
		return $event;
	}();
	;
	return $event;
});
function _classCallCheck(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError(&quot;Cannot call a class as a function&quot;);
	}
}
function _possibleConstructorReturn(self, call) {
	if (!self) {
		throw new ReferenceError(&quot;this hasn&#39;t been initialised - super() hasn&#39;t been called&quot;);
	}return call &amp;&amp; ((typeof call === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(call)) === &quot;object&quot; || typeof call === &quot;function&quot;) ? call : self;
}
function _inherits(subClass, superClass) {
	if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) {
		throw new TypeError(&quot;Super expression must either be null or a function, not &quot; + (typeof superClass === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(superClass)));
	}subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
onix.factory(&quot;$resize&quot;, [&quot;$event&quot;, function ($event) {
	// ------------------------ private ----------------------------------------
<span id='$resize'>	/**
</span>  * Handle window resize event, triggers signal &quot;resize&quot;.
  *
  * @class $resize
  */
	var $resize = function (_$event) {
		_inherits($resize, _$event);
		function $resize() {
			_classCallCheck(this, $resize);
			// event init
			var _this = _possibleConstructorReturn(this, _$event.call(this));
			_this._eventInit();
<span id='$resize-property-_active'>			/**
</span>    * Is active?
    *
    * @member $resize
    * @private
    */
			_this._active = false;
<span id='$resize-property-_resizeObj'>			/**
</span>    * Resize object.
    *
    * @member $resize
    * @private
    */
			_this._resizeObj = {
				id: null,
				timeout: 333
			};
<span id='$resize-property-_binds'>			/**
</span>    * Binds for functions.
    *
    * @member $resize
    * @private
    */
			_this._binds = {
				resize: _this._resize.bind(_this),
				resizeInner: _this._resizeInner.bind(_this)
			};
			return _this;
		}
<span id='$resize-method-_resize'>		/**
</span>   * Window resize event.
   *
   * @member $resize
   * @private
   * @method _resize
   */
		$resize.prototype._resize = function _resize() {
			if (this._resizeObj.id) {
				clearTimeout(this._resizeObj.id);
				this._resizeObj.id = null;
			}
			this._resizeObj.id = setTimeout(this._binds.resizeInner, this._resizeObj.timeout);
		};
<span id='$resize-method-_resizeInner'>		/**
</span>   * Window resize event - trigger signal &quot;resize&quot;.
   *
   * @member $resize
   * @private
   * @method _resizeInner
   */
		$resize.prototype._resizeInner = function _resizeInner() {
			this.trigger(&quot;resize&quot;);
		};
		// ------------------------ public ----------------------------------------
<span id='$resize-method-start'>		/**
</span>   * Bind resize event to window object.
   *
   * @member $resize
   * @method start
   */
		$resize.prototype.start = function start() {
			if (this._active) return;
			window.addEventListener(&quot;resize&quot;, this._binds.resize);
			this._active = true;
		};
<span id='$resize-method-end'>		/**
</span>   * Unbind resize event from window object.
   *
   * @member $resize
   * @method end
   */
		$resize.prototype.end = function end() {
			if (!this._active) return;
			window.removeEventListener(&quot;resize&quot;, this._binds.resize);
			this._active = false;
		};
		return $resize;
	}($event);
	;
	return new $resize();
}]);
var _typeof = typeof Symbol === &quot;function&quot; &amp;&amp; _typeof2(Symbol.iterator) === &quot;symbol&quot; ? function (obj) {
	return typeof obj === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(obj);
} : function (obj) {
	return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol ? &quot;symbol&quot; : typeof obj === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(obj);
};
<span id='$filterLowercase'>/**
</span> * Filter - lowercase functionality.
 *
 * @class $filterLowercase
 */
onix.filter(&quot;lowercase&quot;, function () {
<span id='$filterLowercase-method-lowercase'>	/**
</span>  * Input is transformatted to lowercase.
  *
  * @method lowercase
  * @param  {String} input
  * @return {String|Object}
  * @member $filterLowercase
  */
	return function (input) {
		if (typeof input === &quot;string&quot;) {
			return input.toLowerCase();
		} else {
			return input;
		}
	};
});
<span id='$filterUppercase'>/**
</span> * Filter - uppercase functionality.
 *
 * @class $filterUppercase
 */
onix.filter(&quot;uppercase&quot;, function () {
<span id='$filterUppercase-method-uppercase'>	/**
</span>  * Input is transformatted to uppercase.
  *
  * @method uppercase
  * @param  {String} input
  * @return {String|Object}
  * @member $filterUppercase
  */
	return function (input) {
		if (typeof input === &quot;string&quot;) {
			return input.toUpperCase();
		} else {
			return input;
		}
	};
});
<span id='$filterJson'>/**
</span> * Filter - json stringify functionality.
 *
 * @class $filterJson
 */
onix.filter(&quot;json&quot;, function () {
<span id='$filterJson-method-json'>	/**
</span>  * Input object is stringfied.
  *
  * @method json
  * @param {Object} obj Input object
  * @param {Number} [spacing] Number of spaces per indetation
  * @return {String}
  * @member $filterJson
  */
	return function (obj, spacing) {
		if ((typeof obj === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof(obj)) === &quot;object&quot;) {
			var space = null;
			if (spacing) {
				spacing = parseInt(spacing, 10);
				space = isNaN(spacing) ? null : spacing;
			}
			return JSON.stringify(obj, null, space);
		} else {
			return obj;
		}
	};
});
<span id='$http'>/**
</span> * XMLHttpRequest cover class.
 * 
 * @class $http
 */
onix.service(&quot;$http&quot;, [&quot;$promise&quot;, &quot;$common&quot;, &quot;$location&quot;, function ($promise, $common, $location) {
<span id='$http-method-_preparePostData'>	/**
</span>  * https://developer.mozilla.org/en-US/docs/Web/Guide/Using_FormData_Objects.
  * Prepare post data.
  *
  * @param  {Object|Array} data { name, value }
  * @return {Object}
  * @member $http
  * @private
  */
	this._preparePostData = function (data) {
		var formData = new FormData();
		if (data) {
			if (Array.isArray(data)) {
				data.forEach(function (item) {
					formData.append(item.name, item.value);
				});
			} else {
				Object.keys(data).forEach(function (key) {
					formData.append(key, data[key]);
				});
			}
		}
		return formData;
	};
<span id='$http-method-_updateURL'>	/**
</span>  * Update URL using get data.
  *
  * @param  {String} url
  * @param  {Array} data { name, value }
  * @return {String}
  * @member $http
  * @private
  */
	this._updateURL = function (url, data) {
		var getURL = $location.objToURL(data);
		if (getURL) {
			url += (url.indexOf(&quot;?&quot;) == -1 ? &quot;?&quot; : &quot;&quot;) + getURL;
		}
		return url;
	};
<span id='$http-property-POST_TYPES'>	/**
</span>  * Request types.
  *
  * @property {Object}
  * @param {Number} JSON
  * @param {Number} FORM_DATA
  * @member $http
  */
	this.POST_TYPES = {
		JSON: 1,
		FORM_DATA: 2
	};
<span id='$http-property-METHOD'>	/**
</span>  * Http methods.
  *
  * @property {Object}
  * @param {String} POST
  * @param {String} GET
  * @param {String} DELETE
  * @param {String} PATCH
  * @member $http
  */
	this.METHOD = {
		POST: &quot;POST&quot;,
		GET: &quot;GET&quot;,
		DELETE: &quot;DELETE&quot;,
		PATCH: &quot;PATCH&quot;
	};
<span id='$http-method-createRequest'>	/**
</span>  * Create new XHR request, returns promise.
  *
  * @param  {Object} config
  * @param  {String} config.url URL
  * @param  {String} [config.method] Method from $http.METHOD
  * @param  {String} [config.postType] Post type from $http.POST_TYPES
  * @param  {Object|Array} [config.getData] Data, which will be send in the url (GET)
  * @param  {Object|FormData} [config.postData] Post data
  * @param  {Object} [config.headers] Additional headers
  * @return {$promise}
  * @member $http
  */
	this.createRequest = function (config) {
		var _this = this;
		return new $promise(function (resolve, reject) {
			config = config || {};
			var request = new XMLHttpRequest();
			var method = config.method || _this.METHOD.GET;
			var url = config.url || &quot;&quot;;
			if (!url) {
				reject();
				return;
			}
			url = _this._updateURL(url, config.getData);
			request.onerror = function (err) {
				reject(err);
			};
			request.open(method, url, true);
			request.onreadystatechange = function () {
				if (request.readyState == 4) {
					var responseData = request.responseText || &quot;&quot;;
					var responseType = request.getResponseHeader(&quot;Content-Type&quot;);
					var promiseData = null;
					if (responseType == &quot;application/json&quot;) {
						promiseData = responseData.length ? JSON.parse(responseData) : {};
					} else {
						promiseData = responseData;
					}
					var promiseObj = {
						status: request.status,
						data: promiseData,
						url: url,
						method: method
					};
					// 200 ok
					// 201 created
					// 204 succesfully deleted
					// 403 unautorized
					if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) {
						resolve(promiseObj);
					} else {
						reject(promiseObj);
					}
				}
			};
			try {
				(function () {
					// add headers
					var headers = config.headers;
					if ($common.isObject(headers)) {
						Object.keys(headers).forEach(function (headerName) {
							request.setRequestHeader(headerName, headers[headerName]);
						});
					}
					if (method == _this.METHOD.GET) {
						request.setRequestHeader(&#39;Accept&#39;, &#39;application/json&#39;);
					}
					var type = config.postType || _this.POST_TYPES.JSON;
					if (config.postData &amp;&amp; type == _this.POST_TYPES.JSON) {
						request.setRequestHeader(&#39;Content-Type&#39;, &#39;application/json; charset=UTF-8&#39;);
						request.send(JSON.stringify(config.postData));
					} else if (config.postData &amp;&amp; type == _this.POST_TYPES.FORM_DATA) {
						request.send(_this._preparePostData(config.postData));
					} else {
						request.send();
					}
				})();
			} catch (err) {
				reject(err);
			}
		});
	};
}]);
function _classCallCheck(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError(&quot;Cannot call a class as a function&quot;);
	}
}
onix.provider(&quot;$i18n&quot;, function () {
<span id='$i18nProvider-property-_langs'>	/**
</span>  * All langs data.
  *
  * @type {Object}
  * @member $i18nProvider
  * @private
  */
	var _langs = {};
<span id='$i18nProvider-property-_currentLang'>	/**
</span>  * Current language-
  *
  * @type {String}
  * @member $i18nProvider
  * @private
  */
	var _currentLang = &quot;&quot;;
<span id='$i18nProvider-property-_bindGlobalTranslation'>	/**
</span>  * Bind global _ as translation function-
  *
  * @type {String}
  * @member $i18nProvider
  * @private
  */
	var _bindGlobalTranslation = true;
<span id='$i18nProvider-method-_transReplace'>	/**
</span>  * Replace translated text by object. This functions is implementation of message format object replace inside the string.
  *
  * @param  {String} translate
  * @param  {Object} [replace] Replace all {} in the string
  * @return {String}
  * @member $i18nProvider
  * @private
  */
	var _transReplace = function _transReplace(translate, replace) {
		translate = translate || &quot;&quot;;
		replace = replace || {};
		var replaceParts = translate.match(/{[^}]+,.*}|{[^}]*}/g);
		if (replaceParts) {
			(function () {
				var finalReplace = {};
				replaceParts.forEach(function (part) {
					var key = part;
					if (key.length &gt; 2) {
						key = key.substr(1, key.length - 2);
					}
					// multi
					var parts = key.split(&quot;,&quot;);
					var name = parts[0].trim();
					var multiPartsObj = {};
					if (parts.length == 2) {
						var multiParts = parts[1].match(/[a-zA-Z0-9_]+{[^}]*}/g);
						if (multiParts) {
							multiParts.forEach(function (mpart) {
								var mpartSplits = mpart.split(&quot;{&quot;);
								var mpartValue = mpartSplits[1];
								mpartValue = mpartValue.substr(0, mpartValue.length - 1);
								multiPartsObj[mpartSplits[0].trim()] = mpartValue;
							});
						}
					}
					var replaceValue = name in replace ? replace[name] : &quot;&quot;;
					if (typeof replaceValue === &quot;number&quot; &amp;&amp; Object.keys(multiPartsObj).length) {
						var multiKey = void 0;
						switch (replaceValue) {
							case 1:
								multiKey = &quot;one&quot;;
								break;
							case 2:
							case 3:
							case 4:
								multiKey = &quot;few&quot;;
								break;
							default:
								multiKey = &quot;other&quot;;
						}
						replaceValue = multiKey in multiPartsObj ? multiPartsObj[multiKey] : &quot;&quot;;
					}
					finalReplace[part] = replaceValue;
				});
				Object.keys(finalReplace).forEach(function (key) {
					translate = translate.replace(new RegExp(key, &quot;g&quot;), finalReplace[key]);
				});
			})();
		}
		return translate;
	};
<span id='$i18nProvider-method-_getText'>	/**
</span>  * Get text function. Translate for the current language and the key.
  *
  * @param  {String} key
  * @param  {Object} [replace] Replace all {} in the string
  * @return {String}
  * @member $i18nProvider
  * @private
  */
	var _getText = function _getText(key, replace) {
		key = key || &quot;&quot;;
		var lObj = _langs[_currentLang];
		var translate = &quot;&quot;;
		if (lObj) {
			(function () {
				var parts = key.split(&quot;.&quot;);
				var len = parts.length;
				parts.every(function (item, ind) {
					if (item in lObj) {
						lObj = lObj[item];
						if (ind == len - 1) {
							translate = lObj;
							return false;
						}
					} else {
						return false;
					}
					// go on
					return true;
				});
			})();
		}
		return _transReplace(translate, replace);
	};
<span id='$i18nProvider-method-_addLanguage'>	/**
</span>  * Add a new language.
  *
  * @param {String} lang Language key
  * @param {Object} data
  * @member $i18nProvider
  * @private
  */
	var _addLanguage = function _addLanguage(lang, data) {
		if (!lang || !data) return;
		if (!_langs[lang]) {
			_langs[lang] = {};
		}
		// merge
		Object.keys(data).forEach(function (key) {
			_langs[lang][key] = data[key];
		});
	};
<span id='$i18nProvider-method-_setLanguage'>	/**
</span>  * Set new language by his key.
  *
  * @param {String} lang Language key
  * @member $i18nProvider
  * @private
  */
	var _setLanguage = function _setLanguage(lang) {
		_currentLang = lang || &quot;&quot;;
	};
<span id='$i18nProvider-method-disableGlobalTranslation'>	/**
</span>  * Disable global translation in _
  *
  * @member $i18nProvider
  */
	this.disableGlobalTranslation = function () {
		_bindGlobalTranslation = false;
	};
<span id='$i18nProvider-method-addLanguage'>	/**
</span>  * Add a new language.
  *
  * @param {String} lang Language key
  * @param {Object} data
  * @member $i18nProvider
  */
	this.addLanguage = function (lang, data) {
		_addLanguage(lang, data);
	};
<span id='$i18nProvider-method-setLanguage'>	/**
</span>  * Set new language by his key.
  *
  * @param {String} lang Language key
  * @member $i18nProvider
  */
	this.setLanguage = function (lang) {
		_setLanguage(lang);
	};
<span id='$i18nProvider-method-postProcess'>	/**
</span>  * Post process during config phase.
  *
  * @member $i18nProvider
  */
	this.postProcess = function () {
		if (_bindGlobalTranslation) {
<span id='window-property-_'>			/**
</span>    * Get text function. Translate for the current language and the key.
    *
    * @param  {String} key
    * @param  {Object} [replace] Replace all {} in the string
    * @return {String}
    * @member window
    * @property {Function}
    */
			window._ = _getText;
		}
	};
<span id='$i18nProvider-method-S-get'>	/**
</span>  * Function that creates $i18n.
  * 
  * @member $i18nProvider
  * @return {Array}
  */
	this.$get = [&quot;$http&quot;, &quot;$promise&quot;, function ($http, $promise) {
<span id='$i18n'>		/**
</span>   * Language support, string translation with support for message format syntax.
   * 
   * @class $i18n
   */
		var $i18n = function () {
			function $i18n() {
				_classCallCheck(this, $i18n);
			}
<span id='$i18n-method-_'>			/**
</span>    * Get text function. Translate for the current language and the key.
    *
    * @param  {String} key
    * @param  {Object} [replace] Replace all {} in the string
    * @return {String}
    * @member $i18n
    * @method _
    */
			$i18n.prototype._ = function _(key, replace) {
				return _getText(key, replace);
			};
<span id='$i18n-method-addLanguage'>			/**
</span>    * Add a new language.
    *
    * @param {String} lang Language key
    * @param {Object} data
    * @member $i18n
    * @method addLanguage
    */
			$i18n.prototype.addLanguage = function addLanguage(lang, data) {
				_addLanguage(lang, data);
			};
<span id='$i18n-method-setLanguage'>			/**
</span>    * Set new language by his key.
    *
    * @param {String} lang Language key
    * @member $i18n
    * @method setLanguage
    */
			$i18n.prototype.setLanguage = function setLanguage(lang) {
				_setLanguage(lang);
			};
<span id='$i18n-method-getLanguage'>			/**
</span>    * Get current language key.
    *
    * @return {String} Language key
    * @member $i18n
    * @method getLanguage
    */
			$i18n.prototype.getLanguage = function getLanguage(lang) {
				return _currentLang;
			};
<span id='$i18n-method-getAllLanguages'>			/**
</span>    * Get all languages keys.
    *
    * @return {Array[String]} Languages keys
    * @member $i18n
    * @method getAllLanguages
    */
			$i18n.prototype.getAllLanguages = function getAllLanguages(lang) {
				return Object.keys(_langs);
			};
<span id='$i18n-method-loadLanguage'>			/**
</span>    * Load language from the file.
    *
    * @param  {String} lang Language key
    * @param  {String} url  Path to the file
    * @return {$promise}
    * @member $i18n
    * @method loadLanguage
    */
			$i18n.prototype.loadLanguage = function loadLanguage(lang, url) {
				return new $promise(function (resolve, reject) {
					$http.createRequest({
						url: url
					}).then(function (okData) {
						_addLanguage(lang, okData.data);
						resolve();
					}, function (errorData) {
						reject(errorData);
					});
				});
			};
			return $i18n;
		}();
		;
		return new $i18n();
	}];
});
<span id='$i18n-property-'>/**
</span> * Provider for registering _ translate object.
 */
onix.config([&quot;$i18nProvider&quot;, function ($i18nProvider) {
	$i18nProvider.postProcess();
}]);
<span id='$image'>/**
</span> * Class for creating img previews from File[] variable.
 * 
 * @class $image
 */
onix.service(&quot;$image&quot;, [&quot;$promise&quot;, &quot;$features&quot;, function ($promise, $features) {
<span id='$image-method-readFromFile'>	/**
</span>  * Read one image file - gets canvas with it. EXIF is readed, you can specific max size for image scale.
  *
  * @param  {Object} file Input file
  * @param  {Number} [maxSize] If image width/height is higher than this value, image will be scaled to this dimension
  * @return {$promise} Promise with output object
  * @member $image
  */
	this.readFromFile = function (file, maxSize) {
		var _this = this;
		return new $promise(function (resolve, reject) {
			if (!$features.FILE_READER) {
				reject();
				return;
			}
			var reader = new FileReader();
			var output = {
				img: null,
				exif: null,
				canvas: null
			};
			reader.onload = function (e) {
				var binaryData = reader.result;
				var binaryDataArray = new Uint8Array(binaryData);
				var exif = null;
				// exif only for jpeg
				if (file.type == &quot;image/jpeg&quot; || file.type == &quot;image/pjpeg&quot;) {
					exif = _this.getEXIF(binaryData);
				}
				var img = new Image();
				img.onload = function () {
					var imd = _this.getImageDim(img, maxSize);
					var canvas = _this.getCanvas(img, {
						width: imd.width,
						height: imd.height,
						orientation: exif ? exif.Orientation : 0,
						scaled: imd.scale != 1
					});
					output.img = img;
					output.exif = exif;
					output.canvas = canvas;
					resolve(output);
				};
				img.src = _this.fileToBase64(file.type, binaryDataArray);
			};
			reader.readAsArrayBuffer(file);
		});
	};
<span id='$image-method-getImageDim'>	/**
</span>  * Counts image dimension; if maxSize is available, new dimension is calculated.
  *
  * @param  {Image} img
  * @param  {Number} [maxSize] If image width/height is higher than this value, image will be scaled to this dimension
  * @return {Object}
  * @member $image
  */
	this.getImageDim = function (img, maxSize) {
		maxSize = maxSize || 0;
		var largeWidth = maxSize &gt; 0 &amp;&amp; img.width &gt; maxSize;
		var largeHeight = maxSize &gt; 0 &amp;&amp; img.height &gt; maxSize;
		var output = {
			width: img.width,
			height: img.height,
			scale: 1
		};
		if (largeWidth || largeHeight) {
			// resize picture
			var imgWidth = img.width;
			var imgHeight = img.height;
			// portrait x landscape
			if (img.width &gt; img.height) {
				// landscape
				imgHeight = maxSize * imgHeight / imgWidth;
				imgWidth = maxSize;
			} else {
				// portrait
				imgWidth = maxSize * imgWidth / imgHeight;
				imgHeight = maxSize;
			}
			output.scale = img.width / imgWidth; // ratio between original x scaled image
			output.width = imgWidth;
			output.height = imgHeight;
		}
		return output;
	};
<span id='$image-method-getCanvas'>	/**
</span>  * Get canvas from image/canvas - read input imgData, create canvas with it.
  *
  * @param  {Image} imgData
  * @param  {Object} [optsArg] Variable options
  * @param  {Number} [optsArg.width] Output canvas width
  * @param  {Number} [optsArg.height] Output canvas height
  * @param  {Number} [optsArg.orientation = 0] EXIF orientation; degrees 90, 180, 270 CCW
  * @param  {Boolean} [optsArg.scaled = false]
  * @param  {Canvas} [optsArg.canvas = null] Do not create canvas - use canvas from options
  * @return {Canvas}
  * @member $image
  */
	this.getCanvas = function (imgData, optsArg) {
		var opts = {
			width: imgData.width || 0,
			height: imgData.height || 0,
			orientation: 0,
			scaled: false,
			canvas: null
		};
		for (var key in optsArg) {
			opts[key] = optsArg[key];
		}
		if (!$features.CANVAS) {
			return null;
		}
		var canvas = opts.canvas || document.createElement(&quot;canvas&quot;);
		canvas.width = opts.width;
		canvas.height = opts.height;
		var ctx = canvas.getContext(&quot;2d&quot;);
		var draw = true;
		// rotate
		if (opts.orientation) {
			switch (opts.orientation) {
				case 2:
					// horizontal flip
					ctx.translate(opts.width, 0);
					ctx.scale(-1, 1);
					break;
				case 180:
				case 3:
					// 180° rotate left
					ctx.translate(opts.width, opts.height);
					ctx.rotate(Math.PI);
					break;
				case 4:
					// vertical flip
					ctx.translate(0, opts.height);
					ctx.scale(1, -1);
					break;
				case 5:
					// vertical flip + 90 rotate right
					canvas.width = opts.height;
					canvas.height = opts.width;
					ctx.rotate(0.5 * Math.PI);
					ctx.scale(1, -1);
					if (opts.scaled) {
						ctx.clearRect(0, 0, canvas.width, canvas.height);
						ctx.drawImage(imgData, 0, 0, imgData.width, imgData.height, 0, 0, canvas.height, canvas.width);
						draw = false;
					}
					break;
				case 90:
				case 6:
					// 90° rotate right
					canvas.width = opts.height;
					canvas.height = opts.width;
					ctx.rotate(0.5 * Math.PI);
					ctx.translate(0, -opts.height);
					if (opts.scaled) {
						ctx.clearRect(0, 0, canvas.width, canvas.height);
						ctx.drawImage(imgData, 0, 0, imgData.width, imgData.height, 0, 0, canvas.height, canvas.width);
						draw = false;
					}
					break;
				case 7:
					// horizontal flip + 90 rotate right
					canvas.width = opts.height;
					canvas.height = opts.width;
					ctx.rotate(0.5 * Math.PI);
					ctx.translate(opts.width, -opts.height);
					ctx.scale(-1, 1);
					if (opts.scaled) {
						ctx.clearRect(0, 0, canvas.width, canvas.height);
						ctx.drawImage(imgData, 0, 0, imgData.width, imgData.height, 0, 0, canvas.height, canvas.width);
						draw = false;
					}
					break;
				case 270:
				case 8:
					// 90° rotate left
					canvas.width = opts.height;
					canvas.height = opts.width;
					ctx.rotate(-0.5 * Math.PI);
					ctx.translate(-opts.width, 0);
					if (opts.scaled) {
						ctx.clearRect(0, 0, canvas.width, canvas.height);
						ctx.drawImage(imgData, 0, 0, imgData.width, imgData.height, 0, 0, canvas.height, canvas.width);
						draw = false;
					}
			}
		}
		if (draw) {
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			if (opts.scaled) {
				ctx.drawImage(imgData, 0, 0, imgData.width, imgData.height, 0, 0, canvas.width, canvas.height);
			} else {
				ctx.drawImage(imgData, 0, 0);
			}
		}
		return canvas;
	};
<span id='$image-method-fileToBase64'>	/**
</span>  * Binary data to base64.
  *
  * @param  {String} fileType
  * @param  {Array} binaryData
  * @return {String}
  * @member $image
  */
	this.fileToBase64 = function (fileType, binaryData) {
		var length = binaryData.length;
		var output = &quot;&quot;;
		for (var i = 0; i &lt; length; i += 1) {
			output += String.fromCharCode(binaryData[i]);
		}
		return &#39;data:&#39; + fileType + &#39;;base64,&#39; + btoa(output);
	};
<span id='$image-method-isPicture'>	/**
</span>  * Is file a picture?
  *
  * @param  {File}  file
  * @return {Boolean}
  * @member $image
  */
	this.isPicture = function (file) {
		return file &amp;&amp; (file.type == &quot;image/jpeg&quot; || file.type == &quot;image/pjpeg&quot; || file.type == &quot;image/png&quot;);
	};
<span id='$image-method-getPictureFiles'>	/**
</span>  * Get picture files from array of files.
  * 
  * @param  {Array} array of files
  * @return {Array}
  * @member $image
  */
	this.getPictureFiles = function (files) {
		var pictureFiles = [];
		if (files &amp;&amp; files.length) {
			for (var i = 0; i &lt; files.length; i++) {
				var item = files[i];
				if (this.isPicture(item)) {
					pictureFiles.push(item);
				}
			}
		}
		return pictureFiles;
	};
<span id='$image-method-getPicturesCount'>	/**
</span>  * Get picture files count from the array of Files. This function uses &#39;getPictureFiles&#39;.
  * 
  * @param  {Array} array of files
  * @return {Boolean}
  * @member $image
  */
	this.getPicturesCount = function (files) {
		return this.getPictureFiles(files).length;
	};
<span id='$image-method-getEXIF'>	/**
</span>  * Get image EXIF information.
  * 
  * @param  {Binary[]} imgData Binary img data
  * @return {Object}
  * @member $image
  */
	this.getEXIF = function (imgData) {
		if (&quot;EXIF&quot; in window) {
			return EXIF.readFromBinaryFile(imgData);
		} else {
			return {};
		}
	};
}]);
function _classCallCheck(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError(&quot;Cannot call a class as a function&quot;);
	}
}
onix.factory(&quot;$job&quot;, [&quot;$promise&quot;, function ($promise) {
<span id='$job'>	/**
</span>  * Factory for manage multiple tasks.
  * 
  * @class $job
  */
	var $job = function () {
		function $job() {
			_classCallCheck(this, $job);
			this._isRunning = false;
			this._tasks = [];
			this._taskDone = {
				cb: null,
				scope: null
			};
		}
<span id='$job-method-add'>		/**
</span>   * Add task to job. Every job task needs to call doneFn(), which is added to the last argument position.
   * 
   * @param {Function} task Job function
   * @param {Function|Object} [scope] Variable function scope
   * @param {Object} [args] Add params to the function
   * @member $job
   * @method add
   */
		$job.prototype.add = function add(task, scope, args) {
			args = args || [];
			if (!Array.isArray(args)) {
				args = [args];
			}
			this._tasks.push({
				task: task,
				scope: scope,
				args: args
			});
		};
<span id='$job-method-start'>		/**
</span>   * Start job.
   *
   * @return {$promise} Returns promise for whole job
   * @member $job
   * @method start
   */
		$job.prototype.start = function start() {
			var _this = this;
			return new $promise(function (resolve, reject) {
				if (_this._isRunning || !_this._tasks.length) {
					reject();
					return;
				}
				// job is running
				_this._isRunning = true;
				// because of pop
				_this._tasks.reverse();
				_this._doJob(resolve);
			});
		};
<span id='$job-method-clear'>		/**
</span>   * Clear all job taks.
   *
   * @member $job
   * @method clear
   */
		$job.prototype.clear = function clear() {
			this._tasks = [];
		};
<span id='$job-method-setTaskDone'>		/**
</span>   * Set progress function, which will be called after each task will be done.
   * 
   * @param {Function} cb
   * @param {Function|Object} [scope]
   * @member $job
   * @method setTaskDone
   */
		$job.prototype.setTaskDone = function setTaskDone(cb, scope) {
			this._taskDone.cb = cb;
			this._taskDone.scope = scope;
		};
<span id='$job-method-_doJob'>		/**
</span>   * Internal function for running job queue.
   *
   * @param {Function} resolve Promise object
   * @member $job
   * @method _doJob
   */
		$job.prototype._doJob = function _doJob(resolve) {
			var _this2 = this,
			    _arguments = arguments;
			var rest = this._tasks.length;
			if (rest == 0) {
				this._isRunning = false;
				resolve();
			} else {
				var job = this._tasks.pop();
				job.task.apply(job.scope || job.task, job.args.concat(function () {
					if (_this2._taskDone.cb) {
						var doneFnArgs = Array.prototype.slice.call(_arguments, 0);
						_this2._taskDone.cb.apply(_this2._taskDone.scope || _this2._taskDone.cb, doneFnArgs);
					}
					_this2._doJob(resolve);
				}));
			}
		};
		return $job;
	}();
	;
	return {
<span id='$job-method-create'>		/**
</span>   * Factory for creating new job.
   *
   * @member $job
   * @method create
   */
		create: function create() {
			return new $job();
		},
<span id='$job-method-multipleJobs'>		/**
</span>   * Run jobs array with count for how many functions will be processed simultinously.
   *
   * @param  {Object[]} jobsArray Array with jobs objects
   * @param  {Function} jobsArray.task Job function
   * @param  {Function} [jobsArray.scope] Variable function scope
   * @param  {Function} [jobsArray.args] Add params to the function
   * @param  {Number} count How many functions processed simultinously
   * @param  {Object} taskDoneObj Callback after one task have been done
   * @param  {Object} taskDoneObj.cb Function
   * @param  {Object} [taskDoneObj.scope] Function scope
   * @return {$promise} Callback after all jobs are done
   * @member $job
   * @method multipleJobs
   */
		multipleJobs: function multipleJobs(jobsArray, count, taskDoneObj) {
			var len = jobsArray.length;
			var jobs = [];
			for (var i = 0; i &lt; len; i++) {
				var jp = count &gt; 0 ? i % count : i;
				var jobItem = jobsArray[i];
				if (!jobs[jp]) {
					jobs[jp] = this.create();
					if (taskDoneObj) {
						jobs[jp].setTaskDone(taskDoneObj.cb, taskDoneObj.scope);
					}
				}
				// add one job
				jobs[jp].add(jobItem.task, jobItem.scope, jobItem.args);
			}
			var jobPromises = [];
			jobs.forEach(function (job) {
				jobPromises.push(job.start());
			});
			return $promise.all(jobPromises);
		}
	};
}]);
<span id='$localStorage'>/**
</span> * Cover class for localStorage.
 * 
 * @class $localStorage
 */
onix.factory(&quot;$localStorage&quot;, [&quot;$features&quot;, function ($features) {
	// localStorage provider
	var provider = $features.LOCAL_STORAGE ? window.localStorage : {
		_data: {},
		setItem: function setItem(key, value) {
			if (!key) return;
			this._data[key] = value;
		},
		getItem: function getItem(key) {
			if (!key) return null;
			return this._data[key];
		},
		removeItem: function removeItem(key) {
			if (!key) return;
			if (key in this._data) {
				delete this._data[key];
			}
		}
	};
	return {
<span id='$localStorage-method-set'>		/**
</span>   * Set value to localStorage.
   *
   * @param {String} key
   * @param {String} [value]
   * @member $localStorage
   */
		set: function set(key, value) {
			provider.setItem(key, value);
		},
<span id='$localStorage-method-get'>		/**
</span>   * Get value from localStorage.
   *
   * @param {String} key
   * @return {String}
   * @member $localStorage
   */
		get: function get(key) {
			return provider.getItem(key);
		},
<span id='$localStorage-method-remove'>		/**
</span>   * Remove key from localStorage.
   *
   * @param {String} key
   * @return {Boolean}
   * @member $localStorage
   */
		remove: function remove(key) {
			provider.removeItem(key);
		}
	};
}]);
var _typeof = typeof Symbol === &quot;function&quot; &amp;&amp; _typeof2(Symbol.iterator) === &quot;symbol&quot; ? function (obj) {
	return typeof obj === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(obj);
} : function (obj) {
	return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol ? &quot;symbol&quot; : typeof obj === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(obj);
};
<span id='$location'>/**
</span> * Support class for location operations.
 * 
 * @class $location
 */
onix.service(&quot;$location&quot;, function () {
	// ------------------------ public ----------------------------------------
<span id='$location-method-refresh'>	/**
</span>  * Page refresh.
  *
  * @member $location
  */
	this.refresh = function () {
		window.location.reload();
	};
<span id='$location-method-createSearchURL'>	/**
</span>  * Create a new search url. This method appends ? to the start of the url.
  * 
  * @param  {Object} obj
  * @return {String}
  * @member $location
  */
	this.createSearchURL = function (obj) {
		var url = this.objToURL(obj);
		return url ? &quot;?&quot; + url : &quot;&quot;;
	};
<span id='$location-method-objToURL'>	/**
</span>  * Object to url.
  * 
  * @param  {Array|Object} { name: x, value: y} | obj Mapping key -&gt; name, value -&gt; value.
  * @return {String}
  * @member $location
  */
	this.objToURL = function (obj) {
		var url = [];
		if (Array.isArray(obj)) {
			obj.forEach(function (item) {
				url.push(encodeURIComponent(item.name) + &quot;=&quot; + encodeURIComponent(item.value));
			});
		} else if ((typeof obj === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof(obj)) === &quot;object&quot;) {
			Object.keys(obj).forEach(function (key) {
				url.push(encodeURIComponent(key) + &quot;=&quot; + encodeURIComponent(obj[key]));
			});
		}
		return url.join(&quot;&amp;&quot;);
	};
<span id='$location-method-search'>	/**
</span>  * Get or set new url search. obj -&gt; set new url from obj; !obj -&gt; create obj from search part of url.
  *
  * @param  {Object} [obj]
  * @return {Object}
  * @member $location
  */
	this.search = function (obj) {
		if (obj) {
			// write
			var newURL = this.createSearchURL(obj);
			if (newURL) {
				window.location.search = newURL;
			}
		} else {
			var _ret = function () {
				// read
				var data = location.search;
				var output = {};
				if (data) {
					data = data.replace(&quot;?&quot;, &quot;&quot;);
					data.split(&quot;&amp;&quot;).forEach(function (item) {
						var parts = item.split(&quot;=&quot;);
						var name = decodeURIComponent(parts[0]);
						output[name] = decodeURIComponent(parts[1]);
					});
				}
				return {
					v: output
				};
			}();
			if ((typeof _ret === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof(_ret)) === &quot;object&quot;) return _ret.v;
		}
	};
<span id='$location-method-get'>	/**
</span>  * Get current location.
  *
  * @return {String}
  * @member $location
  */
	this.get = function () {
		return window.location.pathname;
	};
});
<span id='$math'>/**
</span> * Many useful alghoritms.
 * 
 * @class $math
 */
onix.service(&quot;$math&quot;, function () {
<span id='$math-property-_CONST'>	/**
</span>  * Math constants.
  *
  * @private
  * @type {Object}
  * @member $math
  */
	this._CONST = {
		ZOOM: 156543.034
	};
<span id='$math-method-isBBoxIntersection'>	/**
</span>  * Is there two bounding box intersection?
  * 
  * @param  {Object} bbox1
  * @param  {Number} bbox1.x Left top coordinates - axe x
  * @param  {Number} bbox1.y Left top coordinates - axe y
  * @param  {Number} bbox1.width Width of the bbox
  * @param  {Number} bbox1.height Height of the bbox
  * @param  {Object} bbox2
  * @param  {Number} bbox2.x Left top coordinates - axe x
  * @param  {Number} bbox2.y Left top coordinates - axe y
  * @param  {Number} bbox2.width Width of the bbox
  * @param  {Number} bbox2.height Height of the bbox
  * @return {Boolean}
  * @member $math
  */
	this.isBBoxIntersection = function (bbox1, bbox2) {
		var ltx = Math.max(bbox1.x, bbox2.x);
		var lty = Math.max(bbox1.y, bbox2.y);
		var rbx = Math.min(bbox1.x + bbox1.width, bbox2.x + bbox2.width);
		var rby = Math.min(bbox1.y + bbox1.height, bbox2.y + bbox2.height);
		// width and height of intesection has to be higher than 0
		var width = Math.abs(rbx - ltx);
		var height = Math.abs(rby - lty);
		if (ltx &lt;= rbx &amp;&amp; lty &lt;= rby &amp;&amp; width * height &gt; 0) {
			return true;
		} else {
			return false;
		}
	};
<span id='$math-method-getBBox'>	/**
</span>  * Get BBox from points.
  * 
  * @param  {Object[]} points
  * @param  {Number} points.x Coordinate on axe x
  * @param  {Number} points.y Coordinate on axe y
  * @return {Object} Output bbox with x, y, width and height variables
  * @member $math
  */
	this.getBBox = function (points) {
		var minX = Infinity;
		var minY = Infinity;
		var maxX = -Infinity;
		var maxY = -Infinity;
		// for each point
		for (var i = 0; i &lt; points.length; i++) {
			minX = Math.min(points[i].x, minX);
			minY = Math.min(points[i].y, minY);
			maxX = Math.max(points[i].x, maxX);
			maxY = Math.max(points[i].y, maxY);
		}
		return {
			x: minX,
			y: minY,
			width: Math.abs(maxX - minX),
			height: Math.abs(maxY - minY)
		};
	};
<span id='$math-method-det2'>	/**
</span>  * Determinant 2x2 count.
  * 
  * @param {Number} x1
  * @param {Number} x2
  * @param {Number} y1
  * @param {Number} y2
  * @returns {Number}
  * @member $math
  */
	this.det2 = function (x1, x2, y1, y2) {
		return x1 * y2 - y1 * x2;
	};
<span id='$math-method-linesIntersection'>	/**
</span>  * Intersection of two lines.
  * 
  * @param  {Object} firstLine
  * @param  {Object} firstLine.x1 Line start axe x
  * @param  {Object} firstLine.y1 Line start axe y
  * @param  {Object} firstLine.x2 Line end axe x
  * @param  {Object} firstLine.y2 Line end axe y
  * @param  {Object} secondLine
  * @param  {Object} secondLine.x1 Line start axe x
  * @param  {Object} secondLine.y1 Line start axe y
  * @param  {Object} secondLine.x2 Line end axe x
  * @param  {Object} secondLine.y2 Line end axe y
  * @returns {Object} Intersection point x, y
  * @member $math
  */
	this.linesIntersection = function (firstLine, secondLine) {
		var TOLERANCE = 0.000001;
		var a = this.det2(firstLine.x1 - firstLine.x2, firstLine.y1 - firstLine.y2, secondLine.x1 - secondLine.x2, secondLine.y1 - secondLine.y2);
		// lines are parallel
		if (Math.abs(a) &lt; TOLERANCE) {
			return null;
		}
		var d1 = this.det2(firstLine.x1, firstLine.y1, firstLine.x2, firstLine.y2);
		var d2 = this.det2(secondLine.x1, secondLine.y1, secondLine.x2, secondLine.y2);
		var x = this.det2(d1, firstLine.x1 - firstLine.x2, d2, secondLine.x1 - secondLine.x2) / a;
		var y = this.det2(d1, firstLine.y1 - firstLine.y2, d2, secondLine.y1 - secondLine.y2) / a;
		if (x &lt; Math.min(firstLine.x1, firstLine.x2) - TOLERANCE || x &gt; Math.max(firstLine.x1, firstLine.x2) + TOLERANCE) {
			return null;
		}
		if (y &lt; Math.min(firstLine.y1, firstLine.y2) - TOLERANCE || y &gt; Math.max(firstLine.y1, firstLine.y2) + TOLERANCE) {
			return null;
		}
		if (x &lt; Math.min(secondLine.x1, secondLine.x2) - TOLERANCE || x &gt; Math.max(secondLine.x1, secondLine.x2) + TOLERANCE) {
			return null;
		}
		if (y &lt; Math.min(secondLine.y1, secondLine.y2) - TOLERANCE || y &gt; Math.max(secondLine.y1, secondLine.y2) + TOLERANCE) {
			return null;
		}
		return {
			x: Math.round(x),
			y: Math.round(y)
		};
	};
<span id='$math-method-pointBBoxIntersection'>	/**
</span>  * Is there point and bounding box intersection?
  * 
  * @param  {Object} point
  * @param  {Number} point.x Point coordinates - axe x
  * @param  {Number} point.y Point coordinates - axe y
  * @param  {Object} bbox
  * @param  {Number} bbox.x Left top coordinates - axe x
  * @param  {Number} bbox.y Left top coordinates - axe y
  * @param  {Number} bbox.width Width of the bbox
  * @param  {Number} bbox.height Height of the bbox
  * @return {Boolean}
  * @member $math
  */
	this.pointBBoxIntersection = function (point, bbox) {
		return point.x &gt;= bbox.x &amp;&amp; point.x &lt;= bbox.x + bbox.width &amp;&amp; point.y &gt;= bbox.y &amp;&amp; point.y &lt;= bbox.y + bbox.height;
	};
<span id='$math-method-log2'>	/**
</span>  * Logarithm - base 2.
  * 
  * @param  {Number} val Input value
  * @return {Number}
  * @member $math
  */
	this.log2 = function (val) {
		return Math.log(val) / Math.log(2);
	};
<span id='$math-method-zoomToDistance'>	/**
</span>  * Map zoom in mercator projection to distance in meters.
  * 
  * @param  {Number} zoom   Mercator zoom - 2..n
  * @param  {Number} horFOV Horizontal field of view
  * @param  {Number} height Screen height size
  * @return {Number} Distance in meters
  * @member $math
  */
	this.zoomToDistance = function (zoom, horFOV, height) {
		var resolution = this._CONST.ZOOM / Math.pow(2, zoom); // m/px
		var halfHeight = height / 2;
		var y = Math.floor(resolution * halfHeight);
		// we need a half - its in degrees - thats why / 2 * / 180 for radians [rad]; vertical fov -&gt; we need height
		var alfa = horFOV / 360 * Math.PI;
		return Math.floor(y / Math.tan(alfa));
	};
<span id='$math-method-distanceToZoom'>	/**
</span>  * Reverse function for zoomToDistance - distance in meters to zoom in mercator projection.
  * 
  * @param  {Number} distance Distance in meters
  * @param  {Number} horFOV Horizontal field of view
  * @param  {Number} height Screen height size
  * @return {Number} Mercator zoom
  * @member $math
  */
	this.distanceToZoom = function (distance, horFOV, height) {
		var alfa = horFOV / 360 * Math.PI;
		var y = Math.tan(alfa) * distance;
		var mPPx = 2 * y / height; // distance / half of height; meters per pixel
		return Math.floor(this.log2(this._CONST.ZOOM / mPPx));
	};
<span id='$math-method-movePointByAngle'>	/**
</span>  * Move point coordinates by angle in degrees.
  * 
  * @param  {Object} point
  * @param  {Number} point.x Point coordinates - axe x
  * @param  {Number} point.y Point coordinates - axe y
  * @param  {Number} angle Angle in degrees CW
  * @member $math
  */
	this.movePointByAngle = function (point, angle) {
		var rad = (360 - angle) / 180 * Math.PI;
		var x = point.x;
		var y = point.y;
		point.x = x * Math.cos(rad) - y * Math.sin(rad);
		point.y = x * Math.sin(rad) + y * Math.cos(rad);
	};
<span id='$math-method-movePointByVector'>	/**
</span>  * Move point by vector, you can also rotate vector by angle in degrees.
  * 
  * @param  {Object} point
  * @param  {Number} point.x Point coordinates - axe x
  * @param  {Number} point.y Point coordinates - axe y
  * @param  {Object} vector
  * @param  {Number} vector.x Point coordinates - axe x
  * @param  {Number} vector.y Point coordinates - axe y
  * @param  {Number} [angle] Angle in degrees for vector rotation CW
  * @member $math
  */
	this.movePointByVector = function (point, vector, angle) {
		// because overwrite reference object
		var vectorSave = {
			x: vector.x,
			y: vector.y
		};
		this.movePointByAngle(vectorSave, angle || 0);
		point.x += vectorSave.x;
		point.y += vectorSave.y;
	};
<span id='$math-method-setRange'>	/**
</span>  * Set value in selected range.
  * 
  * @param {Number} value Input value
  * @param {Number} min Min value
  * @param {Number} max Max value
  * @return {Number}
  * @member $math
  */
	this.setRange = function (value, min, max) {
		if (value &lt; min) {
			return min;
		} else if (value &gt; max) {
			return max;
		} else {
			return value;
		}
	};
});
onix.factory(&quot;$myQuery&quot;, [&quot;$common&quot;, function ($common) {
<span id='$myQuery'>	/**
</span>  * DOM manipulation in the style of jquery.
  * 
  * @class $myQuery
  * @chainable
  * @param {String|HTMLElement|Array} value
  * @param {$myQuery|HTMLElement} [parent]
  * @member $myQuery
  */
	var $myQuery = function () {
		function $myQuery(value, parent) {
			_classCallCheck2(this, $myQuery);
			this._els = this._getElementsFromValue(value, parent);
			return this;
		}
<span id='$myQuery-method-_getElementsFromValue'>		/**
</span>   * Get elements from value [parent].
   * 
   * @param {String|HTMLElement|Array} value
   * @param {$myQuery|HTMLElement} [parent]
   * @return {Array}
   * @member $myQuery
   * @method _getElementsFromValue
   * @private
   */
		$myQuery.prototype._getElementsFromValue = function _getElementsFromValue(value, parent) {
			value = Array.isArray(value) ? value : [value];
			var els = [];
			value.forEach(function (val) {
				if (typeof val === &quot;string&quot;) {
					if (val.match(/&lt;[a-zA-Z]+&gt;/)) {
						// create el
						var el = document.createElement(&quot;div&quot;);
						el.innerHTML = val;
						els.push(el);
					} else {
						// selector
						if (parent instanceof $myQuery) {
							parent = parent.getEl();
						}
						parent = parent instanceof Element || parent == window || parent == document ? parent : document;
						var selValues = parent.querySelectorAll(val);
						if (selValues) {
							els = els.concat(Array.prototype.slice.call(selValues));
						}
					}
					return;
				} else if (val instanceof $myQuery) {
					val = val.getEl();
				}
				if (val instanceof Element || val == document || val == window) {
					els.push(val);
				}
			});
			return els;
		};
<span id='$myQuery-method-_operation'>		/**
</span>   * Operation on elements.
   * 
   * @param  {Function} cb
   * @param  {Function} [scope]
   * @member $myQuery
   * @private
   * @method _operation
   */
		$myQuery.prototype._operation = function _operation(cb, scope) {
			// NodeList -&gt; Array
			if (!Array.isArray(this._els)) {
				this._els = Array.prototype.slice.call(this._els);
			}
			this._els.forEach(function (item, ind) {
				cb.apply(scope || cb, [item, ind]);
			});
		};
<span id='$myQuery-method-_setGetAll'>		/**
</span>   * Set or get all - cover function.
   * 
   * @chainable
   * @param  {String} attr
   * @param  {String} [newValue]
   * @member $myQuery
   * @private
   * @method _setGetAll
   */
		$myQuery.prototype._setGetAll = function _setGetAll(attr, newValue) {
			var _this15 = this;
			if (typeof attr !== &quot;undefined&quot;) {
				if (typeof newValue !== &quot;undefined&quot;) {
					this._operation(function (item) {
						item[attr] = newValue;
					});
					return this;
				} else {
					var _ret4 = function () {
						var values = [];
						_this15._operation(function (item) {
							values.push(item[attr]);
						});
						if (!values.length) {
							return {
								v: null
							};
						} else if (values.length == 1) {
							return {
								v: values[0]
							};
						} else {
							return {
								v: values
							};
						}
					}();
					if ((typeof _ret4 === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(_ret4)) === &quot;object&quot;) return _ret4.v;
				}
			} else {
				return this;
			}
		};
<span id='$myQuery-method-_bindEvent'>		/**
</span>   * Bind event.
   *
   * @param {String} eventName Event name
   * @param {Function} cb Callback function
   * @param {Object} [scope] cb function scope
   * @chainable
   * @private
   * @method _bindEvent
   */
		$myQuery.prototype._bindEvent = function _bindEvent(eventName, cb, scope) {
			this._operation(function (item) {
				item.addEventListener(eventName, function (event) {
					cb.apply(scope || cb, [event, item]);
				});
			});
			return this;
		};
<span id='$myQuery-method-get'>		/**
</span>   * Get original element.
   *
   * @param  {Number} [ind]
   * @return {HTMLElement}
   * @member $myQuery
   * @method get
   */
		$myQuery.prototype.get = function get(ind) {
			ind = ind || 0;
			if (ind &gt; this._els.length) {
				return null;
			} else {
				return this._els[ind];
			}
		};
<span id='$myQuery-method-getEl'>		/**
</span>   * Get original element.
   *
   * @param  {Number} [ind]
   * @return {HTMLElement}
   * @member $myQuery
   * @method getEl
   */
		$myQuery.prototype.getEl = function getEl(ind) {
			return this.get(ind);
		};
<span id='$myQuery-method-attr'>		/**
</span>   * Get or set attribute.
   *
   * @chainable
   * @param  {String} name
   * @param  {String} [newValue]
   * @return {String|Array}
   * @member $myQuery
   * @method attr
   */
		$myQuery.prototype.attr = function attr(name, newValue) {
			var _this16 = this;
			if (typeof name !== &quot;undefined&quot;) {
				if (typeof newValue !== &quot;undefined&quot;) {
					this._operation(function (item) {
						item.setAttribute(name, newValue);
					});
					return this;
				} else {
					var _ret5 = function () {
						var values = [];
						_this16._operation(function (item) {
							values.push(item.getAttribute(name));
						});
						if (!values.length) {
							return {
								v: null
							};
						} else if (values.length == 1) {
							return {
								v: values[0]
							};
						} else {
							return {
								v: values
							};
						}
					}();
					if ((typeof _ret5 === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(_ret5)) === &quot;object&quot;) return _ret5.v;
				}
			} else {
				return this;
			}
		};
<span id='$myQuery-method-css'>		/**
</span>   * Get or set css value.
   *
   * @chainable
   * @param  {String|Object} name
   * @param  {String} [newValue]
   * @return {String}
   * @member $myQuery
   * @method css
   */
		$myQuery.prototype.css = function css(name, newValue) {
			var _this17 = this;
			if (typeof name !== &quot;undefined&quot;) {
				if (typeof newValue !== &quot;undefined&quot;) {
					this._operation(function (item) {
						item.style[$common.cssNameToJS(name)] = newValue;
					});
					return this;
				} else if ((typeof name === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(name)) === &quot;object&quot; &amp;&amp; !Array.isArray(name)) {
					Object.keys(name).forEach(function (key) {
						_this17._operation(function (item) {
							item.style[$common.cssNameToJS(key)] = name[key];
						});
					});
					return this;
				} else {
					var el = this.getEl();
					return el ? el.style[$common.cssNameToJS(name)] : null;
				}
			} else {
				return this;
			}
		};
<span id='$myQuery-method-src'>		/**
</span>   * Get or set src.
   * 
   * @param  {String} [newValue]
   * @return {String}
   * @member $myQuery
   * @method src
   */
		$myQuery.prototype.src = function src(newValue) {
			return this._setGetAll(&quot;src&quot;, newValue);
		};
<span id='$myQuery-method-hide'>		/**
</span>   * Hide element.
   * 
   * @chainable
   * @member $myQuery
   * @method hide
   */
		$myQuery.prototype.hide = function hide() {
			return this.css(&quot;display&quot;, &quot;none&quot;);
		};
<span id='$myQuery-method-show'>		/**
</span>   * Show element.
   *
   * @chainable
   * @param  {String} [displayStyle]
   * @member $myQuery
   * @method show
   */
		$myQuery.prototype.show = function show(displayStyle) {
			return this.css(&quot;display&quot;, displayStyle || &quot;&quot;);
		};
<span id='$myQuery-method-val'>		/**
</span>   * Get or set value.
   *
   * @chainable
   * @param  {String} [newValue]
   * @return {String}
   * @member $myQuery
   * @method val
   */
		$myQuery.prototype.val = function val(newValue) {
			return this._setGetAll(&quot;value&quot;, newValue);
		};
<span id='$myQuery-method-html'>		/**
</span>   * Get or set HTML.
   * 
   * @param  {String} [newValue]
   * @return {String}
   * @member $myQuery
   * @method html
   */
		$myQuery.prototype.html = function html(newValue) {
			return this._setGetAll(&quot;innerHTML&quot;, newValue);
		};
<span id='$myQuery-method-addClass'>		/**
</span>   * Add CSS class.
   *
   * @chainable
   * @param  {String} className
   * @member $myQuery
   * @method addClass
   */
		$myQuery.prototype.addClass = function addClass(className) {
			this._operation(function (item) {
				item.classList.add(className);
			});
			return this;
		};
<span id='$myQuery-method-removeClass'>		/**
</span>   * Remove CSS class.
   *
   * @chainable
   * @param  {String} className
   * @member $myQuery
   * @method removeClass
   */
		$myQuery.prototype.removeClass = function removeClass(className) {
			this._operation(function (item) {
				item.classList.remove(className);
			});
			return this;
		};
<span id='$myQuery-method-toggleClass'>		/**
</span>   * Toggle CSS class.
   *
   * @chainable
   * @param  {String} className
   * @member $myQuery
   * @method toggleClass
   */
		$myQuery.prototype.toggleClass = function toggleClass(className) {
			this._operation(function (item) {
				item.classList.toggle(className);
			});
			return this;
		};
<span id='$myQuery-method-width'>		/**
</span>   * Get width.
   * 
   * @return {Number}
   * @member $myQuery
   * @method width
   */
		$myQuery.prototype.width = function width() {
			var width = 0;
			this._operation(function (item) {
				width += item.offsetWidth;
			});
			return width;
		};
<span id='$myQuery-method-height'>		/**
</span>   * Get height.
   * 
   * @return {Number}
   * @member $myQuery
   * @method height
   */
		$myQuery.prototype.height = function height() {
			var height = 0;
			this._operation(function (item) {
				height += item.offsetHeight;
			});
			return height;
		};
<span id='$myQuery-method-click'>		/**
</span>   * Click event.
   *
   * @chainable
   * @param  {Function} cb
   * @param  {Function} [scope]
   * @member $myQuery
   * @method click
   */
		$myQuery.prototype.click = function click(cb, scope) {
			return this._bindEvent(&quot;click&quot;, cb, scope);
		};
<span id='$myQuery-method-change'>		/**
</span>   * Change event.
   *
   * @chainable
   * @param  {Function} cb
   * @param  {Function} [scope]
   * @member $myQuery
   * @method change
   */
		$myQuery.prototype.change = function change(cb, scope) {
			return this._bindEvent(&quot;change&quot;, cb, scope);
		};
<span id='$myQuery-method-mouseenter'>		/**
</span>   * Mouse enter event.
   *
   * @chainable
   * @param  {Function} cb
   * @param  {Function} [scope]
   * @member $myQuery
   * @method mouseenter
   */
		$myQuery.prototype.mouseenter = function mouseenter(cb, scope) {
			return this._bindEvent(&quot;mouseenter&quot;, cb, scope);
		};
<span id='$myQuery-method-mouseleave'>		/**
</span>   * Mouse leave event.
   *
   * @chainable
   * @param  {Function} cb
   * @param  {Function} [scope]
   * @member $myQuery
   * @method mouseleave
   */
		$myQuery.prototype.mouseleave = function mouseleave(cb, scope) {
			return this._bindEvent(&quot;mouseleave&quot;, cb, scope);
		};
<span id='$myQuery-method-mouseleave'>		/**
</span>   * Mouse move event.
   *
   * @chainable
   * @param  {Function} cb
   * @param  {Function} [scope]
   * @member $myQuery
   * @method mouseleave
   */
		$myQuery.prototype.mousemove = function mousemove(cb, scope) {
			return this._bindEvent(&quot;mousemove&quot;, cb, scope);
		};
<span id='$myQuery-method-keydown'>		/**
</span>   * Key down event.
   *
   * @chainable
   * @param  {Function} cb
   * @param  {Function} [scope]
   * @member $myQuery
   * @method keydown
   */
		$myQuery.prototype.keydown = function keydown(cb, scope) {
			return this._bindEvent(&quot;keydown&quot;, cb, scope);
		};
<span id='$myQuery-method-keyup'>		/**
</span>   * Key up event.
   *
   * @chainable
   * @param  {Function} cb
   * @param  {Function} [scope]
   * @member $myQuery
   * @method keyup
   */
		$myQuery.prototype.keyup = function keyup(cb, scope) {
			return this._bindEvent(&quot;keyup&quot;, cb, scope);
		};
<span id='$myQuery-method-keypress'>		/**
</span>   * Key press event.
   *
   * @chainable
   * @param  {Function} cb
   * @param  {Function} [scope]
   * @member $myQuery
   * @method keypress
   */
		$myQuery.prototype.keypress = function keypress(cb, scope) {
			return this._bindEvent(&quot;keypress&quot;, cb, scope);
		};
<span id='$myQuery-method-blur'>		/**
</span>   * Blur event.
   *
   * @chainable
   * @param  {Function} cb
   * @param  {Function} [scope]
   * @member $myQuery
   * @method blur
   */
		$myQuery.prototype.blur = function blur(cb, scope) {
			return this._bindEvent(&quot;blur&quot;, cb, scope);
		};
<span id='$myQuery-method-focus'>		/**
</span>   * Focus event.
   *
   * @chainable
   * @param  {Function} cb
   * @param  {Function} [scope]
   * @member $myQuery
   * @method focus
   */
		$myQuery.prototype.focus = function focus(cb, scope) {
			return this._bindEvent(&quot;focus&quot;, cb, scope);
		};
<span id='$myQuery-method-each'>		/**
</span>   * Each.
   *
   * @chainable
   * @param  {Function} cb
   * @param  {Function} [scope]
   * @member $myQuery
   * @method each
   */
		$myQuery.prototype.each = function each(cb, scope) {
			this._operation(function (item, ind) {
				cb.apply(scope || cb, [item, ind]);
			});
			return this;
		};
<span id='$myQuery-method-forEach'>		/**
</span>   * Foreach.
   *
   * @chainable
   * @param  {Function} cb
   * @param  {Function} [scope]
   * @member $myQuery
   * @method forEach
   */
		$myQuery.prototype.forEach = function forEach(cb, scope) {
			return this.each(cb, scope);
		};
<span id='$myQuery-method-remove'>		/**
</span>   * Remove element.
   *
   * @chainable
   * @member $myQuery
   * @method remove
   */
		$myQuery.prototype.remove = function remove() {
			this._operation(function (item) {
				item.parentNode.removeChild(item);
			});
			return this;
		};
<span id='$myQuery-method-append'>		/**
</span>   * Append another element to this one.
   *
   * @chainable
   * @param {HTMLElement|$myQuery|String} child
   * @member $myQuery
   * @method  append
   */
		$myQuery.prototype.append = function append(child) {
			child = this._getElementsFromValue(child);
			if (child.length) {
				this._operation(function (item) {
					item.appendChild(child[0]);
				});
			}
			return this;
		};
<span id='$myQuery-method-prepend'>		/**
</span>   * Prepend element.
   *
   * @chainable
   * @param {HTMLElement|$myQuery|string} child
   * @member $myQuery
   * @method prepend
   */
		$myQuery.prototype.prepend = function prepend(child) {
			child = this._getElementsFromValue(child);
			if (child.length) {
				this._operation(function (item) {
					item.parentNode.insertBefore(child[0], item);
				});
			}
			return this;
		};
<span id='$myQuery-method-prepend'>		/**
</span>   * Insert current element before element.
   *
   * @chainable
   * @param {HTMLElement|$myQuery|string} beforeEl
   * @member $myQuery
   * @method prepend
   */
		$myQuery.prototype.insertBefore = function insertBefore(beforeEl) {
			beforeEl = this._getElementsFromValue(beforeEl);
			var el = this.getEl();
			if (el &amp;&amp; beforeEl.length) {
				beforeEl[0].parentNode.insertBefore(el, beforeEl[0]);
			}
			return this;
		};
<span id='$myQuery-method-empty'>		/**
</span>   * Empty element - clear all its children.
   * Much faster than innerHTML = &quot;&quot;.
   * 
   * @chainable
   * @member $myQuery
   * @method empty
   */
		$myQuery.prototype.empty = function empty() {
			this._operation(function (item) {
				while (item.firstChild) {
					item.removeChild(item.firstChild);
				}
			});
			return this;
		};
<span id='$myQuery-method-len'>		/**
</span>   * Get all elements length.
   * 
   * @return {Number}
   * @member $myQuery
   * @method len
   */
		$myQuery.prototype.len = function len() {
			return this._els.length;
		};
<span id='$myQuery-method-parent'>		/**
</span>   * Get parent node.
   * 
   * @return {$myQuery} new instance with parent node
   * @member $myQuery
   * @method parent
   */
		$myQuery.prototype.parent = function parent() {
			var el = this.getEl();
			return el ? new this(el) : null;
		};
<span id='$myQuery-method-children'>		/**
</span>   * Get children.
   * 
   * @return {Array} Children array
   * @member $myQuery
   * @method children
   */
		$myQuery.prototype.children = function children() {
			var el = this.getEl();
			return el ? el.children : [];
		};
<span id='$myQuery-method-scrollTop'>		/**
</span>   * Get scroll top offset.
   * 
   * @return {Number} Scroll top in [px]
   * @member $myQuery
   * @method scrollTop
   */
		$myQuery.prototype.scrollTop = function scrollTop() {
			var el = this.getEl();
			var docOffset = document.body.scrollTop;
			return el ? el.scrollTop + docOffset : docOffset + 0;
		};
<span id='$myQuery-method-scrollLeft'>		/**
</span>   * Get scroll left offset.
   * 
   * @return {Number} Scroll left in [px]
   * @member $myQuery
   * @method scrollLeft
   */
		$myQuery.prototype.scrollLeft = function scrollLeft() {
			var el = this.getEl();
			var docOffset = document.body.scrollLeft;
			return el ? el.scrollLeft + docOffset : docOffset + 0;
		};
		return $myQuery;
	}();
	;
<span id='onix-property-element'>	/**
</span>  * Quick acces to myQuery and DOM manipulation.
  *
  * @param  {String|HTMLElement|Array} value
  * @param {HTMLElement|$myQuery} [parent] Parent node
  * @return {$myQuery}
  * @member onix
  * @property {Function}
  */
	onix.element = function (value, parent) {
		return new $myQuery(value, parent);
	};
	return {
<span id='$myQuery-method-get'>		/**
</span>  * Main cover function.
  * 
  * @param  {String|HTMLElement|Array} value
  * @param {HTMLElement} [parent]
  * @return {$myQuery}
  * @member $myQuery
  */
		get: function get(value, parent) {
			return new $myQuery(value, parent);
		}
	};
}]);
<span id='$myQuery-property-'>/**
</span> * Run for cache $myQuery object.
 */
onix.run([&quot;$myQuery&quot;, function () {
	// empty
}]);
function _classCallCheck(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError(&quot;Cannot call a class as a function&quot;);
	}
}
onix.factory(&quot;$promise&quot;, function () {
<span id='$promise'>	/**
</span>  * ES6 promise implementation.
  * Handle function(resolve, reject) object
  *
  * @param  {Function} cbFn Handle function
  * @class $promise
  */
	var $promise = function () {
		function $promise(cbFn) {
			_classCallCheck(this, $promise);
<span id='$promise-property-_STATES'>			/**
</span>    * Promise states.
    *
    * @member $promise
    * @private
    */
			this._STATES = {
				IDLE: 0,
				RESOLVED: 1,
				REJECTED: 2
			};
			// current state
			this._state = this._STATES.IDLE;
			// all funcs
			this._thens = [];
			// fulfill data
			this._fulfillData = null;
			// call promise cb function
			if (cbFn &amp;&amp; typeof cbFn === &quot;function&quot;) {
				try {
					cbFn.apply(cbFn, [this._resolve.bind(this), this._reject.bind(this)]);
				} catch (err) {
					console.error(&quot;$promise exception &quot; + err);
				}
			}
		}
<span id='$promise-method-_resolve'>		/**
</span>   * Resolve promise using obj.
   *
   * @private
   * @param  {Object} obj
   * @member $promise
   * @method _resolve
   */
		$promise.prototype._resolve = function _resolve(obj) {
			this._fulfillData = obj;
			this._state = this._STATES.RESOLVED;
			this._resolveFuncs();
		};
<span id='$promise-method-_reject'>		/**
</span>   * Reject promise using obj.
   *
   * @private
   * @param  {Object} obj
   * @member $promise
   * @method _reject
   */
		$promise.prototype._reject = function _reject(obj) {
			this._fulfillData = obj;
			this._state = this._STATES.REJECTED;
			this._resolveFuncs();
		};
<span id='$promise-method-_resolveFuncs'>		/**
</span>   * Resolve all functions.
   *
   * @member $promise
   * @private
   * @method _resolveFuncs
   */
		$promise.prototype._resolveFuncs = function _resolveFuncs() {
			var _this = this;
			var len = this._thens.length;
			var isCatch = this._state == this._STATES.REJECTED;
			for (var i = 0; i &lt; len; i++) {
				var thenItem = this._thens[i];
				var fn = isCatch &amp;&amp; thenItem.rejectCb ? thenItem.rejectCb : !isCatch &amp;&amp; thenItem.resolveCb ? thenItem.resolveCb : null;
				if (!fn) continue;
				try {
					var output = fn(this._fulfillData);
					// promise flattening
					if (output) {
						if (i != len - 1) {
							var _ret = function () {
								var resolveCb = null;
								var rest = _this._thens.slice(i + 1);
								var prom = void 0;
								if (output instanceof $promise) {
									prom = output;
								} else {
									prom = new $promise(function (resolve) {
										resolveCb = resolve;
									});
								}
								rest.forEach(function (restItem) {
									prom.then(restItem.resolveCb, restItem.rejectCb);
								});
								if (resolveCb) {
									resolveCb(output);
								}
								return &quot;break&quot;;
							}();
							if (_ret === &quot;break&quot;) break;
						}
					}
				} catch (err) {
					console.error(err);
				}
			}
			// clear array
			this._thens.length = 0;
		};
<span id='$promise-method-_isAlreadyFinished'>		/**
</span>   * Is promise already finished?
   *
   * @return {Boolean}
   * @member $promise
   * @private
   * @method _isAlreadyFinished
   */
		$promise.prototype._isAlreadyFinished = function _isAlreadyFinished() {
			if (this._state != this._STATES.IDLE) {
				this._resolveFuncs();
			}
		};
<span id='$promise-method-then'>		/**
</span>   * After promise resolve/reject call then (okFn, errorFn).
   *
   * @chainable
   * @param {Function} [resolveCb] Resolve function
   * @param {Function} [rejectCb] Reject function
   * @member $promise
   * @method then
   */
		$promise.prototype.then = function then(resolveCb, rejectCb) {
			this._thens.push({
				resolveCb: resolveCb &amp;&amp; typeof resolveCb === &quot;function&quot; ? resolveCb : null,
				rejectCb: rejectCb &amp;&amp; typeof rejectCb === &quot;function&quot; ? rejectCb : null
			});
			this._isAlreadyFinished();
			return this;
		};
<span id='$promise-method-catch'>		/**
</span>   * After promise reject call then rejectCb.
   *
   * @chainable
   * @param  {Function} rejectCb Reject function
   * @member $promise
   * @method catch
   */
		$promise.prototype[&quot;catch&quot;] = function _catch(rejectCb) {
			this._thens.push({
				resolveCb: null,
				rejectCb: rejectCb &amp;&amp; typeof rejectCb === &quot;function&quot; ? rejectCb : null
			});
			this._isAlreadyFinished();
			return this;
		};
<span id='$promise-static-method-_multiplePromises'>		/**
</span>   * Resolve multiple promises.
   * 
   * @param {$promise[]} promises
   * @param  {Boolean} isRace Is race?
   * @return {Boolean}
   * @member $promise
   * @private
   * @static
   * @method _multiplePromises
   */
		$promise._multiplePromises = function _multiplePromises(promises, isRace) {
			return new $promise(function (resolve) {
				if (Array.isArray(promises) &amp;&amp; promises.length) {
					(function () {
						var count = isRace ? 1 : promises.length;
						var test = function test(data) {
							count--;
							if (count == 0) {
								resolve(isRace ? data : null);
							}
						};
						promises.forEach(function (item) {
							item.then(function (okData) {
								test(okData);
							}, function (errorData) {
								test(errorData);
							});
						});
					})();
				} else {
					resolve();
				}
			});
		};
<span id='$promise-static-method-all'>		/**
</span>   * Resolve all promises in the array.
   *
   * @param {$promise[]} promises
   * @return {$promise}
   * @member $promise
   * @static
   * @method all
   */
		$promise.all = function all(promises) {
			return $promise._multiplePromises(promises);
		};
<span id='$promise-static-method-race'>		/**
</span>   * Race all promises in the array - first one resolves promise.
   *
   * @param {$promise[]} promises
   * @return {$promise} With the value from the first resolved promise.
   * @member $promise
   * @static
   * @method race
   */
		$promise.race = function race(promises) {
			return $promise._multiplePromises(promises, true);
		};
<span id='$promise-static-method-resolve'>		/**
</span>   * Resolve promise with variable object.
   *
   * @param {Object} [obj] Resolved object
   * @return {$promise}
   * @member $promise
   * @static
   * @method resolve
   */
		$promise.resolve = function resolve(obj) {
			return new $promise(function (resolve) {
				resolve(obj);
			});
		};
<span id='$promise-static-method-reject'>		/**
</span>   * Reject promise with variable object.
   *
   * @param {Object} [obj] Rejected object
   * @return {$promise}
   * @member $promise
   * @static
   * @method reject
   */
		$promise.reject = function reject(obj) {
			return new $promise(function (resolve, reject) {
				reject(obj);
			});
		};
		return $promise;
	}();
	;
	return $promise;
});
<span id='$route'>/**
</span> * Simple router for the application.
 * 
 * @class $route
 */
onix.service(&quot;$route&quot;, [&quot;$location&quot;, &quot;$template&quot;, &quot;$di&quot;, &quot;$routeParams&quot;, function ($location, $template, $di, $routeParams) {
<span id='$route-property-_routes'>	/**
</span>  * All routes.
  *
  * @private
  * @type {Array}
  * @member $route
  */
	this._routes = [];
<span id='$route-property-_otherwise'>	/**
</span>  * Otherwise route.
  *
  * @private
  * @type {Object}
  * @member $route
  */
	this._otherwise = null;
<span id='$route-property-_setRouteParams'>	/**
</span>  * Set $routeParams object. First clear all old keys and add new ones, if the available.
  *
  * @private
  * @param {Object} [routeParams] Route params object
  * @type {Object}
  * @member $route
  */
	this._setRouteParams = function (routeParams) {
		Object.keys($routeParams).forEach(function (key) {
			delete $routeParams[key];
		});
		routeParams = routeParams || {};
		Object.keys(routeParams).forEach(function (key) {
			$routeParams[key] = routeParams[key];
		});
	};
<span id='$route-method-when'>	/**
</span>  * Add route to the router.
  *
  * @chainable
  * @param  {String} url 
  * @param  {Object} config
  * @param  {String} [config.templateId] Template ID which will be used for templateUrl
  * @param  {String} [config.templateUrl] Template URL which will be loaded and cached in the $template
  * @param  {String} [config.controller] Run this function if the route is used
  * @param  {Object} [config.xyz] Rest parameters goes to the $routeParams
  * @member $route
  */
	this.when = function (url, config) {
		this._routes.push({
			url: url,
			config: config
		});
		return this;
	};
<span id='$route-method-otherwise'>	/**
</span>  * Otherwise.
  *
  * @chainable
  * @param  {String} page
  * @param  {Object} config
  * @param  {String} [config.templateId] Template ID which will be used for templateUrl
  * @param  {String} [config.templateUrl] Template URL which will be loaded and cached in the $template
  * @param  {String} [config.controller] Run this function if the route is used
  * @param  {Object} [config.xyz] Rest parameters goes to the $routeParams
  * @member $route
  */
	this.otherwise = function (config) {
		this._otherwise = {
			config: config
		};
		return this;
	};
<span id='$route-method-_runController'>	/**
</span>  * Run controller from route path.
  *
  * @private
  * @param  {Array|Function} contr
  * @param  {Object} [routeParams] Additonal data
  * @member $route
  */
	this._runController = function (contr, routeParams) {
		var pp = $di.parseParam(contr);
		this._setRouteParams(routeParams);
		$di.run({
			fn: pp.fn,
			inject: pp.inject
		});
	};
<span id='$route-method-go'>	/**
</span>  * Route GO. Walk through all routes, if there is match, route controller will be called.
  *
  * @member $route
  */
	this.go = function () {
		var _this = this;
		var path = $location.get();
		var find = false;
		var config = null;
		var data = {};
		this._routes.every(function (item) {
			if (path.match(new RegExp(item.url))) {
				config = item.config;
				find = true;
				return false;
			} else {
				return true;
			}
		});
		if (!find &amp;&amp; this._otherwise) {
			config = this._otherwise.config;
		}
		if (config) {
			(function () {
				var templateId = &quot;&quot;;
				var templateUrl = null;
				var contr = null;
				var routeParams = {};
				Object.keys(config).forEach(function (key) {
					var value = config[key];
					switch (key) {
						case &quot;templateId&quot;:
							templateId = value;
							break;
						case &quot;templateUrl&quot;:
							templateUrl = value;
							break;
						case &quot;controller&quot;:
							contr = value;
							break;
						default:
							routeParams[key] = value;
					}
				});
				// run controller function
				var runController = function runController() {
					if (contr) {
						_this._runController(contr, routeParams);
					}
				};
				if (templateUrl) {
					$template.load(config.templateId || config.templateUrl, config.templateUrl).then(runController);
				} else {
					runController();
				}
			})();
		}
	};
}]);
<span id='$routeParams'>/**
</span> * Data for controllers in the $route.
 * 
 * @class $routeParams
 */
onix.factory(&quot;$routeParams&quot;, function () {
	return {};
});
var _typeof = typeof Symbol === &quot;function&quot; &amp;&amp; _typeof2(Symbol.iterator) === &quot;symbol&quot; ? function (obj) {
	return typeof obj === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(obj);
} : function (obj) {
	return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol ? &quot;symbol&quot; : typeof obj === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(obj);
};
function _classCallCheck(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError(&quot;Cannot call a class as a function&quot;);
	}
}
onix.provider(&quot;$template&quot;, function () {
<span id='$templateProvider-property-_conf'>	/**
</span>  * Configuration for template delimeters.
  *
  * @type {Object}
  * @member $templateProvider
  * @private
  */
	var _conf = {
		left: &quot;{{&quot;,
		right: &quot;}}&quot;,
		elPrefix: &quot;data-&quot;,
		elDataBind: &quot;data-bind&quot;
	};
<span id='$templateProvider-method-setConfig'>	/**
</span>  * Set template config; you can use &quot;left&quot; {{ and &quot;right&quot; }} template delimeters, elPrefix = &quot;data-&quot; and elDataBind = &quot;data-bind&quot;
  * 
  * @param {Object} confParam Object with new config
  * @member $templateProvider
  */
	this.setConfig = function (confParam) {
		Object.keys(confParam).forEach(function (confParamKey) {
			_conf[confParamKey] = confParam[confParamKey];
		});
	};
<span id='$templateProvider-method-S-get'>	/**
</span>  * Function that creates $template.
  * 
  * @member $templateProvider
  * @return {Array}
  */
	this.$get = [&quot;$common&quot;, &quot;$promise&quot;, &quot;$http&quot;, &quot;$filter&quot;, function ($common, $promise, $http, $filter) {
<span id='$template'>		/**
</span>   * Handle templates, binds events - syntax similar to moustache and angular template system.
   * $myQuery is used for cache record.
   *
   * @class $template
   */
		var $template = function () {
			function $template() {
				_classCallCheck(this, $template);
<span id='$template-property-_cache'>				/**
</span>     * Template cache.
     *
     * @type {Object}
     * @member $template
     * @private
     */
				this._cache = {};
<span id='$template-property-_RE'>				/**
</span>     * Regular expressions for handle template variables.
     *
     * @type {Object}
     * @member $template
     * @private
     */
				this._RE = {
					VARIABLE: /[$_a-zA-Z][$_a-zA-Z0-9]+/g,
					NUMBERS: /[-]?[0-9]+[.]?([0-9e]+)?/g,
					STRINGS: /[&quot;&#39;][^&quot;&#39;]+[&quot;&#39;]/g,
					JSONS: /[{][^}]+[}]/g,
					ALL: /[-]?[0-9]+[.]?([0-9e]+)?|[&quot;&#39;][^&quot;&#39;]+[&quot;&#39;]|[{][^}]+[}]|[$_a-zA-Z][$_a-zA-Z0-9]+/g
				};
<span id='$template-property-_CONST'>				/**
</span>     * Constants.
     * 
     * @type {Object}
     * @member $template
     * @private
     */
				this._CONST = {
					FILTER_DELIMETER: &quot;|&quot;,
					FILTER_PARAM_DELIMETER: &quot;:&quot;,
					TEMPLATE_SCRIPT_SELECTOR: &quot;script[type=&#39;text/template&#39;]&quot;
				};
				// template init
				this._init();
			}
<span id='$template-method-_parseFnName'>			/**
</span>    * Parse a function name from the string.
    *
    * @param  {String} value
    * @return {String}
    * @member $template
    * @private
    * @method _parseFnName
    */
			$template.prototype._parseFnName = function _parseFnName(value) {
				value = value || &quot;&quot;;
				return value.match(/[a-zA-Z0-9_]+/)[0];
			};
<span id='$template-method-_parseArgs'>			/**
</span>    * Parse arguments from the string -&gt; makes array from them.
    *
    * @param  {String} value
    * @param  {Object} config
    * @param  {Object} config.$event Event object
    * @param  {Object} config.$element Reference to element
    * @return {Array}
    * @member $template
    * @private
    * @method _parseArgs
    */
			$template.prototype._parseArgs = function _parseArgs(value, config) {
				var _this = this;
				var argsValue = value ? value.replace(/^[^(]+./, &quot;&quot;).replace(/\).*$/, &quot;&quot;) : &quot;&quot;;
				var args = [];
				var matches = argsValue.match(this._RE.ALL);
				if (matches) {
					(function () {
						var all = [];
						matches.forEach(function (item) {
							var value = void 0;
							if (item.match(_this._RE.STRINGS)) {
								value = item.substr(1, item.length - 2);
							} else if (item.match(_this._RE.NUMBERS)) {
								value = parseFloat(item);
							} else if (item.match(_this._RE.JSONS)) {
								value = JSON.parse(item);
							} else if (item.match(_this._RE.VARIABLE)) {
								var variable = item.match(_this._RE.VARIABLE)[0];
								if (variable == &quot;$event&quot;) {
									value = config.event;
								} else if (variable == &quot;$element&quot;) {
									value = config.el;
								} else {
									// todo - maybe eval with scope
									value = null;
								}
							}
							all.push({
								value: value,
								pos: argsValue.indexOf(item)
							});
						});
						if (all.length) {
							all.sort(function (a, b) {
								return a.pos - b.pos;
							}).forEach(function (item) {
								args.push(item.value);
							});
						}
					})();
				}
				return args;
			};
<span id='$template-method-_bindEvent'>			/**
</span>    * Bind one single event to the element.
    * 
    * @param  {HTMLElement} el
    * @param  {Object} attr { name, value }
    * @param  {Function} scope
    * @member $template
    * @private
    * @method _bindEvent
    */
			$template.prototype._bindEvent = function _bindEvent(el, attr, scope) {
				var _this2 = this;
				if (!el || !attr || !scope) return;
				var eventName = attr.name.replace(_conf.elPrefix, &quot;&quot;);
				var fnName = this._parseFnName(attr.value);
				if (eventName &amp;&amp; fnName in scope) {
					el.addEventListener(eventName, function (event) {
						var args = _this2._parseArgs(attr.value, {
							el: el,
							event: event
						});
						scope[fnName].apply(scope, args);
					});
				}
			};
<span id='$template-method-_getAttributes'>			/**
</span>    * Get element prefixed attributes.
    * 
    * @param  {HTMLElement} el
    * @return {Array}
    * @member $template
    * @private
    * @method _getAttributes
    */
			$template.prototype._getAttributes = function _getAttributes(el) {
				var output = [];
				if (el &amp;&amp; &quot;attributes&quot; in el) {
					Object.keys(el.attributes).forEach(function (attr) {
						var item = el.attributes[attr];
						// ie8 fix
						if (!item || (typeof item === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof(item)) !== &quot;object&quot; || !item.name) return;
						if (item.name.indexOf(_conf.elPrefix) != -1) {
							output.push({
								name: item.name,
								value: item.value
							});
						}
					});
				}
				return output;
			};
<span id='$template-method-_init'>			/**
</span>    * Init - get all templates from the page. Uses &#39;text/template&#39; script with template data.
    * Each script has to have id and specifi type=&quot;text/template&quot;.
    *
    * @private
    * @member $template
    * @method _init
    */
			$template.prototype._init = function _init() {
				var _this3 = this;
				onix.element(this._CONST.TEMPLATE_SCRIPT_SELECTOR).forEach(function (item) {
					_this3.add(item.id || &quot;&quot;, item.innerHTML);
				});
			};
<span id='$template-method-add'>			/**
</span>    * Add new item to the cache.
    *
    * @param {String} key 
    * @param {String} data
    * @member $template
    * @method add
    */
			$template.prototype.add = function add(key, data) {
				this._cache[key] = data;
			};
<span id='$template-method-compile'>			/**
</span>    * Compile one template - replaces all ocurances of {{ xxx }} by model.
    *
    * @param  {String} key Template key/name
    * @param  {Object} data Model
    * @return {String}
    * @member $template
    * @method compile
    */
			$template.prototype.compile = function compile(key, data) {
				var _this4 = this;
				var tmpl = this.get(key);
				if (data) {
					var all = tmpl.match(new RegExp(_conf.left + &quot;(.*?)&quot; + _conf.right, &quot;g&quot;)) || [];
					all.forEach(function (item) {
						var itemSave = item;
						item = item.replace(new RegExp(&quot;^&quot; + _conf.left), &quot;&quot;).replace(new RegExp(_conf.right + &quot;$&quot;), &quot;&quot;);
						if (item.indexOf(_this4._CONST.FILTER_DELIMETER) != -1) {
							(function () {
								var filterValue = void 0;
								// filters
								item.split(_this4._CONST.FILTER_DELIMETER).forEach(function (filterItem, ind) {
									filterItem = filterItem.trim();
									if (!ind) {
										// value
										if (filterItem in data) {
											filterValue = data[filterItem];
										}
									} else {
										(function () {
											// preprocessing by filter
											var args = [filterValue];
											var filterParts = filterItem.split(_this4._CONST.FILTER_PARAM_DELIMETER);
											var filterName = &quot;&quot;;
											if (filterParts.length == 1) {
												filterName = filterParts[0].trim();
											} else {
												filterParts.forEach(function (filterPartItem, filterPartInd) {
													filterPartItem = filterPartItem.trim();
													if (!filterPartInd) {
														filterName = filterPartItem;
													} else {
														args.push(filterPartItem);
													}
												});
											}
											var filter = $filter(filterName);
											filterValue = filter.apply(filter, args);
										})();
									}
								});
								tmpl = tmpl.replace(itemSave, filterValue || &quot;&quot;);
							})();
						} else {
							// standard
							var replaceValue = &quot;&quot;;
							item = item.trim();
							if (item in data) {
								replaceValue = data[item];
							}
							tmpl = tmpl.replace(itemSave, replaceValue);
						}
					});
				}
				return tmpl;
			};
<span id='$template-method-get'>			/**
</span>    * Get template from the cache.
    *
    * @param  {String} key Template key/name
    * @return {String}
    * @member $template
    * @method get
    */
			$template.prototype.get = function get(key) {
				return this._cache[key] || &quot;&quot;;
			};
<span id='$template-method-bindTemplate'>			/**
</span>    * Bind all elements in the root element. Selectors all data-* and functions are binds against scope object.
    * For data-bind, scope has to have &quot;addEls&quot; function.
    * Supports: click, change, keydown, bind.
    *
    * @param  {HTMLElement} root Root element
    * @param  {Object} scope Scope which against will be binding used
    * @param  {Function} [addElsCb] Callback function with object with all data-bind objects
    * @member $template
    * @method bindTemplate
    */
			$template.prototype.bindTemplate = function bindTemplate(root, scope, addElsCb) {
				var _this5 = this;
				var allElements = onix.element(&quot;*&quot;, root);
				if (allElements.len()) {
					(function () {
						var newEls = {};
						allElements.forEach(function (item) {
							var attrs = _this5._getAttributes(item);
							attrs.forEach(function (attr) {
								if (attr.name == _conf.elDataBind) {
									newEls[attr.value] = item;
								} else {
									_this5._bindEvent(item, attr, scope);
								}
							});
						});
						if (addElsCb &amp;&amp; typeof addElsCb === &quot;function&quot;) {
							addElsCb(newEls);
						}
					})();
				}
			};
<span id='$template-method-load'>			/**
</span>    * Load template from the path, returns promise after load.
    *
    * @param  {String} key
    * @param  {String} path
    * @return {$promise}
    * @member $template
    * @method load
    */
			$template.prototype.load = function load(key, path) {
				var _this6 = this;
				return new $promise(function (resolve, reject) {
					$http.createRequest({
						url: path
					}).then(function (okData) {
						_this6.add(key, okData.data);
						resolve();
					}, function (errorData) {
						reject(errorData);
					});
				});
			};
			return $template;
		}();
		;
		return new $template();
	}];
});
<span id='$features'>/**
</span> * Browser features.
 * 
 * @class $features
 */
onix.service(&quot;$features&quot;, function () {
	// ------------------------ public ----------------------------------------
<span id='$features-property-FILE_READER'>	/**
</span>  * FileReader is available.
  *
  * @member $features
  * @type {Boolean}
  */
	this.FILE_READER = &quot;FileReader&quot; in window;
<span id='$features-property-CANVAS'>	/**
</span>  * Canvas is available.
  *
  * @member $features
  * @type {Boolean}
  */
	this.CANVAS = !!document.createElement(&quot;canvas&quot;).getContext;
	// local storage
	var locStor = true;
	try {
		window.localStorage;
	} catch (err) {
		locStor = false;
	}
<span id='$features-property-LOCAL_STORAGE'>	/**
</span>  * Local storage is available.
  *
  * @member $features
  * @type {Boolean}
  */
	this.LOCAL_STORAGE = locStor;
});
function _classCallCheck(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError(&quot;Cannot call a class as a function&quot;);
	}
}
function _possibleConstructorReturn(self, call) {
	if (!self) {
		throw new ReferenceError(&quot;this hasn&#39;t been initialised - super() hasn&#39;t been called&quot;);
	}return call &amp;&amp; ((typeof call === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(call)) === &quot;object&quot; || typeof call === &quot;function&quot;) ? call : self;
}
function _inherits(subClass, superClass) {
	if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) {
		throw new TypeError(&quot;Super expression must either be null or a function, not &quot; + (typeof superClass === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(superClass)));
	}subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
onix.factory(&quot;$anonymizer&quot;, [&quot;$math&quot;, &quot;$event&quot;, &quot;$loader&quot;, &quot;$promise&quot;, &quot;$common&quot;, &quot;$features&quot;, function ($math, $event, $loader, $promise, $common, $features) {
<span id='$anonymizer'>	/**
</span>  * Anonymizer - canvas for image preview with posibility for add geometries.
  *
  * @param {HTMLElement} parent Where is canvas appended
  * @param {Object} [optsArg] Configuration
  * @param {Number} [optsArg.canWidth] Canvas width
  * @param {Number} [optsArg.canHeight] Canvas height
  * @param {Number} [optsArg.zoom = 100] start zoom in [%]
  * @param {Number} [optsArg.minZoom = 20] min zoom in [%]
  * @param {Number} [optsArg.maxZoom = 100] max zoom in [%]
  * @param {Number} [optsArg.zoomStep = 10] How many [%] add/dec with zoom change
  * @param {Number} [optsArg.zoomMoveStep = 1] Under 100% multiplier for faster image movement
  * @param {Object} [optsArg.curEntity = $anonymizer.ENTITES.CIRCLE] Start entity from $anonymizer.ENTITES
  * @param {Number} [optsArg.showPreview = true] Show preview - image overview
  * @param {Number} [optsArg.previewLeft = 17] Preview location from left top corner, axe x [px]
  * @param {Number} [optsArg.previewTop = 17] Preview location from left top corner, axe y [px]
  * @param {Number} [optsArg.previewWidth = 200] Preview image width [px]
  * @param {HTMLElement} [optsArg.entityPreview = null] Create entity preview? Parent for append.
  * @class $anonymizer
  */
	var $anonymizer = function (_$event) {
		_inherits($anonymizer, _$event);
		function $anonymizer(parent, optsArg) {
			_classCallCheck(this, $anonymizer);
			// event init
			var _this = _possibleConstructorReturn(this, _$event.call(this));
			_this._eventInit();
			// is canvas available?
			if (!$features.CANVAS) {
				console.error(&quot;Canvas is not available!&quot;);
				return _possibleConstructorReturn(_this);
			}
			// parent reference
			_this._parent = parent;
			_this._parent.classList.add(&quot;anonymizer&quot;);
			_this._opts = {
				canWidth: parent.offsetWidth || 0,
				canHeight: parent.offsetHeight || 0,
				zoom: 100,
				minZoom: 20,
				maxZoom: 100,
				zoomStep: 10,
				zoomMoveStep: 1,
				curEntity: $anonymizer.ENTITES.CIRCLE,
				showPreview: true,
				previewLeft: 17,
				previewTop: 17,
				previewWidth: 200,
				entityPreview: null
			};
			for (var key in optsArg) {
				_this._opts[key] = optsArg[key];
			}
			// canvas width &amp; height
			_this._canWidth = _this._opts.canWidth;
			_this._canHeight = _this._opts.canHeight;
			// zoom
			_this._zoom = _this._opts.zoom;
			// zoom step
			_this._zoomStep = _this._opts.zoomStep;
			// step for zoom move
			_this._zoomMoveStep = 0;
			// act. image width
			_this._curWidth = 0;
			// act. image height
			_this._curHeight = 0;
			// create main canvas
			_this._canvas = document.createElement(&quot;canvas&quot;);
			_this._canvas.width = _this._canWidth;
			_this._canvas.height = _this._canHeight;
			// ctx of main canvas
			_this._ctx = _this._canvas.getContext(&quot;2d&quot;);
			// loaded image
			_this._img = null;
			// original image width
			_this._imgWidth = 0;
			// original image height
			_this._imgHeight = 0;
			// canvas &amp; ctx for create line
			_this._lineCanvas = null;
			_this._lineCanvasCtx = null;
			// canvas &amp; ctx for preview of a entity
			_this._entityCanvas = null;
			_this._entityCanvasCtx = null;
			// entites to draw
			_this._entites = [];
			// image draw offset axe x
			_this._x = 0;
			// image draw offset axe y
			_this._y = 0;
			// threshold for click
			_this._THRESHOLD = {
				MIN: -1,
				MAX: 1
			};
			// helper for mouse event
			_this._mouse = {
				startXSave: 0,
				startYSave: 0,
				startX: 0,
				startY: 0,
				bcr: null
			};
			_this._flags = {
				wasRightClick: false,
				wasMove: false,
				wasPreview: false,
				wasLine: false,
				wasImgMove: false
			};
			// binds
			_this._binds = {
				mouseWheel: _this._mouseWheel.bind(_this),
				mouseDown: _this._mouseDown.bind(_this),
				mouseMove: _this._mouseMove.bind(_this),
				mouseUp: _this._mouseUp.bind(_this),
				mouseMoveLine: _this._mouseMoveLine.bind(_this),
				mouseUpLine: _this._mouseUpLine.bind(_this),
				contextMenu: _this._cancelEvents.bind(_this)
			};
			// firefox
			_this._canvas.addEventListener(&quot;DOMMouseScroll&quot;, _this._binds.mouseWheel);
			// others
			_this._canvas.addEventListener(&quot;mousewheel&quot;, _this._binds.mouseWheel);
			_this._canvas.addEventListener(&quot;mousedown&quot;, _this._binds.mouseDown);
			_this._canvas.addEventListener(&quot;contextmenu&quot;, _this._binds.contextMenu);
			// spinner - progress for image load
			_this._spinner = $loader.getSpinner();
			parent.appendChild(_this._spinner);
			parent.appendChild(_this._canvas);
			// preview canvas
			if (_this._opts.entityPreview) {
				_this._entityCanvas = document.createElement(&quot;canvas&quot;);
				_this._entityCanvas.width = 300;
				_this._entityCanvas.height = 150;
				_this._entityCanvasCtx = _this._entityCanvas.getContext(&quot;2d&quot;);
				_this._opts.entityPreview.appendChild(_this._entityCanvas);
			}
			return _this;
		}
<span id='$anonymizer-method-_redraw'>		/**
</span>   * Scene redraw - clear, picture, entites.
   *
   * @private
   * @method _redraw
   * @member $anonymizer
   */
		$anonymizer.prototype._redraw = function _redraw() {
			var _this2 = this;
			// pictue
			this._ctx.clearRect(0, 0, this._canWidth, this._canHeight);
			this._ctx.drawImage(this._img, this._x, this._y, this._img.width, this._img.height, 0, 0, this._curWidth, this._curHeight);
			// entites
			if (this._entites.length) {
				(function () {
					var zc = _this2._zoom / 100;
					var xc = _this2._x * zc;
					var yc = _this2._y * zc;
					_this2._entites.forEach(function (entity) {
						var x = void 0;
						var y = void 0;
						switch (entity.id) {
							case $anonymizer.ENTITES.CIRCLE.id:
								var radius = Math.round(entity.value * zc);
								x = Math.round(_this2._curWidth * entity.xRatio - xc);
								y = Math.round(_this2._curHeight * entity.yRatio - yc);
								_this2._drawCircle(_this2._ctx, x, y, radius);
								break;
							case $anonymizer.ENTITES.LINE.id:
								var lineWidth = Math.round(entity.value * zc);
								x = Math.round(_this2._curWidth * entity.xRatio - xc);
								y = Math.round(_this2._curHeight * entity.yRatio - yc);
								var x2 = Math.round(_this2._curWidth * entity.x2Ratio - xc);
								var y2 = Math.round(_this2._curHeight * entity.y2Ratio - yc);
								_this2._drawLine(_this2._ctx, x, y, x2, y2, lineWidth);
								break;
						}
					});
				})();
			}
			// image preview
			this._drawPreview();
		};
<span id='$anonymizer-method-_setWhiteCanvas'>		/**
</span>   * Draw white canvas.
   * 
   * @private
   * @method _setWhiteCanvas
   * @member $anonymizer
   */
		$anonymizer.prototype._setWhiteCanvas = function _setWhiteCanvas() {
			this._ctx.clearRect(0, 0, this._canWidth, this._canHeight);
			this._drawFillRect(this._ctx, 0, 0, this._canWidth, this._canHeight, &quot;#fff&quot;);
		};
<span id='$anonymizer-method-_drawCircle'>		/**
</span>   * Draw a circle.
   * 
   * @param  {Canvas} ctx Canvas context
   * @param  {Number} x Center coordinates axe x
   * @param  {Number} y Center coordinates axe y
   * @param  {Number} radius Circle radius
   * @private
   * @method _drawCircle
   * @member $anonymizer
   */
		$anonymizer.prototype._drawCircle = function _drawCircle(ctx, x, y, radius) {
			ctx.beginPath();
			ctx.arc(x, y, radius, 0, 2 * Math.PI);
			ctx.fillStyle = $anonymizer.ENTITES.CIRCLE.fillStyle;
			ctx.closePath();
			ctx.fill();
		};
<span id='$anonymizer-method-_drawLine'>		/**
</span>   * Draw a line.
   * 
   * @param  {Canvas} ctx Canvas context
   * @param  {Number} x Line start coordinates axe x
   * @param  {Number} y Line start coordinates axe y
   * @param  {Number} x2 Line end coordinates axe x
   * @param  {Number} y2 Line end coordinates axe y
   * @param  {Number} lineWidth Line width [px]
   * @private
   * @method _drawLine
   * @member $anonymizer
   */
		$anonymizer.prototype._drawLine = function _drawLine(ctx, x, y, x2, y2, lineWidth) {
			ctx.beginPath();
			ctx.moveTo(x, y);
			ctx.lineTo(x2, y2);
			ctx.lineWidth = lineWidth;
			ctx.strokeStyle = $anonymizer.ENTITES.LINE.strokeStyle;
			ctx.closePath();
			ctx.stroke();
		};
<span id='$anonymizer-method-_drawFillRect'>		/**
</span>   * Draw a filled rectangle.
   * 
   * @param  {Canvas} ctx Canvas context
   * @param  {Number} x Start coordinates axe x
   * @param  {Number} y Start coordinates axe y
   * @param  {Number} width Rectangle width
   * @param  {Number} height Rectangle height
   * @param  {String} fillStyle Fill style
   * @private
   * @method _drawFillRect
   * @member $anonymizer
   */
		$anonymizer.prototype._drawFillRect = function _drawFillRect(ctx, x, y, width, height, fillStyle) {
			ctx.beginPath();
			ctx.fillStyle = fillStyle || &quot;&quot;;
			ctx.fillRect(x, y, width, height);
			ctx.closePath();
		};
<span id='$anonymizer-method-_drawRect'>		/**
</span>   * Draw a rectangle, only border.
   * 
   * @param  {Canvas} ctx Canvas context
   * @param  {Number} x Start coordinates axe x
   * @param  {Number} y Start coordinates axe y
   * @param  {Number} width Rectangle width
   * @param  {Number} height Rectangle height
   * @param  {String} strokeStyle Border style
   * @param  {Number} lineWidth Border width
   * @private
   * @method _drawRect
   * @member $anonymizer
   */
		$anonymizer.prototype._drawRect = function _drawRect(ctx, x, y, width, height, strokeStyle, lineWidth) {
			ctx.beginPath();
			ctx.rect(x, y, width, height);
			ctx.lineWidth = lineWidth || 1;
			ctx.strokeStyle = strokeStyle || &quot;&quot;;
			ctx.closePath();
			ctx.stroke();
		};
<span id='$anonymizer-method-_drawPreview'>		/**
</span>   * Draw a image preview.
   *
   * @private
   * @method _drawPreview
   * @member $anonymizer
   */
		$anonymizer.prototype._drawPreview = function _drawPreview() {
			if (!this._opts.showPreview) return;
			var ratio = this._imgWidth / this._imgHeight;
			var height = Math.round(this._opts.previewWidth / ratio);
			// background
			this._drawFillRect(this._ctx, this._opts.previewLeft - 1, this._opts.previewTop - 1, this._opts.previewWidth + 2, height + 2, &quot;rgba(255, 255, 255, 0.5)&quot;);
			// picture
			this._ctx.drawImage(this._img, 0, 0, this._img.width, this._img.height, this._opts.previewLeft, this._opts.previewTop, this._opts.previewWidth, height);
			// red border - current view
			var zc = this._zoom / 100;
			var xc = this._x * zc;
			var yc = this._y * zc;
			var xRatio = xc / this._curWidth;
			var yRatio = yc / this._curHeight;
			var x2Ratio = (xc + this._canWidth) / this._curWidth;
			var y2Ratio = (yc + this._canHeight) / this._curHeight;
			// restrictions
			xRatio = $math.setRange(xRatio, 0, 1);
			yRatio = $math.setRange(yRatio, 0, 1);
			x2Ratio = $math.setRange(x2Ratio, 0, 1);
			y2Ratio = $math.setRange(y2Ratio, 0, 1);
			var x1 = Math.round(this._opts.previewLeft + xRatio * this._opts.previewWidth);
			var y1 = Math.round(this._opts.previewTop + yRatio * height);
			var x2 = Math.round(this._opts.previewLeft + x2Ratio * this._opts.previewWidth);
			var y2 = Math.round(this._opts.previewTop + y2Ratio * height);
			// red border
			this._drawRect(this._ctx, x1, y1, x2 - x1, y2 - y1, &quot;#C01&quot;, 1);
		};
<span id='$anonymizer-method-_drawEntityPreview'>		/**
</span>   * Draw a entity preview for circle/line.
   *
   * @private
   * @method _drawEntityPreview
   * @member $anonymizer
   */
		$anonymizer.prototype._drawEntityPreview = function _drawEntityPreview() {
			if (!this._opts.entityPreview) return;
			var width = this._entityCanvas.width;
			var height = this._entityCanvas.height;
			this._entityCanvasCtx.clearRect(0, 0, width, height);
			this._drawFillRect(this._entityCanvasCtx, 0, 0, width, height, &quot;#f9f9f9&quot;);
			var curEnt = this._opts.curEntity;
			var zc = this._zoom / 100;
			switch (curEnt.id) {
				case $anonymizer.ENTITES.CIRCLE.id:
					var radius = Math.round(curEnt.value * zc);
					var x = Math.round(width / 2);
					var y = Math.round(height / 2);
					this._drawCircle(this._entityCanvasCtx, x, y, radius);
					break;
				case $anonymizer.ENTITES.LINE.id:
					var x1 = Math.round(width * 0.2);
					var y1 = Math.round(height / 2);
					var x2 = Math.round(width * 0.8);
					// y2 = y1
					var lineWidth = Math.round(curEnt.value * zc);
					this._drawLine(this._entityCanvasCtx, x1, y1, x2, y1, lineWidth);
					break;
			}
		};
<span id='$anonymizer-method-_getFromPoint'>		/**
</span>   * Get center point for zoom, otherwise is used point with mouse wheel and cursor position.
   *
   * @param {Number} [x] Coordinates on canvas axe x, otherwise is used center point on axe x
   * @param {Number} [y] Coordinates on canvas axe y, otherwise is used center point on axe y
   * @return {Object}
   * @private
   * @method _getFromPoint
   * @member $anonymizer
   */
		$anonymizer.prototype._getFromPoint = function _getFromPoint(x, y) {
			var fromPoint = {
				x: x || Math.round(this._canWidth / 2),
				y: y || Math.round(this._canHeight / 2)
			};
			var zc = this._zoom / 100;
			var newX = Math.round(this._x * zc) + fromPoint.x;
			var newY = Math.round(this._y * zc) + fromPoint.y;
			fromPoint.xRatio = newX / this._curWidth;
			fromPoint.yRatio = newY / this._curHeight;
			return fromPoint;
		};
<span id='$anonymizer-method-_postZoom'>		/**
</span>   * Post zoom operation - new image dimenstions, new move zoom step.
   * 
   * @private
   * @method _postZoom
   * @member $anonymizer
   */
		$anonymizer.prototype._postZoom = function _postZoom() {
			var zc = this._zoom / 100;
			this._curWidth = Math.round(this._img.width * zc);
			this._curHeight = Math.round(this._img.height * zc);
			if (this._zoom &lt; 100) {
				// function for zoom and mouse move
				this._zoomMoveStep = Math.max((100 - this._zoom) / 10 * this._opts.zoomMoveStep / 2, 1);
			}
		};
<span id='$anonymizer-method-_setCenter'>		/**
</span>   * Set image center on the canvas center.
   *
   * @private
   * @method _setCenter
   * @member $anonymizer
   */
		$anonymizer.prototype._setCenter = function _setCenter() {
			this._setPosition(0.5, 0.5);
		};
<span id='$anonymizer-method-_setPosition'>		/**
</span>   * Set image offset position.
   * 
   * @param {Number} xRatio &lt;0;1&gt; Point position on the image
   * @param {Number} yRatio &lt;0;1&gt; Point position on the image
   * @param {Number} [x] Screen offset, otherwise center [px], axe x
   * @param {Number} [y] Screen offset, otherwise center [px], axe y
   * @private
   * @method _setPosition
   * @member $anonymizer
   */
		$anonymizer.prototype._setPosition = function _setPosition(xRatio, yRatio, x, y) {
			x = x || this._canWidth / 2;
			y = y || this._canHeight / 2;
			xRatio = $math.setRange(xRatio, 0, 1);
			yRatio = $math.setRange(yRatio, 0, 1);
			var zc = this._zoom / 100;
			var xc = this._curWidth * xRatio - x;
			var yc = this._curHeight * yRatio - y;
			this._x = Math.max(Math.round(xc / zc), 0);
			this._y = Math.max(Math.round(yc / zc), 0);
		};
<span id='$anonymizer-method-_alignImgToCanvas'>		/**
</span>   * Align image to the canvas - left top corner and bottom right corner.
   *
   * @private
   * @method _alignImgToCanvas
   * @member $anonymizer
   */
		$anonymizer.prototype._alignImgToCanvas = function _alignImgToCanvas() {
			var maxX = Math.max(this._curWidth - this._canWidth, 0);
			var currX = Math.round(this._x * this._zoom / 100);
			if (this._x &lt; 0) {
				this._x = 0;
			} else if (currX &gt; maxX) {
				this._x = Math.round(maxX * 100 / this._zoom);
			}
			var maxY = Math.max(this._curHeight - this._canHeight, 0);
			var currY = Math.round(this._y * this._zoom / 100);
			if (this._y &lt; 0) {
				this._y = 0;
			} else if (currY &gt; maxY) {
				this._y = Math.round(maxY * 100 / this._zoom);
			}
		};
<span id='$anonymizer-method-_isRightClick'>		/**
</span>   * It event contains right mouse click?
   *
   * @param {Event} e Mouse event
   * @return {Boolean}
   * @private
   * @method _isRightClick
   * @member $anonymizer
   */
		$anonymizer.prototype._isRightClick = function _isRightClick(e) {
			if (e &amp;&amp; (e.which &amp;&amp; e.which == 3 || e.button &amp;&amp; e.button == 2)) {
				return true;
			} else {
				return false;
			}
		};
<span id='$anonymizer-method-_cancelEvents'>		/**
</span>   * Cancel events.
   * 
   * @param  {Event} e Mouse event
   * @private
   * @method _cancelEvents
   * @member $anonymizer
   */
		$anonymizer.prototype._cancelEvents = function _cancelEvents(e) {
			$common.cancelEvents(e);
		};
<span id='$anonymizer-method-_mouseWheel'>		/**
</span>   * Mouse wheel event.
   *
   * @param {Event} e Mouse event
   * @private
   * @method  _mouseWheel
   * @member $anonymizer
   */
		$anonymizer.prototype._mouseWheel = function _mouseWheel(e) {
			if (!this._imgWidth &amp;&amp; !this._imgHeight) return;
			var delta = e.wheelDelta || -e.detail;
			if (!delta) {
				return;
			}
			this._cancelEvents(e);
			this._setBCR();
			var data = this._getMouseXY(e);
			var fromPoint = this._getFromPoint(data.x, data.y);
			if (delta &gt; 0) {
				this._setZoom(this._zoom + this._zoomStep, fromPoint);
			} else {
				this._setZoom(this._zoom - this._zoomStep, fromPoint);
			}
		};
<span id='$anonymizer-method-_getMouseXY'>		/**
</span>   * Get mouse coordinates.
   * 
   * @param  {Event} e
   * @return {Object}
   * @private
   * @method _getMouseXY
   * @member $anonymizer
   */
		$anonymizer.prototype._getMouseXY = function _getMouseXY(e) {
			return {
				x: e.clientX - this._mouse.bcr.left,
				y: e.clientY - this._mouse.bcr.top
			};
		};
<span id='$anonymizer-method-_setCBR'>		/**
</span>   * Set mouse bounding client rect from canvas el.
   * 
   * @private
   * @method _setCBR
   * @member $anonymizer
   */
		$anonymizer.prototype._setBCR = function _setBCR() {
			this._mouse.bcr = this._canvas.getBoundingClientRect();
		};
<span id='$anonymizer-method-_mouseDown'>		/**
</span>   * Mouse down - create a circle, start of the line, start of move.
   *
   * @param {Event} e Mouse event
   * @private
   * @method _mouseDown
   * @member $anonymizer
   */
		$anonymizer.prototype._mouseDown = function _mouseDown(e) {
			if (!this._imgWidth &amp;&amp; !this._imgHeight) return;
			this._cancelEvents(e);
			this._setBCR();
			var data = this._getMouseXY(e);
			this._mouse.startXSave = data.x;
			this._mouse.startYSave = data.y;
			this._mouse.startX = this._mouse.startXSave;
			this._mouse.startY = this._mouse.startYSave;
			this._flags.wasMove = false;
			this._flags.wasRightClick = this._isRightClick(e);
			// circle
			if (this._opts.curEntity == $anonymizer.ENTITES.CIRCLE) {
				this._flags.wasImgMove = false;
				this._flags.wasPreview = false;
				document.addEventListener(&quot;mousemove&quot;, this._binds.mouseMove);
				document.addEventListener(&quot;mouseup&quot;, this._binds.mouseUp);
			}
			// line
			else if (this._opts.curEntity == $anonymizer.ENTITES.LINE) {
					// add canvas
					var lineCanvas = document.createElement(&quot;canvas&quot;);
					lineCanvas.width = this._canWidth;
					lineCanvas.height = this._canHeight;
					lineCanvas.classList.add(&quot;line-canvas&quot;);
					this._flags.wasPreview = false;
					this._flags.wasLine = false;
					this._lineCanvas = lineCanvas;
					this._lineCanvas.addEventListener(&quot;contextmenu&quot;, this._binds.contextMenu);
					document.addEventListener(&quot;mousemove&quot;, this._binds.mouseMoveLine);
					document.addEventListener(&quot;mouseup&quot;, this._binds.mouseUpLine);
					if (this._flags.wasRightClick) {
						this._lineCanvas.classList.add(&quot;is-dragged&quot;);
					}
					this._lineCanvasCtx = this._lineCanvas.getContext(&quot;2d&quot;);
					this._parent.appendChild(lineCanvas);
				}
		};
<span id='$anonymizer-method-_imgMove'>		/**
</span>   * Image move - according to the coordinates of the mouse.
   * 
   * @param  {Number} newX New value on the axe x
   * @param  {Number} newY New value on the axe y
   * @private
   * @method _imgMove
   * @member $anonymizer
   */
		$anonymizer.prototype._imgMove = function _imgMove(newX, newY) {
			var diffX = this._mouse.startX - newX;
			var diffY = this._mouse.startY - newY;
			if (diffX == 0 &amp;&amp; diffY == 0) {
				return;
			}
			// image movement constant
			var zms = this._zoomMoveStep &gt; 0 ? this._zoomMoveStep : 1;
			// move image to the new coordinates
			this._x = diffX * zms + this._x;
			this._y = diffY * zms + this._y;
			this._alignImgToCanvas();
			this._redraw();
		};
<span id='$anonymizer-method-_mouseMove'>		/**
</span>   * Mouse move over the canvas.
   *
   * @param {Event} e Mouse event
   * @private
   * @method _mouseMove
   * @member $anonymizer
   */
		$anonymizer.prototype._mouseMove = function _mouseMove(e) {
			var data = this._getMouseXY(e);
			// mouse cursor
			if (!this._flags.wasMove) {
				this._canvas.classList.add(&quot;is-dragged&quot;);
			}
			// mouse move flag
			this._flags.wasMove = true;
			// mouse move over the preview?
			var isPreview = this._isPreview(data.x, data.y);
			if (!this._flags.wasRightClick &amp;&amp; !this._flags.wasImgMove &amp;&amp; isPreview) {
				// set preview flag
				this._flags.wasPreview = true;
				// image move over the preview
				this._setPosition(isPreview.xRatio, isPreview.yRatio);
				this._alignImgToCanvas();
				this._redraw();
			} else if (!this._flags.wasPreview) {
				// image move - flag
				this._flags.wasImgMove = true;
				// image move
				this._imgMove(data.x, data.y);
			}
			// save
			this._mouse.startX = data.x;
			this._mouse.startY = data.y;
		};
<span id='$anonymizer-method-_isPreview'>		/**
</span>   * Is there a preview on coordinates x, y?
   * 
   * @param  {Number} x Click position on canvas, axe x
   * @param  {Number} y Click position on canvas, axe y
   * @return {Object} Object with percent ration or null
   * @private
   * @method _isPreview
   * @member $anonymizer
   */
		$anonymizer.prototype._isPreview = function _isPreview(x, y) {
			if (!this._opts.showPreview) return null;
			var ratio = this._imgWidth / this._imgHeight;
			// sirka a vyska nahledu
			var width = this._opts.previewWidth;
			var height = Math.round(this._opts.previewWidth / ratio);
			var left = this._opts.previewLeft;
			var top = this._opts.previewTop;
			var zc = this._zoom / 100;
			x = x || 0;
			y = y || 0;
			if (x &gt;= left &amp;&amp; x &lt;= left + width &amp;&amp; y &gt;= top &amp;&amp; y &lt;= top + height) {
				return {
					xRatio: (x - left) / width,
					yRatio: (y - top) / height
				};
			} else {
				return null;
			}
		};
<span id='$anonymizer-method-_mouseUp'>		/**
</span>   * Mouse up - draw a circle, end of move, preview click.
   *
   * @param {Event} e Mouse event
   * @private
   * @method _mouseUp
   * @member $anonymizer
   */
		$anonymizer.prototype._mouseUp = function _mouseUp(e) {
			var data = this._getMouseXY(e);
			var thresholdTest = false;
			// only it was move
			if (this._flags.wasMove) {
				// difference towards start click
				var diffX = this._mouse.startXSave - data.x;
				var diffY = this._mouse.startYSave - data.y;
				if (diffX &gt;= this._THRESHOLD.MIN &amp;&amp; diffX &lt;= this._THRESHOLD.MAX &amp;&amp; diffY &gt;= this._THRESHOLD.MIN &amp;&amp; diffY &lt;= this._THRESHOLD.MAX) {
					// we are in the range
					thresholdTest = true;
				}
			}
			// click - there was no move, threshold test, it is disabled for right mouse click
			if (!this._flags.wasRightClick &amp;&amp; (!this._flags.wasMove || thresholdTest)) {
				var isPreview = this._isPreview(data.x, data.y);
				if (isPreview) {
					// preview click - click coordinates on the canvas center
					this._setPosition(isPreview.xRatio, isPreview.yRatio);
					this._alignImgToCanvas();
					this._redraw();
				} else {
					// add circle
					var zc = this._zoom / 100;
					var x = Math.round(this._x * zc) + data.x;
					var y = Math.round(this._y * zc) + data.y;
					this._entites.push({
						id: this._opts.curEntity.id,
						value: this._opts.curEntity.value,
						xRatio: x / this._curWidth,
						yRatio: y / this._curHeight
					});
					this._redraw();
				}
			}
			this._canvas.classList.remove(&quot;is-dragged&quot;);
			document.removeEventListener(&quot;mousemove&quot;, this._binds.mouseMove);
			document.removeEventListener(&quot;mouseup&quot;, this._binds.mouseUp);
		};
<span id='$anonymizer-method-_mouseMoveLine'>		/**
</span>   * Mouse move over canvas - line draw.
   *
   * @param {Event} e Mouse event
   * @private
   * @method _mouseMoveLine
   * @member $anonymizer
   */
		$anonymizer.prototype._mouseMoveLine = function _mouseMoveLine(e) {
			var data = this._getMouseXY(e);
			// mouse move
			this._flags.wasMove = true;
			// right mouse click
			if (this._flags.wasRightClick) {
				// image move
				this._imgMove(data.x, data.y);
				// save
				this._mouse.startX = data.x;
				this._mouse.startY = data.y;
			}
			// left mouse click
			else {
					var isPreview = this._isPreview(data.x, data.y);
					var wasPreview = this._flags.wasPreview;
					if (!this._flags.wasLine &amp;&amp; isPreview) {
						this._flags.wasPreview = true;
						// move over preview
						this._setPosition(isPreview.xRatio, isPreview.yRatio);
						this._alignImgToCanvas();
						this._redraw();
					} else if (!this._flags.wasPreview) {
						this._flags.wasLine = true;
						// line width
						var lineWidth = Math.round(this._opts.curEntity.value * this._zoom / 100);
						// clear
						this._lineCanvasCtx.clearRect(0, 0, this._canWidth, this._canHeight);
						// draw a line
						this._drawLine(this._lineCanvasCtx, this._mouse.startX, this._mouse.startY, data.x, data.y, lineWidth);
					}
					// change of state
					if (!wasPreview &amp;&amp; this._flags.wasPreview) {
						this._lineCanvas.classList.add(&quot;is-dragged&quot;);
					}
				}
		};
<span id='$anonymizer-method-_mouseUpLine'>		/**
</span>   * End of move over canvas - create line, image move.
   * Draw a line in main canvas.
   *
   * @param {Event} e Mouse event
   * @private
   * @method _mouseUpLine
   * @member $anonymizer
   */
		$anonymizer.prototype._mouseUpLine = function _mouseUpLine(e) {
			var data = this._getMouseXY(e);
			var isPreview = null;
			if (!this._flags.wasMove) {
				isPreview = this._isPreview(data.x, data.y);
			}
			// only for left mouse click
			if (!this._flags.wasRightClick) {
				if (isPreview) {
					// preview click - click coordinates on the canvas center
					this._setPosition(isPreview.xRatio, isPreview.yRatio);
					this._alignImgToCanvas();
					this._redraw();
				} else if (this._flags.wasLine) {
					// create a line
					var zc = this._zoom / 100;
					var xc = Math.round(this._x * zc);
					var yc = Math.round(this._y * zc);
					var x = xc + this._mouse.startX;
					var y = yc + this._mouse.startY;
					var x2 = xc + data.x;
					var y2 = yc + data.y;
					this._entites.push({
						id: this._opts.curEntity.id,
						value: this._opts.curEntity.value,
						xRatio: x / this._curWidth,
						yRatio: y / this._curHeight,
						x2Ratio: x2 / this._curWidth,
						y2Ratio: y2 / this._curHeight
					});
					this._redraw();
				}
			}
			this._lineCanvas.classList.remove(&quot;is-dragged&quot;);
			this._lineCanvas.removeEventListener(&quot;contextmenu&quot;, this._binds.contextMenu);
			document.removeEventListener(&quot;mousemove&quot;, this._binds.mouseMoveLine);
			document.removeEventListener(&quot;mouseup&quot;, this._binds.mouseUpLine);
			this._parent.removeChild(this._lineCanvas);
			this._lineCanvas = null;
		};
<span id='$anonymizer-method-_setZoom'>		/**
</span>   * Set new value for zoom.
   * 
   * @param  {Number} value New value
   * @param  {Object} [fromPoint] Center of the screen or data from mouse wheel
   * @private
   * @method _setZoom
   * @member $anonymizer
   */
		$anonymizer.prototype._setZoom = function _setZoom(value, fromPoint) {
			fromPoint = fromPoint || this._getFromPoint();
			var oldZoom = this._zoom;
			var newZoom = $math.setRange(value, this._opts.minZoom, this._opts.maxZoom);
			if (newZoom == oldZoom) return;
			this._zoom = newZoom;
			this.trigger(&quot;zoom&quot;, this._zoom);
			this._postZoom();
			this._setPosition(fromPoint.xRatio, fromPoint.yRatio, fromPoint.x, fromPoint.y);
			this._alignImgToCanvas();
			this._drawEntityPreview();
			this._redraw();
		};
<span id='$anonymizer-method-loadImage'>		/**
</span>   * Load and show image in canvas. Returns promise after load.
   * 
   * @param  {String} url Path to image
   * @return {$promise} Promise
   * @method loadImage
   * @member $anonymizer
   */
		$anonymizer.prototype.loadImage = function loadImage(url) {
			var _this3 = this;
			return new $promise(function (resolve, reject) {
				_this3._setWhiteCanvas();
				_this3._spinner.classList.remove(&quot;hide&quot;);
				var img = new Image();
				img.addEventListener(&quot;load&quot;, function () {
					_this3._spinner.classList.add(&quot;hide&quot;);
					_this3._img = img;
					_this3._imgWidth = img.width;
					_this3._imgHeight = img.height;
					_this3._zoom = _this3._opts.zoom;
					_this3.trigger(&quot;zoom&quot;, _this3._zoom);
					_this3._postZoom();
					_this3._setCenter();
					_this3._alignImgToCanvas();
					_this3._drawEntityPreview();
					_this3._redraw();
					resolve();
				});
				img.addEventListener(&quot;error&quot;, function () {
					_this3._spinner.classList.add(&quot;hide&quot;);
					_this3._img = null;
					_this3._imgWidth = 0;
					_this3._imgHeight = 0;
					reject();
				});
				img.src = url || &quot;&quot;;
			});
		};
<span id='$anonymizer-method-zoomPlus'>		/**
</span>   * Increase zoom by one step, fires signal &quot;zoom&quot;.
   * 
   * @member $anonymizer
   * @method zoomPlus
   */
		$anonymizer.prototype.zoomPlus = function zoomPlus() {
			this._setZoom(this._zoom + this._zoomStep);
		};
<span id='$anonymizer-method-zoomMinus'>		/**
</span>   * Decrease zoom by one step, fires signal &quot;zoom&quot;.
   * 
   * @member $anonymizer
   * @method zoomMinus
   */
		$anonymizer.prototype.zoomMinus = function zoomMinus() {
			this._setZoom(this._zoom - this._zoomStep);
		};
<span id='$anonymizer-method-setZoom'>		/**
</span>   * Set new value for zoom.
   * 
   * @param  {Number} value New value
   * @member $anonymizer
   * @method setZoom
   */
		$anonymizer.prototype.setZoom = function setZoom(value) {
			this._setZoom(value);
		};
<span id='$anonymizer-method-getEntityId'>		/**
</span>   * Get current draw entity ID.
   * 
   * @return {String}
   * @member $anonymizer
   * @method getEntityId
   */
		$anonymizer.prototype.getEntityId = function getEntityId() {
			return this._opts.curEntity.id;
		};
<span id='$anonymizer-method-switchEntity'>		/**
</span>   * Switch to other entity, uses priority.
   *
   * @member $anonymizer
   * @method switchEntity
   */
		$anonymizer.prototype.switchEntity = function switchEntity() {
			var _this4 = this;
			var variants = Object.keys($anonymizer.ENTITES);
			var priority = this._opts.curEntity.priority;
			var selVariant = null;
			var lowestVariant = null;
			variants.forEach(function (variant) {
				var varObj = $anonymizer.ENTITES[variant];
				if (!selVariant &amp;&amp; varObj.priority &gt; _this4._opts.curEntity.priority) {
					selVariant = varObj;
				}
				if (!lowestVariant || varObj.priority &lt; lowestVariant.priority) {
					lowestVariant = varObj;
				}
			});
			if (!selVariant) {
				selVariant = lowestVariant;
			}
			this._opts.curEntity = selVariant;
			this._drawEntityPreview();
		};
<span id='$anonymizer-method-getEntity'>		/**
</span>   * Get current entity object.
   * 
   * @return {Object}
   * @member $anonymizer
   * @method getEntity
   */
		$anonymizer.prototype.getEntity = function getEntity() {
			return this._opts.curEntity;
		};
<span id='$anonymizer-method-setEntityValue'>		/**
</span>   * Set value for current entity.
   * 
   * @param {Number} val New value
   * @return {Boolean} If there was an error -&gt; it returns false
   * @member $anonymizer
   * @method setEntityValue
   */
		$anonymizer.prototype.setEntityValue = function setEntityValue(val) {
			val = val || 0;
			if (val &gt;= this._opts.curEntity.min &amp;&amp; val &lt;= this._opts.curEntity.max) {
				this._opts.curEntity.value = val;
				this._drawEntityPreview();
				return true;
			} else {
				return false;
			}
		};
<span id='$anonymizer-method-setCircleEntity'>		/**
</span>   * Set circle as a selected entity.
   *
   * @member $anonymizer
   * @method setCircleEntity
   */
		$anonymizer.prototype.setCircleEntity = function setCircleEntity() {
			this._opts.curEntity = $anonymizer.ENTITES.CIRCLE;
			this._drawEntityPreview();
		};
<span id='$anonymizer-method-setLineEntity'>		/**
</span>   * Set line as a selected entity.
   *
   * @member $anonymizer
   * @method setLineEntity
   */
		$anonymizer.prototype.setLineEntity = function setLineEntity() {
			this._opts.curEntity = $anonymizer.ENTITES.LINE;
			this._drawEntityPreview();
		};
<span id='$anonymizer-method-stepBack'>		/**
</span>   * Take last entity and redraw a scene.
   * 
   * @member $anonymizer
   * @method stepBack
   */
		$anonymizer.prototype.stepBack = function stepBack() {
			if (!this._imgWidth &amp;&amp; !this._imgHeight) return;
			this._entites.pop();
			this._redraw();
		};
<span id='$anonymizer-method-removeAll'>		/**
</span>   * Remove all entites and redraw a scene.
   * 
   * @member $anonymizer
   * @method removeAll
   */
		$anonymizer.prototype.removeAll = function removeAll() {
			if (!this._imgWidth &amp;&amp; !this._imgHeight) return;
			this._entites = [];
			this._redraw();
		};
<span id='$anonymizer-method-exportEntites'>		/**
</span>   * Export all entites on the screen and count them towards original image size.
   * 
   * @return {Object}
   * @member $anonymizer
   * @method exportEntites
   */
		$anonymizer.prototype.exportEntites = function exportEntites() {
			var _this5 = this;
			var output = {
				actions: [],
				image: {
					width: this._imgWidth,
					height: this._imgHeight
				}
			};
			this._entites.forEach(function (entity) {
				switch (entity.id) {
					case $anonymizer.ENTITES.CIRCLE.id:
						output.actions.push({
							type: entity.id.toLowerCase(),
							x: $math.setRange(Math.round(_this5._imgWidth * entity.xRatio), 0, _this5._imgWidth),
							y: $math.setRange(Math.round(_this5._imgHeight * entity.yRatio), 0, _this5._imgHeight),
							r: entity.value
						});
						break;
					case $anonymizer.ENTITES.LINE.id:
						output.actions.push({
							type: entity.id.toLowerCase(),
							x1: $math.setRange(Math.round(_this5._imgWidth * entity.xRatio), 0, _this5._imgWidth),
							y1: $math.setRange(Math.round(_this5._imgHeight * entity.yRatio), 0, _this5._imgHeight),
							x2: $math.setRange(Math.round(_this5._imgWidth * entity.x2Ratio), 0, _this5._imgWidth),
							y2: $math.setRange(Math.round(_this5._imgHeight * entity.y2Ratio), 0, _this5._imgHeight),
							width: entity.value
						});
						break;
				}
			});
			return output;
		};
<span id='$anonymizer-method-syncPort'>		/**
</span>   * Resize canvas with new width and height.
   * 
   * @param  {Number} [width] New width in [px]
   * @param  {Number} [height] New height in [px]
   * @member $anonymizer
   * @method syncPort
   */
		$anonymizer.prototype.syncPort = function syncPort(width, height) {
			width = width || this._parent.offsetWidth;
			height = height || this._parent.offsetHeight;
			this._canWidth = width;
			this._canHeight = height;
			this._canvas.width = width;
			this._canvas.height = height;
			if (this._img) {
				this._postZoom();
				this._setCenter();
				this._alignImgToCanvas();
				this._drawEntityPreview();
				this._redraw();
			}
		};
		return $anonymizer;
	}($event);
	;
<span id='$anonymizer-static-property-ENTITES'>	/**
</span>  * List of entites.
  * 
  * @type {Object}
  * @param {Object} CIRCLE Circle entity
  * @param {Object} LINE Line entity
  * @member $anonymizer
  * @static
  */
	$anonymizer.ENTITES = {
		CIRCLE: {
			min: 10,
			value: 50,
			max: 100,
			id: &quot;CIRCLE&quot;,
			fillStyle: &quot;rgba(0, 0, 255, 0.5)&quot;,
			priority: 1
		},
		LINE: {
			min: 10,
			value: 20,
			max: 100,
			id: &quot;LINE&quot;,
			strokeStyle: &quot;rgba(0, 255, 0, 0.5)&quot;,
			priority: 2
		}
	};
	return $anonymizer;
}]);
function _classCallCheck(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError(&quot;Cannot call a class as a function&quot;);
	}
}
onix.factory(&quot;$loader&quot;, [&quot;$dom&quot;, function ($dom) {
<span id='$loader'>	/**
</span>  * Progress loader in the application.
  * 
  * @class $loader
  */
	var $loader = function () {
		function $loader() {
			_classCallCheck(this, $loader);
			// loader init
			this._create();
		}
<span id='$loader-method-_create'>		/**
</span>   * Create loader.
   *
   * @private
   * @member $loader
   * @method _create
   */
		$loader.prototype._create = function _create() {
			this._el = $dom.create({
				el: &quot;div&quot;,
				&quot;class&quot;: &quot;loader&quot;
			});
			// insert into the body on first position
			document.body.insertBefore(this._el, document.body.firstChild);
		};
<span id='$loader-method-start'>		/**
</span>   * Start loader.
   *
   * @member $loader
   * @method start
   */
		$loader.prototype.start = function start() {
			this._el.classList.add(&quot;start&quot;);
		};
<span id='$loader-method-end'>		/**
</span>   * End loader.
   *
   * @member $loader
   * @method end
   */
		$loader.prototype.end = function end() {
			var _this = this;
			this._el.classList.remove(&quot;start&quot;);
			this._el.classList.add(&quot;end&quot;);
			setTimeout(function () {
				_this._el.classList.remove(&quot;end&quot;);
				_this._el.classList.add(&quot;hide&quot;);
				setTimeout(function () {
					_this._el.classList.remove(&quot;hide&quot;);
				}, 350);
			}, 150);
		};
<span id='$loader-method-getSpinner'>		/**
</span>   * Get spinner - DOM or object.
   *
   * @param {Boolean} [getObject] True for object DOM configuration for $dom; default HTML node
   * @return {HTMLElement|Object}
   * @member $loader
   * @method getSpinner
   */
		$loader.prototype.getSpinner = function getSpinner(getObject) {
			var children = [];
			for (var i = 1; i &lt; 6; i++) {
				children.push({
					el: &quot;div&quot;,
					&quot;class&quot;: &quot;rect&quot; + i
				});
			}
			var domConf = {
				el: &quot;div&quot;,
				&quot;class&quot;: &quot;spinner&quot;,
				child: children
			};
			return getObject ? domConf : $dom.create(domConf);
		};
		return $loader;
	}();
	;
	return new $loader();
}]);
function _classCallCheck(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError(&quot;Cannot call a class as a function&quot;);
	}
}
onix.service(&quot;$notify&quot;, [&quot;$common&quot;, &quot;$promise&quot;, function ($common, $promise) {
<span id='$notify'>	/**
</span>  * $notify uses bootstrap alerts and provides additional functionality.
  * Create notification object from the element.
  *
  * @param {HTMLElement} el
  * @class $notify
  */
	var $notify = function () {
		function $notify(el) {
			_classCallCheck(this, $notify);
			this._el = el;
			this._HIDE_TIMEOUT = 1500; // [ms]
			this._options = {
				&quot;ok&quot;: &quot;alert-success&quot;,
				&quot;error&quot;: &quot;alert-danger&quot;,
				&quot;info&quot;: &quot;alert-info&quot;,
				&quot;warn&quot;: &quot;alert-warning&quot;
			};
			return this;
		}
<span id='$notify-method-_setValue'>		/**
</span>   * Set value to the notify element.
   *
   * @param  {String|HTMLElement} txt
   * @member $notify
   * @method _setValue
   * @private
   */
		$notify.prototype._setValue = function _setValue(txt) {
			if ($common.isElement(txt)) {
				onix.element(this._el).empty().append(txt);
			} else if (typeof txt === &quot;string&quot;) {
				this._el.innerHTML = txt;
			}
		};
<span id='$notify-method-reset'>		/**
</span>   * Reset CSS classes.
   *
   * @method reset
   * @member $notify
   */
		$notify.prototype.reset = function reset() {
			var _this = this;
			Object.keys(this._options).forEach(function (key) {
				_this._el.classList.remove(_this._options[key]);
			});
			return this;
		};
<span id='$notify-method-ok'>		/**
</span>   * Show OK state.
   * 
   * @param  {String|HTMLElement} txt
   * @method ok
   * @member $notify
   */
		$notify.prototype.ok = function ok(txt) {
			this._el.classList.add(this._options.ok);
			this._setValue(txt);
			return this;
		};
<span id='$notify-method-error'>		/**
</span>   * Show ERROR state.
   * 
   * @param  {String|HTMLElement} txt
   * @method error
   * @member $notify
   */
		$notify.prototype.error = function error(txt) {
			this._el.classList.add(this._options.error);
			this._setValue(txt);
			return this;
		};
<span id='$notify-method-info'>		/**
</span>   * Show INFO state.
   *
   * @param  {String|HTMLElement} txt
   * @method info
   * @member $notify
   */
		$notify.prototype.info = function info(txt) {
			this._el.classList.add(this._options.info);
			this._setValue(txt);
			return this;
		};
<span id='$notify-method-warn'>		/**
</span>   * Show WARNING state.
   *
   * @param  {String|HTMLElement} txt
   * @method warn
   * @member $notify
   */
		$notify.prototype.warn = function warn(txt) {
			this._el.classList.add(this._options.warn);
			this._setValue(txt);
			return this;
		};
<span id='$notify-method-hide'>		/**
</span>   * Hide alert after timeout and returns promise at the end of operation.
   * Default timeout is 1500 ms.
   *
   * @param {Number} [timeout] Hide timeout in [ms]
   * @return {$promise}
   * @method hide
   * @member $notify
   */
		$notify.prototype.hide = function hide(timeout) {
			var _this2 = this;
			return new $promise(function (resolve) {
				setTimeout(function () {
					_this2.reset();
					resolve();
				}, timeout || _this2._HIDE_TIMEOUT);
			});
		};
		return $notify;
	}();
	;
<span id='$notify-method-get'>	/**
</span>  * Main public access to the notify obj.
  *
  * @param  {HTMLElement} el
  * @return {$notify}
  * @member $notify
  */
	this.get = function (el) {
		return new $notify(el);
	};
}]);
<span id='$previewImages'>/**
</span> * Class for creating img previews from File[] variable.
 * 
 * @class $previewImages
 */
onix.service(&quot;$previewImages&quot;, [&quot;$image&quot;, &quot;$dom&quot;, &quot;$job&quot;, &quot;$loader&quot;, function ($image, $dom, $job, $loader) {
<span id='$previewImages-method-_createPreview'>	/**
</span>  * Create one image preview.
  *
  * @private
  * @param  {File} file
  * @param  {Number} [maxSize] Max image size
  * @return {Object} dom references
  * @member $previewImages
  */
	this._createPreview = function (file, maxSize) {
		var exported = {};
		var cont = $dom.create({
			el: &quot;span&quot;,
			&quot;class&quot;: [&quot;preview-item&quot;, &quot;preview-loading&quot;],
			child: [{
				el: &quot;span&quot;,
				&quot;class&quot;: &quot;canvas-cover&quot;,
				child: [$loader.getSpinner(true)],
				style: &quot;height: &quot; + (maxSize || 100) + &quot;px&quot;,
				_exported: &quot;canvasCover&quot;
			}, {
				el: &quot;span&quot;,
				&quot;class&quot;: &quot;title&quot;,
				innerHTML: file.name.replace(/\..*/g, &quot;&quot;)
			}]
		}, exported);
		return {
			cont: cont,
			canvasCover: exported.canvasCover
		};
	};
<span id='$previewImages-method-_createPreviewHolders'>	/**
</span>  * Create preview holders. Only for images count 4 and 7.
  * Four images are in the one row, seven images has the last one above them.
  *
  * @private
  * @param {HTMLElement} el
  * @param {Number} count
  * @member $previewImages
  */
	this._createPreviewHolders = function (el, count) {
		if (!el || count != 4 &amp;&amp; count != 7) return;
		var exported = {};
		// placeholder for 7 images
		if (count == 7) {
			// ceiling line
			el.appendChild($dom.create({
				el: &quot;div&quot;,
				child: [{
					el: &quot;span&quot;,
					_exported: &quot;img_06&quot;
				}]
			}, exported));
		}
		var child = [];
		var childCount = count == 7 ? 6 : 4;
		for (var i = 0; i &lt; childCount; i++) {
			child.push({
				el: &quot;span&quot;,
				_exported: &quot;img_0&quot; + i
			});
		}
		// rest line
		el.appendChild($dom.create({
			el: &quot;div&quot;,
			child: child
		}, exported));
		for (var _i = 0; _i &lt; count; _i++) {
			this._dom[&quot;img_0&quot; + _i] = exported[&quot;img_0&quot; + _i];
		}
	};
<span id='$previewImages-method-_jobTask'>	/**
</span>  * One job task
  *
  * @private
  * @param  {Object} previewObj Object with file and preview ID
  * @param  {Number} maxSize Max image size in px
  * @param  {Function} jobDone Function which indicates that job is done
  * @member $previewImages
  */
	this._jobTask = function (previewObj, maxSize, jobDone) {
		var file = previewObj.file;
		var previewID = previewObj.previewID;
		var preview = this._createPreview(file, maxSize);
		// append
		if (previewID in this._dom) {
			this._dom[previewID].appendChild(preview.cont);
		} else {
			this._dom.previewItems.appendChild(preview.cont);
		}
		$image.readFromFile(file, maxSize).then(function (readFileObj) {
			preview.cont.classList.remove(&quot;preview-loading&quot;);
			preview.canvasCover.innerHTML = &quot;&quot;;
			preview.canvasCover.appendChild(readFileObj.canvas);
			jobDone();
		});
	};
<span id='$previewImages-method-show'>	/**
</span>  * Main function for showing img previews.
  * 
  * @param  {HTMLElement} el Placeholder element
  * @param  {File[]} files
  * @param  {Object} [opts] Configuration
  * @param  {Number} [opts.maxSize = 0] Max image size in px; the size is used for image scale
  * @param  {Number} [opts.count = 0] How many images are processed simultinously
  * @param  {Boolean} [opts.createHolder = false] Create placeholder, see _createPreviewHolders function
  * @member $previewImages
  */
	this.show = function (el, files, optsArg) {
		var _this = this;
		// clear previous
		el.innerHTML = &quot;&quot;;
		// add class
		el.classList.add(&quot;preview-images&quot;);
		var opts = {
			maxSize: 0,
			count: 0,
			createHolder: false
		};
		for (var key in optsArg) {
			opts[key] = optsArg[key];
		}
		this._dom = {
			previewItems: el
		};
		var pictureFiles = $image.getPictureFiles(files);
		var count = pictureFiles.length;
		if (count) {
			(function () {
				// create placeholder?
				if (opts.createHolder) {
					_this._createPreviewHolders(el, count);
				}
				var jobsArray = [];
				// sort by name, make previewID - only for 7 pictures
				pictureFiles = pictureFiles.sort(function (a, b) {
					if (a.name &lt; b.name) return -1;else if (a.name &gt; b.name) return 1;else return 0;
				}).forEach(function (pf, ind) {
					jobsArray.push({
						task: _this._jobTask,
						scope: _this,
						args: [{
							file: pf,
							previewID: &quot;img_0&quot; + ind
						}, opts.maxSize]
					});
				});
				// run jobs array
				$job.multipleJobs(jobsArray, opts.count);
			})();
		}
	};
}]);
function _classCallCheck(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError(&quot;Cannot call a class as a function&quot;);
	}
}
function _possibleConstructorReturn(self, call) {
	if (!self) {
		throw new ReferenceError(&quot;this hasn&#39;t been initialised - super() hasn&#39;t been called&quot;);
	}return call &amp;&amp; ((typeof call === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(call)) === &quot;object&quot; || typeof call === &quot;function&quot;) ? call : self;
}
function _inherits(subClass, superClass) {
	if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) {
		throw new TypeError(&quot;Super expression must either be null or a function, not &quot; + (typeof superClass === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(superClass)));
	}subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
onix.factory(&quot;$select&quot;, [&quot;$common&quot;, &quot;$event&quot;, &quot;$dom&quot;, function ($common, $event, $dom) {
<span id='$select'>	/**
</span>  * $select uses bootstrap dropdown and provides additional functionality.
  *
  * @class $select
  * @param {HTMLElement} el Where element has class &quot;dropdown&quot;
  * @param {Object} [opts]
  * @param {Boolean} [opts.addCaption = false] Add caption to select
  */
	var $select = function (_$event) {
		_inherits($select, _$event);
		function $select(el, opts) {
			_classCallCheck(this, $select);
			// event init
			var _this = _possibleConstructorReturn(this, _$event.call(this));
			_this._eventInit();
			_this._opts = {
				addCaption: false
			};
			for (var key in opts) {
				_this._opts[key] = opts[key];
			}
			_this._CONST = {
				CAPTION_SEL: &quot;.dropdown-toggle&quot;,
				OPTIONS_SEL: &quot;.dropdown-menu a&quot;,
				CARET_SEL: &quot;.caret&quot;,
				OPEN_DROPDOWN_SEL: &quot;.dropdown.open&quot;,
				OPEN_CLASS: &quot;open&quot;,
				ACTIVE_CLASS: &quot;active&quot;
			};
			_this._el = el;
			_this._optinsRef = [];
			_this._captionEl = null;
			_this.captionTextEl = null;
			_this._binds = {
				captionClick: _this._captionClick.bind(_this),
				choiceClick: _this._choiceClick.bind(_this),
				removeAllOpened: _this._removeAllOpened.bind(_this),
				click: _this._click.bind(_this)
			};
			_this._bind();
			return _this;
		}
<span id='$select-method-_bind'>		/**
</span>   * Bind clicks on the select.
   *
   * @member $select
   * @private
   * @method _bind
   */
		$select.prototype._bind = function _bind() {
			this._bindCaption();
			this._bindChoices();
		};
<span id='$select-method-_bindCaption'>		/**
</span>   * Bind caption el.
   * 
   * @member $select
   * @private
   * @method _bindCaption
   */
		$select.prototype._bindCaption = function _bindCaption() {
			var captionEl = this._el.querySelector(this._CONST.CAPTION_SEL);
			if (captionEl) {
				// click on the caption
				captionEl.addEventListener(&quot;click&quot;, this._binds.captionClick);
				// insert span placeholder for caption
				if (this._opts.addCaption) {
					var caretEl = captionEl.querySelector(this._CONST.CARET_SEL);
					if (caretEl) {
						var captionTextEl = $dom.create({
							el: &quot;span&quot;,
							&quot;class&quot;: &quot;add-caption&quot;
						});
						captionEl.insertBefore(captionTextEl, caretEl);
						this._captionTextEl = captionTextEl;
					}
				}
			}
			this._captionEl = captionEl;
		};
<span id='$select-method-_removeAllOpened'>		/**
</span>   * Remove all opened selectors -&gt; close all.
   *
   * @member $select
   * @private
   * @method _removeAllOpened
   */
		$select.prototype._removeAllOpened = function _removeAllOpened() {
			var _this2 = this;
			// remove all
			onix.element(this._CONST.OPEN_DROPDOWN_SEL).forEach(function (item) {
				item.classList.remove(_this2._CONST.OPEN_CLASS);
			});
		};
<span id='$select-method-_click'>		/**
</span>   * Outside click.
   * 
   * @member $select
   * @private
   * @method _click
   */
		$select.prototype._click = function _click() {
			this._removeAllOpened();
			document.removeEventListener(&quot;click&quot;, this._binds.click);
		};
<span id='$select-method-_captionClick'>		/**
</span>   * Event - click on caption.
   * 
   * @param  {Event} e 
   * @member $select
   * @private
   * @method _captionClick
   */
		$select.prototype._captionClick = function _captionClick(e) {
			e.stopPropagation();
			var isOpen = this._el.classList.contains(this._CONST.OPEN_CLASS);
			this._binds.removeAllOpened();
			if (isOpen) {
				// outside click
				document.removeEventListener(&quot;click&quot;, this._binds.click);
			} else {
				// outside click
				document.addEventListener(&quot;click&quot;, this._binds.click);
				this._el.classList.add(this._CONST.OPEN_CLASS);
			}
		};
<span id='$select-method-_bindChoices'>		/**
</span>   * Bind choices inside select.
   *
   * @member $select
   * @private
   * @method _bindChoices
   */
		$select.prototype._bindChoices = function _bindChoices() {
			var _this3 = this;
			onix.element(this._CONST.OPTIONS_SEL, this._el).forEach(function (option) {
				option.addEventListener(&quot;click&quot;, _this3._binds.choiceClick);
				// event ref
				_this3._optinsRef.push({
					el: option,
					event: &quot;click&quot;,
					fn: _this3._binds.choiceClick
				});
			});
		};
<span id='$select-method-_choiceClick'>		/**
</span>   * Event - click on option.
   * 
   * @param  {Event} e 
   * @member $select
   * @private
   * @method _choiceClick
   */
		$select.prototype._choiceClick = function _choiceClick(e) {
			e.stopPropagation();
			var el = e.target || e.srcElement;
			if (el &amp;&amp; !el.parentNode.classList.contains(this._CONST.ACTIVE_CLASS)) {
				// remove previously selected
				var active = el.parentNode.parentNode.querySelector(&quot;.&quot; + this._CONST.ACTIVE_CLASS);
				if (active) {
					active.classList.remove(this._CONST.ACTIVE_CLASS);
				}
				// add to the current
				el.parentNode.classList.add(this._CONST.ACTIVE_CLASS);
				this._el.classList.remove(this._CONST.OPEN_CLASS);
				if (this._opts.addCaption &amp;&amp; this._captionTextEl) {
					this._captionTextEl.innerHTML = el.innerHTML;
				}
				// trigger click
				var value = el.getAttribute(&quot;data-value&quot;) || &quot;&quot;;
				this.trigger(&quot;change&quot;, value);
			}
		};
<span id='$select-method-unbindChoices'>		/**
</span>   * Unbind choices.
   *
   * @member $select
   * @method unbindChoices
   */
		$select.prototype.unbindChoices = function unbindChoices() {
			if (this._optinsRef.length) {
				this._optinsRef.forEach(function (option) {
					option.el.removeEventListener(option.event, option.fn);
				});
				this._optinsRef = [];
			}
		};
<span id='$select-method-rebindChoices'>		/**
</span>   * Rebind choices.
   *
   * @member $select
   * @method rebindChoices
   */
		$select.prototype.rebindChoices = function rebindChoices() {
			this.unbindChoices();
			this._bindChoices();
		};
<span id='$select-method-selectOption'>		/**
</span>   * Select option from the select.
   * 
   * @param {Number} ind Position 0..n
   * @member $select
   * @method selectOption
   */
		$select.prototype.selectOption = function selectOption(ind) {
			ind = ind || 0;
			var optionsCount = this._optinsRef.length;
			if (optionsCount &gt; 0 &amp;&amp; ind &gt;= 0 &amp;&amp; ind &lt; optionsCount) {
				var el = this._optinsRef[ind].el;
				var parent = this._optinsRef[ind].el.parentNode;
				if (!parent.classList.contains(this._CONST.ACTIVE_CLASS)) {
					parent.classList.add(this._CONST.ACTIVE_CLASS);
					if (this._opts.addCaption &amp;&amp; this._captionTextEl) {
						this._captionTextEl.innerHTML = el.innerHTML;
					}
					// trigger click
					var value = el.getAttribute(&quot;data-value&quot;) || &quot;&quot;;
					this.trigger(&quot;change&quot;, value);
				}
			}
		};
<span id='$select-method-setAddCaption'>		/**
</span>   * Set add caption from the current value.
   *
   * @member $select
   * @method setAddCaption
   */
		$select.prototype.setAddCaption = function setAddCaption() {
			var _this4 = this;
			if (!this._opts.addCaption) return;
			this._optinsRef.every(function (item) {
				var parent = item.el.parentNode;
				if (parent.classList.contains(_this4._CONST.ACTIVE_CLASS)) {
					_this4._captionTextEl.innerHTML = item.el.innerHTML;
					return false;
				} else {
					return true;
				}
			});
		};
		return $select;
	}($event);
	;
	return $select;
}]);
function _classCallCheck(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError(&quot;Cannot call a class as a function&quot;);
	}
}
function _possibleConstructorReturn(self, call) {
	if (!self) {
		throw new ReferenceError(&quot;this hasn&#39;t been initialised - super() hasn&#39;t been called&quot;);
	}return call &amp;&amp; ((typeof call === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(call)) === &quot;object&quot; || typeof call === &quot;function&quot;) ? call : self;
}
function _inherits(subClass, superClass) {
	if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) {
		throw new TypeError(&quot;Super expression must either be null or a function, not &quot; + (typeof superClass === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof2(superClass)));
	}subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
onix.factory(&quot;$slider&quot;, [&quot;$dom&quot;, &quot;$event&quot;, &quot;$common&quot;, &quot;$math&quot;, function ($dom, $event, $common, $math) {
<span id='$slider'>	/**
</span>  * Slider - slider with input for selecting numbers from the range.
  * 
  * @param {HTMLElement} parent Where is canvas appended
  * @param {Object} [optsArg] Configuration
  * @param {Number} [optsArg.min=0] Min value
  * @param {Number} [optsArg.max=100] Max value
  * @param {Number} [optsArg.wheelStep=1] Mouse wheel step value
  * @param {Number} [optsArg.timeout=333] Timeout for signal fire (keydown, move)
  * @class $slider
  */
	var $slider = function (_$event) {
		_inherits($slider, _$event);
		function $slider(parent, optsArg) {
			_classCallCheck(this, $slider);
			// event init
			var _this = _possibleConstructorReturn(this, _$event.call(this));
			_this._eventInit();
			_this._parent = parent;
			_this._root = _this._create();
			_this._opts = {
				min: 0,
				max: 100,
				wheelStep: 1,
				timeout: 333
			};
			for (var key in optsArg) {
				_this._opts[key] = optsArg[key];
			}
			// selected value
			_this._value = null;
			// signal change - helper
			_this._signalObj = {
				id: null,
				lastValue: null
			};
			parent.appendChild(_this._root);
			_this._binds = {
				keyUp: _this._keyUp.bind(_this),
				click: _this._click.bind(_this),
				mouseDownCaret: _this._mouseDownCaret.bind(_this),
				mouseMove: _this._mouseMove.bind(_this),
				mouseWheel: _this._mouseWheel.bind(_this),
				mouseUp: _this._mouseUp.bind(_this),
				sendSignalInner: _this._sendSignalInner.bind(_this)
			};
			_this._mouse = {
				bcr: null
			};
			_this._els.input.addEventListener(&quot;keyup&quot;, _this._binds.keyUp);
			_this._els.tube.addEventListener(&quot;click&quot;, _this._binds.click);
			_this._els.caret.addEventListener(&quot;mousedown&quot;, _this._binds.mouseDownCaret);
			// firefox
			_this._els.lineHolder.addEventListener(&quot;DOMMouseScroll&quot;, _this._binds.mouseWheel);
			// others
			_this._els.lineHolder.addEventListener(&quot;mousewheel&quot;, _this._binds.mouseWheel);
			// def. max value
			_this.setValue(_this._opts.max);
			return _this;
		}
<span id='$slider-method-_create'>		/**
</span>   * Create slider and his children.
   *
   * @member $slider
   * @private
   * @method _create
   */
		$slider.prototype._create = function _create() {
			this._els = {};
			return $dom.create({
				el: &quot;div&quot;,
				&quot;class&quot;: &quot;slider&quot;,
				child: [{
					el: &quot;input&quot;,
					type: &quot;text&quot;,
					value: &quot;&quot;,
					_exported: &quot;input&quot;
				}, {
					el: &quot;span&quot;,
					&quot;class&quot;: &quot;line-holder&quot;,
					_exported: &quot;lineHolder&quot;,
					child: [{
						el: &quot;span&quot;,
						&quot;class&quot;: &quot;lh-tube&quot;,
						_exported: &quot;tube&quot;
					}, {
						el: &quot;span&quot;,
						&quot;class&quot;: &quot;lh-caret&quot;,
						_exported: &quot;caret&quot;
					}]
				}]
			}, this._els);
		};
<span id='$slider-method-_setCaret'>		/**
</span>   * Set caret position.
   * 
   * @param {Number} posX Value [px] caret offset accord to the start
   * @member $slider
   * @private
   * @method _setCaret
   */
		$slider.prototype._setCaret = function _setCaret(posX) {
			var width = this._els.lineHolder.offsetWidth;
			if (posX &lt; 0) {
				posX = 0;
			} else if (posX &gt; width) {
				posX = width;
			}
			this._els.caret.style.left = posX.toFixed(2) + &quot;px&quot;;
		};
<span id='$slider-method-_getMouseXY'>		/**
</span>   * Get mouse coordinates.
   * 
   * @param  {Event} e
   * @return {Object}
   * @private
   * @member $slider
   * @method _getMouseXY
   */
		$slider.prototype._getMouseXY = function _getMouseXY(e) {
			return {
				x: e.clientX - this._mouse.bcr.left,
				y: e.clientY - this._mouse.bcr.top
			};
		};
<span id='$slider-method-_setBCR'>		/**
</span>   * Set mouse bounding client rect from canvas el.
   * 
   * @private
   * @member $slider
   * @method _setBCR
   */
		$slider.prototype._setBCR = function _setBCR() {
			this._mouse.bcr = this._els.lineHolder.getBoundingClientRect();
		};
<span id='$slider-method-_keyUp'>		/**
</span>   * Key up event from the input.
   *
   * @member $slider
   * @private
   * @method _keyUp
   */
		$slider.prototype._keyUp = function _keyUp() {
			var inputEl = this._els.input;
			var value = parseFloat(inputEl.value);
			var errors = false;
			if (isNaN(value) || value &lt; this._opts.min || value &gt; this._opts.max) {
				errors = true;
			} else {
				// set new value
				this.setValue(value);
				this._sendSignal(true);
			}
			inputEl.classList[errors ? &quot;add&quot; : &quot;remove&quot;](&quot;error&quot;);
		};
<span id='$slider-method-_click'>		/**
</span>   * Click on tube event.
   *
   * @param {Event} e
   * @member $slider
   * @private
   * @method _click
   */
		$slider.prototype._click = function _click(e) {
			$common.cancelEvents(e);
			this._setBCR();
			var width = this._els.lineHolder.offsetWidth;
			var value = this._getMouseXY(e).x;
			var ratio = value / width;
			// increate click range
			if (ratio &lt;= 0.05) {
				value = 0;
			} else if (ratio &gt;= 0.95) {
				value = width;
			}
			this._setCaret(value);
			this._setValue(value, true);
		};
<span id='$slider-method-_mouseDownCaret'>		/**
</span>   * Click on the caret event, binds mouse up over the document.
   *
   * @param {Event} e
   * @member $slider
   * @private
   * @method _mouseDownCaret
   */
		$slider.prototype._mouseDownCaret = function _mouseDownCaret(e) {
			$common.cancelEvents(e);
			this._setBCR();
			document.addEventListener(&quot;mousemove&quot;, this._binds.mouseMove);
			document.addEventListener(&quot;mouseup&quot;, this._binds.mouseUp);
		};
<span id='$slider-method-_mouseMove'>		/**
</span>   * Mouse move event over line holder - only if was clicked on the caret.
   *
   * @param {Event} e
   * @member $slider
   * @private
   * @method _mouseMove
   */
		$slider.prototype._mouseMove = function _mouseMove(e) {
			var caretEl = this._els.caret;
			var posX = this._getMouseXY(e).x;
			this._setCaret(posX);
			this._setValue(posX);
		};
<span id='$slider-method-_mouseUp'>		/**
</span>   * Mouse up event over the document.
   * 
   * @member $slider
   * @private
   * @method _mouseUp
   */
		$slider.prototype._mouseUp = function _mouseUp() {
			document.removeEventListener(&quot;mousemove&quot;, this._binds.mouseMove);
			document.removeEventListener(&quot;mouseup&quot;, this._binds.mouseUp);
		};
<span id='$slider-method-_mouseWheel'>		/**
</span>   * Mouse wheel event.
   *
   * @param {Event} e Mouse event
   * @private
   * @member $slider
   * @method _mouseWheel
   */
		$slider.prototype._mouseWheel = function _mouseWheel(e) {
			var delta = e.wheelDelta || -e.detail;
			if (!delta) {
				return;
			}
			$common.cancelEvents(e);
			if (delta &gt; 0) {
				this.setValue(this._value + this._opts.wheelStep);
				this._sendSignal();
			} else {
				this.setValue(this._value - this._opts.wheelStep);
				this._sendSignal();
			}
		};
<span id='$slider-method-_getPosFromValue'>		/**
</span>   * Get value -&gt; position convert.
   *
   * @param {Number} value Value in the range --&gt; [px] position for the caret.
   * @return {Number}
   * @member $slider
   * @private
   * @method _getPosFromValue
   */
		$slider.prototype._getPosFromValue = function _getPosFromValue(value) {
			value = value || this._value;
			var width = this._els.lineHolder.offsetWidth;
			var range = this._opts.max - this._opts.min;
			var posX = (value - this._opts.min) / range * width;
			return posX;
		};
<span id='$slider-method-_setValue'>		/**
</span>   * Set value using caret position. Fires signal &quot;change&quot;.
   *
   * @param {Number} posX Value on the axe x
   * @param {Boolean} [fromClick] It was called from click method?
   * @member $slider
   * @private
   * @method _setValue
   */
		$slider.prototype._setValue = function _setValue(posX, fromClick) {
			posX = posX || 0;
			var width = this._els.lineHolder.offsetWidth;
			var range = this._opts.max - this._opts.min;
			if (posX &lt; 0) {
				posX = 0;
			} else if (posX &gt; width) {
				posX = width;
			}
			var value = Math.round(posX / width * range + this._opts.min);
			this._value = value;
			this._els.input.value = value;
			this._els.input.classList.remove(&quot;error&quot;);
			this._sendSignal(!fromClick);
		};
<span id='$slider-method-_sendSignal'>		/**
</span>   * Delayed sending of signal.
   *
   * @param {Boolean} [withTimeout] Send with timeout?
   * @member $slider
   * @private
   * @method _sendSignal
   */
		$slider.prototype._sendSignal = function _sendSignal(withTimeout) {
			if (this._signalObj.id) {
				clearTimeout(this._signalObj.id);
				this._signalObj.id = null;
			}
			if (withTimeout) {
				this._signalObj.id = setTimeout(this._binds.sendSignalInner, this._opts.timeout);
			} else {
				this._sendSignalInner();
			}
		};
<span id='$slider-method-_sendSignalInner'>		/**
</span>   * Delayed sending of signal - inner method.
   *
   * @member $slider
   * @private
   * @method _sendSignalInner
   */
		$slider.prototype._sendSignalInner = function _sendSignalInner() {
			if (this._value == this._signalObj.lastValue) return;
			this._signalObj.lastValue = this._value;
			this.trigger(&quot;change&quot;, this._value);
		};
<span id='$slider-method-setValue'>		/**
</span>   * Set slider value.
   * 
   * @param {Number} value New value
   * @return {Boolean} If there was error, it returns false
   * @member $slider
   * @method setValue
   */
		$slider.prototype.setValue = function setValue(value) {
			if (typeof value === &quot;number&quot;) {
				value = $math.setRange(value, this._opts.min, this._opts.max);
				this._value = value;
				this._els.input.value = value;
				this._els.input.classList.remove(&quot;error&quot;);
				this._setCaret(this._getPosFromValue(value));
				return true;
			} else {
				return false;
			}
		};
<span id='$slider-method-getValue'>		/**
</span>   * Get slider value.
   * 
   * @return {Number}
   * @member $slider
   * @method getValue
   */
		$slider.prototype.getValue = function getValue() {
			return this._value;
		};
<span id='$slider-method-rewriteOpts'>		/**
</span>   * Overwrite configuration object.
   *
   * @param {Object} optsArg See constructor.
   * @member $slider
   * @method rewriteOpts
   */
		$slider.prototype.rewriteOpts = function rewriteOpts(optsArg) {
			for (var key in optsArg) {
				this._opts[key] = optsArg[key];
			}
			this._value = $math.setRange(this._value, this._opts.min, this._opts.max);
			this.setValue(this._value);
		};
		return $slider;
	}($event);
	;
	return $slider;
}]);
function _classCallCheck(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError(&quot;Cannot call a class as a function&quot;);
	}
}
onix.factory(&quot;$crop&quot;, [&quot;$dom&quot;, &quot;$math&quot;, &quot;$common&quot;, function ($dom, $math, $common) {
<span id='$crop'>	/**
</span>  *
  * Crop - this class is used for selection crop above the image/element.
  * 
  * @param {Object} [options] Configuration
  * @param {Number} [options.width = 250] Crop width
  * @param {Number} [options.height = 250] Crop height
  * @param {Number} [options.minWidth = 10] Crop min width, always higher than 0!
  * @param {Number} [options.minHeight = 10] Crop min height, always higher than 0!
  * @param {Number} [options.maxWidth = Infinity] Crop max width
  * @param {Number} [options.maxHeight = Infinity] Crop max height
  * @param {Boolean} [options.resizable = true] Crop can be resizabled by points
  * @param {Number} [options.aspectRatio = 0] Crop aspect ratio for width / height
  * @class $crop
  */
	var $crop = function () {
		function $crop(options) {
			_classCallCheck(this, $crop);
			this._CONST = {
				HIDE_CLASS: &quot;hide&quot;
			};
			this._options = {
				width: 250, // initial size
				height: 250,
				minWidth: 10,
				minHeight: 10, //  if resizable=true
				maxWidth: Infinity,
				maxHeight: Infinity,
				resizable: true,
				aspectRatio: 0
			};
			for (var op in options) {
				this._options[op] = options[op];
			}
			// areas dimensions
			this._dim = {
				areaWidth: 0,
				areaHeight: 0,
				width: this._options.width,
				height: this._options.height
			};
			this._changed = false;
			this._backupData = null;
			this._groups = {
				&quot;point-nw&quot;: [{ type: &quot;nw&quot;, x: true, y: true }, { type: &quot;sw&quot;, x: true }, { type: &quot;ne&quot;, y: true }],
				&quot;point-ne&quot;: [{ type: &quot;ne&quot;, x: true, y: true }, { type: &quot;se&quot;, x: true }, { type: &quot;nw&quot;, y: true }],
				&quot;point-sw&quot;: [{ type: &quot;sw&quot;, x: true, y: true }, { type: &quot;nw&quot;, x: true }, { type: &quot;se&quot;, y: true }],
				&quot;point-se&quot;: [{ type: &quot;se&quot;, x: true, y: true }, { type: &quot;ne&quot;, x: true }, { type: &quot;sw&quot;, y: true }]
			};
			this._points = { nw: { x: 0, y: 0 }, ne: { x: 0, y: 0 }, sw: { x: 0, y: 0 }, se: { x: 0, y: 0 } };
			this._type = null;
			this._mouse = {
				startXSave: 0,
				startYSave: 0,
				startX: 0,
				startY: 0
			};
			this._binds = {
				mouseDown: this._mouseDown.bind(this),
				mouseMove: this._mouseMove.bind(this),
				mouseUp: this._mouseUp.bind(this)
			};
			this._dom = {};
			this._create();
			this._dom.container.addEventListener(&quot;mousedown&quot;, this._binds.mouseDown);
			// crop is by default hidden
			this.hide();
		}
<span id='$crop-method-_create'>		/**
</span>   * Create crop element.
   * 
   * @return {Element}
   * @member $crop
   * @private
   * @method _create
   */
		$crop.prototype._create = function _create() {
			var cropClass = [&quot;crop&quot;];
			if (this._options.resizable) {
				cropClass.push(&quot;resizable&quot;);
			}
			$dom.create({
				el: &quot;div&quot;,
				&quot;class&quot;: cropClass,
				child: [{
					el: &quot;div&quot;,
					&quot;class&quot;: &quot;crop-top&quot;,
					child: [{
						el: &quot;span&quot;,
						&quot;class&quot;: &quot;point-nw&quot;
					}, {
						el: &quot;span&quot;,
						&quot;class&quot;: &quot;point-ne&quot;
					}],
					_exported: &quot;cropTop&quot;
				}, {
					el: &quot;div&quot;,
					&quot;class&quot;: &quot;crop-bottom&quot;,
					child: [{
						el: &quot;span&quot;,
						&quot;class&quot;: &quot;point-sw&quot;
					}, {
						el: &quot;span&quot;,
						&quot;class&quot;: &quot;point-se&quot;
					}],
					_exported: &quot;cropBottom&quot;
				}, {
					el: &quot;div&quot;,
					&quot;class&quot;: &quot;crop-left&quot;,
					_exported: &quot;cropLeft&quot;
				}, {
					el: &quot;div&quot;,
					&quot;class&quot;: &quot;crop-right&quot;,
					_exported: &quot;cropRight&quot;
				}, {
					el: &quot;div&quot;,
					&quot;class&quot;: &quot;crop-middle&quot;,
					_exported: &quot;cropMiddle&quot;
				}],
				_exported: &quot;container&quot;
			}, this._dom);
		};
<span id='$crop-method-_setCenter'>		/**
</span>   * Set crop center above his area.
   *
   * @private
   * @member $crop
   * @method _setCenter
   */
		$crop.prototype._setCenter = function _setCenter() {
			var width = this._dim.width;
			var height = this._dim.height;
			var leftDiff = Math.round((this._dim.areaWidth - width) / 2);
			var topDiff = Math.round((this._dim.areaHeight - height) / 2);
			var p = this._points;
			p.nw.x = leftDiff;
			p.nw.y = topDiff;
			p.ne.x = p.nw.x + width;
			p.ne.y = p.nw.y + height;
			p.sw.x = this._dim.areaWidth - leftDiff;
			p.sw.y = this._dim.areaHeight - topDiff;
			p.se.x = p.ne.x;
			p.se.y = p.ne.y;
		};
<span id='$crop-method-_alignPoints'>		/**
</span>   * Align crop points inside his area.
   * 
   * @private
   * @member $crop
   * @method _alignPoints
   */
		$crop.prototype._alignPoints = function _alignPoints() {
			var p = this._points;
			var w = this._dim.areaWidth - this._dim.width;
			var h = this._dim.areaHeight - this._dim.height;
			p.nw.x = $math.setRange(p.nw.x, 0, w);
			p.sw.x = $math.setRange(p.sw.x, 0, w);
			p.ne.x = $math.setRange(p.ne.x, this._dim.width, this._dim.areaWidth);
			p.se.x = $math.setRange(p.se.x, this._dim.width, this._dim.areaWidth);
			p.nw.y = $math.setRange(p.nw.y, 0, h);
			p.ne.y = $math.setRange(p.ne.y, 0, h);
			p.sw.y = $math.setRange(p.sw.y, this._dim.height, this._dim.areaHeight);
			p.se.y = $math.setRange(p.se.y, this._dim.height, this._dim.areaHeight);
		};
<span id='$crop-method-_redraw'>		/**
</span>   * Redraw crop - calculate all his points and set them in dom objects.
   * 
   * @private
   * @member $crop
   * @method _redraw
   */
		$crop.prototype._redraw = function _redraw() {
			var p = this._points;
			var leftX = p.nw.x;
			var leftY = p.nw.y;
			var size = this._getSize();
			this._dom.cropTop.style.left = leftX + &quot;px&quot;;
			this._dom.cropTop.style.width = size.width + &quot;px&quot;;
			this._dom.cropTop.style.height = leftY + &quot;px&quot;;
			this._dom.cropBottom.style.left = leftX + &quot;px&quot;;
			this._dom.cropBottom.style.width = size.width + &quot;px&quot;;
			this._dom.cropBottom.style.height = this._dim.areaHeight - p.sw.y + &quot;px&quot;;
			this._dom.cropLeft.style.width = leftX + &quot;px&quot;;
			this._dom.cropLeft.style.height = this._dim.areaHeight + &quot;px&quot;;
			this._dom.cropRight.style.width = this._dim.areaWidth - p.ne.x + &quot;px&quot;;
			this._dom.cropRight.style.height = this._dim.areaHeight + &quot;px&quot;;
			this._dom.cropMiddle.style.width = size.width + &quot;px&quot;;
			this._dom.cropMiddle.style.height = size.height + &quot;px&quot;;
			this._dom.cropMiddle.style.left = leftX + &quot;px&quot;;
			this._dom.cropMiddle.style.top = leftY + &quot;px&quot;;
		};
<span id='$crop-method-_mouseDown'>		/**
</span>   * Mouse down - move/resize crop.
   * 
   * @param  {Event} e
   * @private
   * @member $crop
   * @method _mouseDown
   */
		$crop.prototype._mouseDown = function _mouseDown(e) {
			$common.cancelEvents(e);
			// ie8
			var target = e.target || e.srcElement;
			this._type = target.getAttribute(&quot;class&quot;);
			switch (this._type) {
				case &quot;crop-top&quot;:
				case &quot;crop-bottom&quot;:
				case &quot;crop-left&quot;:
				case &quot;crop-right&quot;:
					return;
			}
			// save values during click
			this._mouse.startX = e.clientX;
			this._mouse.startY = e.clientY;
			this._mouse.startXSave = e.clientX;
			this._mouse.startYSave = e.clientY;
			document.addEventListener(&quot;mousemove&quot;, this._binds.mouseMove);
			document.addEventListener(&quot;mouseup&quot;, this._binds.mouseUp);
		};
<span id='$crop-method-_mouseMove'>		/**
</span>   * Mouse move - move/resize crop.
   * 
   * @param  {Event} e
   * @private
   * @member $crop
   * @method _mouseMove
   */
		$crop.prototype._mouseMove = function _mouseMove(e) {
			var _this = this;
			$common.cancelEvents(e);
			var diffX = e.clientX - this._mouse.startX;
			var diffY = e.clientY - this._mouse.startY;
			if (this._type == &quot;crop-middle&quot;) {
				// move
				Object.keys(this._points).forEach(function (key) {
					_this._points[key].x += diffX;
					_this._points[key].y += diffY;
				});
				this._alignPoints();
				this._redraw();
			} else {
				// resize - which group?
				var group = this._groups[this._type];
				if (this._options.aspectRatio) {
					diffY = diffX / this._options.aspectRatio * (this._type == &quot;point-nw&quot; || this._type == &quot;point-se&quot; ? 1 : -1);
				}
				if (this._resizeTest(diffX, diffY, group)) {
					group.forEach(function (i) {
						var point = _this._points[i.type];
						// add diffx, diffy to all group members
						point.x += i.x ? diffX : 0;
						point.y += i.y ? diffY : 0;
					});
					// update size
					var size = this._getSize();
					this._dim.width = size.width;
					this._dim.height = size.height;
					this._redraw();
				}
			}
			// overwrite
			this._mouse.startX = e.clientX;
			this._mouse.startY = e.clientY;
		};
<span id='$crop-method-_mouseUp'>		/**
</span>   * Mouse up - end of move/resize crop.
   * 
   * @param  {Event} e
   * @private
   * @member $crop
   * @method _mouseUp
   */
		$crop.prototype._mouseUp = function _mouseUp(e) {
			$common.cancelEvents(e);
			document.removeEventListener(&quot;mousemove&quot;, this._binds.mouseMove);
			document.removeEventListener(&quot;mouseup&quot;, this._binds.mouseUp);
			if (this._mouse.startXSave != e.clientX || this._mouse.startYSave != e.clientY) {
				// crop was changed
				this._changed = true;
			}
		};
<span id='$crop-method-_getSize'>		/**
</span>   * Get size of crop.
   * 
   * @param  {Object} [points] Points object, default is used crop points.
   * @return {Object}
   * @member $crop
   * @method _getSize
   */
		$crop.prototype._getSize = function _getSize(points) {
			points = points || this._points;
			return {
				width: Math.abs(points.ne.x - points.nw.x),
				height: Math.abs(points.sw.y - points.nw.y)
			};
		};
<span id='$crop-method-_resizeTest'>		/**
</span>   * Resize test - if returns false, crop size is on the edge of the area.
   * 
   * @param  {Number} diffX Increment on axe X
   * @param  {Number} diffY Increment on axe Y
   * @param  {Array[Object]} group Selected group from mouse down
   * @return {Boolean} false - error
   * @member $crop
   * @method _resizeTest
   */
		$crop.prototype._resizeTest = function _resizeTest(diffX, diffY, group) {
			var _this2 = this;
			if (!this._options.aspectRatio) {
				return false;
			}
			var points = {
				nw: {
					x: this._points.nw.x,
					y: this._points.nw.y
				},
				ne: {
					x: this._points.ne.x,
					y: this._points.ne.y
				},
				sw: {
					x: this._points.sw.x,
					y: this._points.sw.y
				},
				se: {
					x: this._points.se.x,
					y: this._points.se.y
				}
			};
			group.forEach(function (i) {
				var point = points[i.type];
				// add diffx, diffy to all group members
				point.x = _this2._points[i.type].x + (i.x ? diffX : 0);
				point.y = _this2._points[i.type].y + (i.y ? diffY : 0);
			});
			// min. and max. value
			var size = this._getSize(points);
			// test
			if (size.width &lt; this._options.minWidth || size.width &gt; this._options.maxWidth || size.height &lt; this._options.minHeight || size.height &gt; this._options.maxHeight || points.nw.x &lt; 0 || points.se.x &gt; this._dim.areaWidth || points.nw.y &lt; 0 || points.sw.y &gt; this._dim.areaHeight) {
				return false;
			} else {
				return true;
			}
		};
<span id='$crop-method-setCenter'>		/**
</span>   * Set crop center above his area.
   * 
   * @member $crop
   * @method setCenter
   */
		$crop.prototype.setCenter = function setCenter() {
			this._setCenter();
			this._redraw();
		};
<span id='$crop-method-fitToArea'>		/**
</span>   * Fit crop to whole area and center him on the screen.
   * 
   * @member $crop
   * @method fitToArea
   */
		$crop.prototype.fitToArea = function fitToArea() {
			var width = void 0;
			var height = void 0;
			if (this._options.aspectRatio) {
				var ratio = this._options.aspectRatio;
				// try width
				width = this._dim.areaWidth;
				height = Math.round(width / ratio);
				// try height
				if (height &gt; this._dim.areaHeight) {
					height = this._dim.areaHeight;
					width = Math.round(height * ratio);
				}
			} else {
				width = Math.min(this._options.maxWidth, this._dim.areaWidth);
				height = Math.min(this._options.maxHeight, this._dim.areaHeight);
			}
			// update dimensions
			this._dim.width = width;
			this._dim.height = height;
			// center and redraw
			this.setCenter();
		};
<span id='$crop-method-destroy'>		/**
</span>   * Remove crop from DOM.
   * 
   * @member $crop
   * @method destroy
   */
		$crop.prototype.destroy = function destroy() {
			var c = this.getContainer();
			if (c.parentNode) {
				c.parentNode.removeChild(c);
			}
			this._dom.container.removeEventListener(&quot;mousedown&quot;, this._binds.mouseDown);
		};
<span id='$crop-method-getContainer'>		/**
</span>   * Get crop root el.
   * 
   * @return {HTMLElement}
   * @member $crop
   * @method getContainer
   */
		$crop.prototype.getContainer = function getContainer() {
			return this._dom.container;
		};
<span id='$crop-method-setDim'>		/**
</span>   * Set crop area dimensions.
   * 
   * @param {Object} [dim]
   * @param {Number} [dim.areaWidth] Area width
   * @param {Number} [dim.areaHeight] Area height
   * @member $crop
   * @method setDim
   */
		$crop.prototype.setDim = function setDim(dim) {
			dim = dim || {};
			if (dim.areaWidth) {
				this._dim.areaWidth = dim.areaWidth;
				this._dom.container.style.width = this._dim.areaWidth + &quot;px&quot;;
			}
			if (dim.areaHeight) {
				this._dim.areaHeight = dim.areaHeight;
				this._dom.container.style.height = this._dim.areaHeight + &quot;px&quot;;
			}
		};
<span id='$crop-method-show'>		/**
</span>   * Show crop.
   *
   * @member $crop
   * @method show
   */
		$crop.prototype.show = function show() {
			this._dom.container.classList.remove(this._CONST.HIDE_CLASS);
		};
<span id='$crop-method-hide'>		/**
</span>   * Hide crop.
   *
   * @member $crop
   * @method hide
   */
		$crop.prototype.hide = function hide() {
			this._dom.container.classList.add(this._CONST.HIDE_CLASS);
		};
<span id='$crop-method-isVisible'>		/**
</span>   * Is crop visible?
   * 
   * @return {Boolean}
   * @member $crop
   * @method isVisible
   */
		$crop.prototype.isVisible = function isVisible() {
			return !this._dom.container.classList.contains(this._CONST.HIDE_CLASS);
		};
<span id='$crop-method-isChanged'>		/**
</span>   * Is crop changed?
   * 
   * @return {Boolean}
   * @member $crop
   * @method isChanged
   */
		$crop.prototype.isChanged = function isChanged() {
			return this._changed;
		};
<span id='$crop-method-backup'>		/**
</span>   * Backup current crop state - his position and change state.
   * 
   * @member $crop
   * @method backup
   */
		$crop.prototype.backup = function backup() {
			this._backupData = {
				changed: this._changed,
				aabb: this.getAABB()
			};
		};
<span id='$crop-method-restore'>		/**
</span>   * Restore crop saved state - his position and change state.
   * 
   * @member $crop
   * @method restore
   */
		$crop.prototype.restore = function restore() {
			if (this._backupData) {
				this._changed = this._backupData.changed;
				var aabb = this._backupData.aabb;
				var nw = this._points[&quot;nw&quot;];
				var ne = this._points[&quot;ne&quot;];
				var sw = this._points[&quot;sw&quot;];
				var se = this._points[&quot;se&quot;];
				// restore
				nw.x = aabb[0];
				nw.y = aabb[1];
				se.x = aabb[2];
				se.y = aabb[3];
				ne.x = se.x;
				ne.y = nw.y;
				sw.x = nw.x;
				sw.y = se.y;
				this._redraw();
				this._backupData = null;
			}
		};
<span id='$crop-method-getAABB'>		/**
</span>   * Get crop bounding box.
   * 
   * @param {Number} [scale=1] Recalculate all positions using scale constants, def. is 1
   * @return {Array} [x1, y1, x2, y2] 2 points coordinates from top left corner
   * @member $crop
   * @method getAABB
   */
		$crop.prototype.getAABB = function getAABB(scale) {
			var nw = this._points[&quot;nw&quot;];
			var se = this._points[&quot;se&quot;];
			scale = scale || 1.0;
			return [Math.round(nw.x * scale), Math.round(nw.y * scale), Math.round(se.x * scale), Math.round(se.y * scale)];
		};
		return $crop;
	}();
	;
	return $crop;
}]);</pre>
</body>
</html>
