<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">onix.factory(&quot;$$shadowDom&quot;, function() {
<span id='$$shadowDom'>	/**
</span>	 * TODO - not completed yet!
	 * 
	 * @param  {NodeElement} root Maping element
	 * @class $$shadowDom
	 */
	var $$shadowDom = function(root) {
		this._root = root;
	};

	$$shadowDom.prototype.map = function(el) {
		el = el || document.body;
		this._el = el;
		this._map(this._root, this._el);
	}

	$$shadowDom.prototype._toArray = function(nodelist) {
		return Array.prototype.slice.call(nodelist);
	}

	$$shadowDom.prototype._map = function(sdEl, el, dontC) {
		if (sdEl.parent &amp;&amp; !dontC) {
			el = this._createWCH(sdEl);
		}

		var childs = [];
		this._toArray(el.childNodes).forEach(function(child) {
			if (!(child.nodeName == &quot;#text&quot; &amp;&amp; !child.textContent.trim())) {
				childs.push(child);
			}
		});

		var nodeChilds = childs.length;
		var sdChilds = sdEl.child.length;

		var to = Math.max(nodeChilds, sdChilds);

		for (var i = 0; i &lt; to; i++) {
			var nodeChild = i &lt; childs.length ? childs[i] : null;
			var sdChild = i &lt; sdEl.child.length ? sdEl.child[i] : null;

			if (nodeChild &amp;&amp; !sdChild) {
				nodeChild.parentNode.removeChild(nodeChild);
			}
			else if (!nodeChild &amp;&amp; sdChild) {
				var child = this._createWCH(sdChild);

				el.appendChild(child);

				sdChild.child.forEach(function(subChild) {
					var newChild = this._map(subChild, child);
					child.appendChild(newChild);
				}, this);
			}
			else if (nodeChild &amp;&amp; sdChild) {
				// update
				this._update(sdChild, nodeChild);
			}
		}

		return el;
	};

	$$shadowDom.prototype._getDirectives = function() {
		return {
			&quot;onixik&quot;: true
		};
	};

	$$shadowDom.prototype._parseFnName = function(value) {
		value = value || &quot;&quot;;

		return value.match(/[a-zA-Z0-9_]+/)[0];
	};

	// create without children
	$$shadowDom.prototype._createWCH = function(sdEl) {
		// directives
		if (sdEl.el in this._getDirectives()) {
			console.log(&quot;custom directive &quot; + sdEl.el);
		}
		var newEl = sdEl.el != &quot;#text&quot; ? document.createElement(sdEl.el) : document.createTextNode(sdEl.text);

		// bind elements
		var be = [];

		Object.keys(sdEl.attrs || {}).forEach(function(name) {
			var value = sdEl.attrs[name];

			if (!value) {
				newEl[name] = true;
			}
			else {
				newEl.setAttribute(name, value);
			}

			// events
			switch (name) {
				case &quot;data-click&quot;:
					var fnName = this._parseFnName(value);

					console.log(&quot;data-click = &quot; + value + &quot;, &quot; + fnName);
					if (fnName in $scope) {
						newEl.addEventListener(&quot;click&quot;, function(e) {
							// todo parse click
							$scope[fnName].apply($scope, [e, this]);
						});
						be.push(&quot;click&quot;);
					}
					break;
			}
		});

		if (be.length) {
			// internal attribute
			newEl.setAttribute(&quot;data-onix-be&quot;, be.join(&quot;;&quot;));
		}

		return newEl;
	};

	$$shadowDom.prototype._update = function(sdEl, el) {
		// different elements
		if (sdEl.el != el.nodeName.toLowerCase()) {
			var newEl = this._map(sdEl, this._createWCH(sdEl));

			el.parentNode.insertBefore(newEl, el);
			el.parentNode.removeChild(el);
		}
		// same elements text
		else if (sdEl.el == &quot;#text&quot;) {
			el.textContent = templateBind(sdEl.text, $scope);
		}
		// same elements others
		else {
			var toRemove = {};

			Object.keys(el.attributes).forEach(function(attr) {
				var name = el.attributes[attr].name;

				// only for names; skip our
				if (name &amp;&amp; name != &quot;data-onix-be&quot;) {
					toRemove[name] = true;
				}
			});

			// set first
			var beData = (el.getAttribute(&quot;data-onix-be&quot;) || &quot;&quot;);
			var be;

			if (beData) {
				be = beData.split(&quot;;&quot;);
			}
			else {
				be = [];
			}

			Object.keys(sdEl.attrs).forEach(function(key) {
				var value = sdEl.attrs[key];
				el.setAttribute(key, value);
				delete toRemove[key];


				if (key == &quot;data-click&quot;) {
					console.log(&quot;aaa&quot;);
					if (be.indexOf(&quot;click&quot;) != -1) {
						// already bounded
					}
					else {
						var fnName = this._parseFnName(value);

						if (fnName in $scope) {
							el.addEventListener(&quot;click&quot;, function(e) {
								// todo parse click
								$scope[fnName].apply($scope, [e, this]);
							});
							be.push(&quot;click&quot;);
						}
					}
				}
			});

			// remove them
			Object.keys(toRemove).forEach(function(key) {
				el.removeAttribute(key);

				if (key == &quot;data-click&quot;) {
					el.removeEventListener(&quot;click&quot;);
					be.splice(be.indexOf(&quot;data-click&quot;), 1);
				}
			});

			if (be.length) {
				el.setAttribute(&quot;data-onix-be&quot;, be.join(&quot;;&quot;));
			}
			else {
				el.removeAttribute(&quot;data-onix-be&quot;);
			}

			// update children
			this._map(sdEl, el, true); // dont create parent el
		}
	};

	//var shadowDom = new $$shadowDom(root);
	//shadowDom.map();

	return $$shadowDom;
});
</pre>
</body>
</html>
