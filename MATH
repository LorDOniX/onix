this._CONST = {
	PAN_FACTOR: 0.5,
	ROTATE_FACTOR: 0.4,
	ZOOM_FACTOR: 0.35,
	ZOOM: 156543.034
};

cameraFOV 45

// zoom int 3-22...
Mapy.Left3D.prototype.zoomToDistance = function(zoom) {
	var resolution = this._CONST.ZOOM / Math.pow(2, zoom); // m/px
	var halfHeight = this._size.y / 2;
	var y = Math.floor(resolution * halfHeight);

	// potrebujeme pulku - je to ve stupnich - proto / 2 * / 180 na radiany [rad]; vertikalni fov - proto vyska
	var alfa = this._vadstena.getData("browserConfig").cameraFOV / 360 * Math.PI;

	return Math.floor(y / Math.tan(alfa));
};

// vzdalenost ve vadstene prepoctena na zoom
Mapy.Left3D.prototype.distanceToZoom = function() {
	var log2 = function(val) {
		return Math.log(val) / Math.log(2);
	};

	var distance = this._vadstena.getPosition()[2];
	var alfa = this._vadstena.getData("browserConfig").cameraFOV / 360 * Math.PI;
	var y = Math.tan(alfa) * distance;
	var mPPx = 2 * y / this._size.y; // distance / pulka size.y; pocet metru na pixel

	return Math.floor(log2(this._CONST.ZOOM / mPPx));
};

/**
 * Posune souradnice bodu x, y, o zadany uhel
 * @param  {number} x souradnice
 * @param  {number} y souradnice
 * @param  {number} angle uhel
 * @return {Object} bod posunuty o uhel
 */
SMap.Control.Pointer.prototype._movePointByAngle = function(x, y, angle) {
	var rad = angle / 180 * Math.PI;

	return {
		x: x * Math.cos(rad) - y * Math.sin(rad),
		y: x * Math.sin(rad) + y * Math.cos(rad)
	};
};

/**
 * Je v konfigu padding? Pokud ano, posuneme výslednou pozici kapky o tuto konstantu.
 * @param {object} point Souřadnice x a y
 * @param {number} angle Uhel natoceni
 */
SMap.Control.Pointer.prototype._setPadding = function(point, angle) {
	var dim = this._options.type.dimensions;

	var moveVector = this._movePointByAngle(0, dim.padding || 0, angle);

	point.x += moveVector.x;
	point.y += moveVector.y;

	return moveVector;
};

/**
	 * Check point inside bbox
	 * 
	 * @param  {SMap.Coords} point
	 * @param  {Array} bbox
	 * @return {Boolean}
	 */
	this._boundingBoxCheck = function(point, bbox) {
		return point[0] >= bbox[0] && point[0] <= bbox[2] && point[1] >= bbox[1] && point[1] <= bbox[3];
	};

